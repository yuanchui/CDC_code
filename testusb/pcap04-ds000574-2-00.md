

## PCap04  Capacitance-to-Digital Converter

General Description PCap04 is a capacitance-to-digital converter (CDC) with integrated digital signal processor (DSP) for on-chip data post-processing. Its front end is based on ams PICOCAP principle.

This conversion principle offers outstanding flexibility with respect to power consumption, resolution and speed. Further, PCap04 covers a wide capacitance input range from a few femtofarads up to several hundreds of nanofarads. It is easy to configure the PCap04 for different capacitance measurement tasks, i.e. single as well as differential sensors in both, grounded or floating connection. The on-chip DSP allows to implement sensor algorithms like linearization and temperature compensation, with data output in a digital (SPI or IIC) or analog (PDM/PWM) way.

Ordering Information and Content Guide appear at end of datasheet.

## Key Benefits & Features

The benefits and features of PCap04, Capacitance-to-Digital Converter are listed below:

Figure 1:

Added Value of Using PCap04

<table><tr><td>Benefits</td><td>Features</td></tr><tr><td>- High flexibility: Easy adaption to various applications - ultra low power, high resolution or high speed - just by configuration</td><td>- Up to 6 capacitors grounded, 3 capacitors floating - Capacitance range \( 1\mathrm{{pF}} \) to \( {100}\mathrm{{nF}} \) - Internal reference \( 1\mathrm{{pF}} \) to \( {31}\mathrm{{pF}} \) - Integrated guard driver</td></tr><tr><td>- High resolution or high speed</td><td>- Up to \( 8\mathrm{{aF}} \) at \( {2.5}\mathrm{\;{Hz}} \) and \( {10}\mathrm{{pF}} \) base capacitance - Up to \( {50}\mathrm{{kHz}} \) sample rate - Up to 20-bit resolution</td></tr><tr><td>- On-chip DSP for sensor algorithms, signal post-processing including linearization and temperature compensation</td><td>- 32-bit DSP - 3k ROM code, 1k NVRAM - 96 x 32 bit RAM - SPI / IIC interface - PDM / PWM outputs, GPIO</td></tr><tr><td>- On-chip and external temperature measurement capability</td><td>- Supply voltage 2.1/3.0V to 3.6V - Operating current down to \( {3\mu }\mathrm{A} \) - PCap04-Bxxx -40°C to \( {85}^{ \circ  }\mathrm{C} \) - PCap04-Axxx -40°C to \( {125}^{ \circ  }\mathrm{C} \) - QFN24 or die (1.588mm x 1.46mm)</td></tr></table>

ams Datasheet

[v1-03] 2018-Apr-04

## amm

## Applications MEMS Sensors

The PCap04 applications include:

- Position sensors

- Pressure sensors

- Force sensors

- Proximity sensor

- Acceleration sensors

- Inclination sensors

- Humidity sensors

- Dewpoint sensors

- Tilt sensors

- Angle sensors

- Wireless applications

- Level sensors

## Block Diagram

The functional blocks of this device are shown below:

Figure 2:

Functional Blocks of PCap04

![bo_d3r3s93ef24c73d0qhr0_1_198_1141_1294_652_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_1_198_1141_1294_652_0.jpg)

## Pin Assignments

Figure 3:

Pin Diagram of PCap04 Die

![bo_d3r3s93ef24c73d0qhr0_2_532_372_638_664_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_2_532_372_638_664_0.jpg)

(Changed "GUARD" and "ROSZ" to "nc" at Image above)

## Note(s):

1. Die dimensions: 1.588 mm x 1.46 mm (w/ seal) with pad pitch 120μm, pad opening is \( {85\mu }\mathrm{m} \times  {85\mu }\mathrm{m} \) . Thickness \( {290\mu }\mathrm{m} \) .

## Figure 4:

Pin Diagram of PCap04 QFN24

![bo_d3r3s93ef24c73d0qhr0_2_562_1408_573_590_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_2_562_1408_573_590_0.jpg)

## amm

Pin Description

Figure 5:

Pin Description of PCap04

<table><tr><td colspan="2">Pin Number</td><td rowspan="2">Pin Name</td><td rowspan="2">Description</td><td rowspan="2">If Not Used</td></tr><tr><td>Die</td><td>24-Pin QFN</td></tr><tr><td>1</td><td>24</td><td>PC2</td><td>CDC port</td><td>open</td></tr><tr><td>2</td><td>1</td><td>PC3</td><td>CDC port</td><td>open</td></tr><tr><td>3</td><td/><td>GND_H</td><td/><td>GND</td></tr><tr><td>4</td><td>2</td><td>GND</td><td/><td>GND</td></tr><tr><td>5</td><td/><td>VDD18_H</td><td/><td>VDD18</td></tr><tr><td>6</td><td>3</td><td>VDD18 (1)</td><td>Core supply voltage</td><td>VDD18</td></tr><tr><td>7</td><td>4</td><td>VDD33 (2)</td><td>I/O supply voltage</td><td>VDD33</td></tr><tr><td>8</td><td>5</td><td>PT1</td><td>RDC port (temperature sensor)</td><td>open</td></tr><tr><td>9</td><td>6</td><td>PTOREF</td><td>RDC port (temperature sensor or external reference)</td><td>open</td></tr><tr><td>10</td><td>7</td><td>PTOUT (3)</td><td>Discharge capacitor for RDC</td><td>open</td></tr><tr><td>11</td><td/><td>n.c.</td><td>No pad</td><td/></tr><tr><td>12</td><td/><td>n.c.</td><td>No pad</td><td/></tr><tr><td>13</td><td>8</td><td>GND</td><td/><td/></tr><tr><td>14/15</td><td/><td>n.c.</td><td>No pad</td><td/></tr><tr><td>16</td><td/><td>n.c.</td><td>Always open</td><td/></tr><tr><td>17</td><td>9</td><td>SSN_PG0</td><td>Serial select line. Otherwise, general purpose I/O port</td><td>open</td></tr><tr><td>18</td><td>10</td><td>MISO_PG1</td><td>Master in/Slave out when SPI is used. Otherwise, general purpose I/O port</td><td>open</td></tr><tr><td>19</td><td>11</td><td>PG5</td><td>General purpose I/O port</td><td>open</td></tr><tr><td>20</td><td>12</td><td>PG2</td><td>General purpose I/O port</td><td>open</td></tr><tr><td>21</td><td/><td>GND</td><td/><td>GND</td></tr><tr><td>22</td><td/><td>GND_ifc</td><td/><td>GND</td></tr><tr><td>23</td><td>13</td><td>IIC_EN</td><td>Serial interface select, \( 0 = \mathrm{{SPI}} \) enable 1 = IIC enable</td><td/></tr><tr><td>24</td><td>14</td><td>VDD33</td><td/><td>VDD33</td></tr></table>

<table><tr><td colspan="2">Pin Number</td><td rowspan="2">Pin Name</td><td rowspan="2">Description</td><td rowspan="2">If Not Used</td></tr><tr><td>Die</td><td>24-Pin QFN</td></tr><tr><td>25</td><td>15</td><td>MOSI_SDA</td><td>Master out/Slave in when SPI is used. Otherwise, serial data for IIC</td><td/></tr><tr><td>26</td><td/><td>n.c.</td><td>Always open</td><td/></tr><tr><td>27</td><td/><td>n.c.</td><td>Always open</td><td/></tr><tr><td>28</td><td>16</td><td>SCK_SCL</td><td>Serial clock for SPI/IIC</td><td/></tr><tr><td>29</td><td>17</td><td>PG3</td><td>General purpose I/O port</td><td>open</td></tr><tr><td>30</td><td>17</td><td>PG4</td><td>General purpose I/O port</td><td>open</td></tr><tr><td>31/32</td><td/><td>n.c.</td><td>No pad</td><td/></tr><tr><td>33</td><td>19</td><td>PCAUX</td><td>Auxiliary port - For external compensation capacitance or - External discharge resistor - Guarding output</td><td>open</td></tr><tr><td>34</td><td>20</td><td>PC4</td><td>CDC port</td><td>open</td></tr><tr><td>35</td><td>21</td><td>PC5</td><td>CDC port</td><td>open</td></tr><tr><td>36</td><td/><td>n.c.</td><td>Always open</td><td>open</td></tr><tr><td>37</td><td>22</td><td>PC0</td><td>CDC port</td><td>open</td></tr><tr><td>38</td><td>23</td><td>PC1</td><td>CDC port</td><td>open</td></tr></table>

Note(s):

1. Connect buffer capacitor \( \geq  {4.7\mu }\mathrm{F} \)

2. Connect buffer capacitor \( \geq  {10\mu }\mathrm{F} \)

3. Connect 10nF COG

4. Center pad is internally connected to GND. No wires other than GND are allowed underneath.

5. It is recommended to not use the center pad. Too much solder paste could reduce solder quality.

6. Suitable socket: e.g. Plastronics 32QN50S15050D.

## amm

Pad Coordinates

Figure 6:

Pad Coordinates of PCap04

<table><tr><td>Pad Number</td><td>Description</td><td>X-POS (μm)</td><td>Y-POS (μm)</td></tr><tr><td>1</td><td>PC2</td><td>260.0</td><td>59.5</td></tr><tr><td>2</td><td>PC3</td><td>380.0</td><td>59.5</td></tr><tr><td>3</td><td>GND_H</td><td>488.0</td><td>59.5</td></tr><tr><td>4</td><td>GND</td><td>608.0</td><td>59.5</td></tr><tr><td>5</td><td>VDD18_H</td><td>728.0</td><td>59.5</td></tr><tr><td>6</td><td>VDD18</td><td>848.0</td><td>59.5</td></tr><tr><td>7</td><td>VDD33</td><td>968.0</td><td>59.5</td></tr><tr><td>8</td><td>PT1</td><td>1088.0</td><td>59.5</td></tr><tr><td>9</td><td>PTOREF</td><td>1208.0</td><td>59.5</td></tr><tr><td>10</td><td>PTOUT</td><td>1328.0</td><td>59.5</td></tr><tr><td>11</td><td>n.c.</td><td>No pad</td><td>No pad</td></tr><tr><td>12</td><td>n.c.</td><td>No pad</td><td>No pad</td></tr><tr><td>13</td><td>GND</td><td>1528.5</td><td>501.0</td></tr><tr><td>14/15</td><td>n.c.</td><td>No pad</td><td>No pad</td></tr><tr><td>16</td><td>n.c.</td><td>No pad</td><td>No pad</td></tr><tr><td>17</td><td>SSN_PG0</td><td>1528.5</td><td>965.0</td></tr><tr><td>18</td><td>MICO_PG1</td><td>1528.5</td><td>1085.0</td></tr><tr><td>19</td><td>PG5</td><td>1528.5</td><td>1205.0</td></tr><tr><td>20</td><td>PG2</td><td>1333.0</td><td>1400.5</td></tr><tr><td>21</td><td>GND</td><td>1213.0</td><td>1400.5</td></tr><tr><td>22</td><td>GND_ifc</td><td>1093.0</td><td>1400.5</td></tr><tr><td>23</td><td>IIC_EN</td><td>973.0</td><td>1400.5</td></tr><tr><td>24</td><td>VDD33</td><td>853.0</td><td>1400.5</td></tr><tr><td>25</td><td>MOSI_SDA</td><td>733.0</td><td>1400.5</td></tr><tr><td>26</td><td>n.c.</td><td>No pad</td><td>No pad</td></tr><tr><td>27</td><td>n.c.</td><td>No pad</td><td>No pad</td></tr><tr><td>28</td><td>SCK_SCL</td><td>374.7</td><td>1400.5</td></tr></table>

<table><tr><td>Pad Number</td><td>Description</td><td>X-POS (μm)</td><td>Y-POS (μm)</td></tr><tr><td>29</td><td>PG3</td><td>254.7</td><td>1400.5</td></tr><tr><td>30</td><td>PG4</td><td>59.5</td><td>1205.0</td></tr><tr><td>31/32</td><td>n.c.</td><td>No pad</td><td>No pad</td></tr><tr><td>33</td><td>PCAUX</td><td>59.5</td><td>859.9</td></tr><tr><td>34</td><td>PC4</td><td>59.5</td><td>739.8</td></tr><tr><td>35</td><td>PC5</td><td>59.5</td><td>619.8</td></tr><tr><td>36</td><td>n.c.</td><td>No pad</td><td>No pad</td></tr><tr><td>37</td><td>PC0</td><td>59.5</td><td>379.8</td></tr><tr><td>38</td><td>PC1</td><td>59.5</td><td>259.8</td></tr></table>

Note(s):

1. Pad coordinates are center/center (x/y-direction), relative to die origin die dimensions: 1.588mm x 1.46mm (with seal,15μm each side) with pad pitch \( {120\mu }\mathrm{m} \) , pad opening is \( {85\mu }\mathrm{m} \times  {85\mu }\mathrm{m} \)

Absolute Maximum Ratings Stresses beyond those listed under Absolute Maximum Ratings may cause permanent damage to the device. These are stress ratings only. Functional operation of the device at these or any other conditions beyond those indicated under Electrical Characteristics is not implied. Exposure to absolute maximum rating conditions for extended periods may affect device reliability.

Figure 7:

Absolute Maximum Ratings

<table><tr><td>Symbol</td><td>Parameter</td><td>Min</td><td>Max</td><td>Units</td><td>Comments</td></tr><tr><td colspan="6">Electrical Parameters</td></tr><tr><td>\( {V}_{DD}/{V}_{GND} \)</td><td>Supply Voltage to Ground</td><td>-0.3</td><td>4.0</td><td>V</td><td/></tr><tr><td>\( {\mathrm{V}}_{\mathrm{{IN}}} \)</td><td>Input Pin Voltage to Ground</td><td>-0.3</td><td>4.0</td><td>V</td><td/></tr><tr><td>Iscr</td><td>Input Current (latch-up immunity) @125°C</td><td colspan="2">\( \pm  {100} \)</td><td>mA</td><td>JEDEC JESD78D Nov 2011</td></tr><tr><td colspan="6">Continuous Power Dissipation \( \left( {{\mathrm{T}}_{\mathrm{A}} = {70}^{ \circ  }\mathrm{C}}\right) \)</td></tr><tr><td>\( {P}_{T} \)</td><td>Continuous Power Dissipation</td><td/><td>1.44</td><td>mW</td><td/></tr><tr><td colspan="6">Electrostatic Discharge</td></tr><tr><td>\( {\mathrm{{ESD}}}_{\mathrm{{HBM}}} \)</td><td>Electrostatic Discharge HBM</td><td colspan="2">\( \pm  {1000} \)</td><td>V</td><td>JS-001-2014</td></tr><tr><td colspan="6">Temperature Ranges and Storage Conditions</td></tr><tr><td rowspan="3">\( {\mathrm{T}}_{\mathrm{A}} \)</td><td>Operating Ambient Temperature</td><td/><td/><td/><td/></tr><tr><td>PCap04-Bxxx</td><td>-40</td><td>85</td><td>℃</td><td/></tr><tr><td>PCap04-Axxx</td><td>- 40</td><td>125</td><td>℃</td><td/></tr><tr><td>\( {R}_{\text{THJA }} \)</td><td>Junction to Ambient Thermal Resistance</td><td/><td>28</td><td>℃/W</td><td/></tr><tr><td rowspan="2">\( {\mathrm{T}}_{\mathrm{j}} \)</td><td>Operating Junction Temperature PCap04-Bxxx</td><td/><td>85</td><td>℃</td><td/></tr><tr><td>PCap04-Axxx</td><td/><td>125</td><td>℃</td><td/></tr><tr><td>TSTRG</td><td>Storage Temperature Range</td><td>-55</td><td>150</td><td>℃</td><td/></tr></table>

<table><tr><td>Symbol</td><td>Parameter</td><td>Min</td><td>Max</td><td>Units</td><td>Comments</td></tr><tr><td>TBODY</td><td>Maximum Package Body Temperature during Reflow</td><td/><td>260</td><td>℃</td><td>IPC/JEDEC J-STD-020 The reflow peak soldering temperature (body temperature) is specified according to IPC/JEDEC J-STD-020 “Moisture/Reflow Sensitivity Classification for Non-hermetic Solid State Surface Mount Devices."The lead finish for Pb-free leaded packages is "Matte Tin" (100% Sn)</td></tr><tr><td>RHNC</td><td>Relative Humidity (non-condensing)</td><td>5</td><td>85</td><td>%</td><td/></tr><tr><td>MSL</td><td>Moisture Sensitivity Level</td><td colspan="2">3</td><td/><td>Maximum floor life time of 168h</td></tr><tr><td>TSTRG-DOF</td><td>Storage Time for DOF/die or wafers on foil</td><td/><td>3</td><td>months</td><td>Refers to indicated date of packing</td></tr><tr><td>TSTRG-DOF</td><td>Storage Temperature for DOF/die or wafers on foil</td><td>17</td><td>28</td><td>℃</td><td/></tr><tr><td>RHOPEN-DOF</td><td>Relative Humidity for DOF/die or wafers on foil in open package</td><td/><td>15</td><td>%</td><td>Opened package</td></tr><tr><td>\( {\mathrm{{RH}}}_{\mathrm{{UNOPEN}} - } \) DOF</td><td>Relative Humidity for DOF/die or wafers on foil in sealed package</td><td>40</td><td>60</td><td>%</td><td>Sealed bag</td></tr><tr><td>TSTRG-WP</td><td>Storage Time for WP/wafers or die in waffle pack</td><td/><td>6</td><td>months</td><td>17-28℃ 40-60% relative humidity storage in original Ultrapack boxes</td></tr><tr><td>tstrg-WP</td><td>Storage Time for WP/wafers or die in waffle pack</td><td/><td>2</td><td>years</td><td>19-25℃ <15% relative humidity storage in closed cabinet with dry air</td></tr><tr><td>tstrg-WP</td><td>Storage Time for WP/wafers or die in waffle pack</td><td/><td>5</td><td>years</td><td>19-25℃ <5% relative humidity storage in closed cabinet with dry air</td></tr><tr><td>TSTRG_____WP</td><td>Storage Time for WP/wafers or die in waffle pack</td><td/><td>10</td><td>years</td><td>19-25℃ <5% relative humidity storage in closed cabinet and closed Ultrapak box with safeguarded Nitrogen atmosphere</td></tr></table>

## Electrical Characteristics

Characteristics indicate conditions for which the device is guaranteed to be functional. For details on the test conditions see the notes at the table footer.

Figure 8:

Electrical Characteristics of PCap04

<table><tr><td>Symbol</td><td>Parameter</td><td>Conditions</td><td>Min</td><td>Typ</td><td>Max</td><td>Unit</td></tr><tr><td>\( {\mathrm{V}}_{\mathrm{{DD}}} \)</td><td>Supply Voltage (4)</td><td>Relative to GND Power-down: VDD has to be <0.05V before power-up</td><td>2.1</td><td/><td>3.6</td><td>V</td></tr><tr><td>\( {V}_{DD} \)</td><td>Supply Voltage</td><td>NVRAM recall -Bx: -40°C to 85°C -Ax: -40℃ to 125℃</td><td>2.5</td><td/><td>3.6</td><td>V</td></tr><tr><td>\( {V}_{DD} \)</td><td>Supply Voltage</td><td>NVRAM store -25℃ to 60℃</td><td>3.0</td><td/><td>3.6</td><td>V</td></tr><tr><td>VIO_DIGITAL</td><td>Digital Ports Input Voltage (4)</td><td>Relative to GND</td><td>-0.6</td><td>3.3</td><td>\( {V}_{DD} + {0.6} \) \( \leq  {3.6} \)</td><td>V</td></tr><tr><td>VIO_DIGITAL</td><td>Digital Ports Input Switching Levels (2)</td><td>HIGH to LOW LOW to HIGH</td><td>\( {0.7} * {\mathrm{\;V}}_{\mathrm{{DD}}} \)</td><td/><td>\( {0.3} * {V}_{DD} \)</td><td>V</td></tr><tr><td>\( {V}_{OH} \)</td><td>Digital Ports Output Voltage (2)</td><td>HIGH</td><td>\( {V}_{DD} - {0.4} \)</td><td/><td>\( {V}_{DD} + {0.1} \)</td><td>V</td></tr><tr><td>VOL</td><td>Digital Ports Output Voltage (2)</td><td>LOW</td><td>-0.1</td><td/><td>0.4</td><td>V</td></tr><tr><td>IeakH</td><td>Digital Ports Leakage (2)</td><td>IIC_EN=VDD HIGH</td><td>-0.1</td><td/><td>1.0</td><td>μA</td></tr><tr><td>IleakPU</td><td>Digital Ports Leakage (2)</td><td>Internal pull-ups</td><td>-2.8</td><td/><td>-5.2</td><td>μA</td></tr><tr><td>IleakL</td><td>Digital Ports Leakage (2)</td><td>IIC_EN=VDD LOW</td><td>-1.0</td><td/><td>0.1</td><td>μA</td></tr><tr><td/><td>Static Supply</td><td>-40°C \( {35}^{ \circ  }\mathrm{C} \)</td><td/><td>1.28 1.6</td><td>- 5</td><td rowspan="3">μA</td></tr><tr><td>ddq</td><td>Current (2)</td><td>\( {85}^{ \circ  }\mathrm{C} \)</td><td/><td>4.26</td><td>18</td></tr><tr><td/><td/><td>125°C</td><td/><td>22.5</td><td>50</td></tr><tr><td>\( {R}_{P} \)</td><td>Precharge Resistance (2)</td><td>R_C_PCHGO R_C_PCHG1</td><td>7 126</td><td>10 180</td><td>13 234</td><td>kOhm</td></tr><tr><td/><td/><td>R_DCHGO</td><td>7</td><td>10</td><td>13</td><td rowspan="3">kOhm</td></tr><tr><td>\( {R}_{D} \)</td><td>Discharge Resistance (2)</td><td>R_DCHG1 R DCHG2</td><td>21 63</td><td>30 90</td><td>39 117</td></tr><tr><td/><td/><td>R_DCHG3</td><td>126</td><td>180</td><td>234</td></tr></table>

<table><tr><td>Symbol</td><td>Parameter</td><td>Conditions</td><td>Min</td><td>Typ</td><td>Max</td><td>Unit</td></tr><tr><td>\( {\mathrm{C}}_{\text{ref0 }} \) \( {\mathrm{C}}_{\text{ref }1} \) \( {\mathrm{C}}_{\mathrm{{ref}}2} \) \( {\mathrm{C}}_{\mathrm{r}\mathrm{e}\mathrm{f}3} \) \( {\mathrm{C}}_{\mathrm{r}\mathrm{e}\mathrm{f}4} \)</td><td>Internal Reference (5)</td><td/><td/><td>0.4 1.4 3.4 7.4 15.4</td><td/><td>pF</td></tr><tr><td>\( {\mathrm{C}}_{\mathrm{R}} \)</td><td>Internal RDC Discharge Cap (2)</td><td>PTOUT n.c.</td><td>65</td><td>94</td><td>122</td><td>pF</td></tr><tr><td>IC_G7</td><td rowspan="3">Driver 7 Driver Low (3)</td><td>\( {PC0} = {V}_{DD} \)</td><td/><td>-3.5</td><td/><td rowspan="3">mA</td></tr><tr><td>IC_GLow</td><td>\( \mathrm{{PCO}} = {\mathrm{V}}_{\mathrm{{DD}}} * {0.05} \)</td><td/><td>-9</td><td/></tr><tr><td/><td>PCAUX \( = {V}_{DD} \)</td><td/><td/><td/></tr><tr><td>Vguardo VGUARD1</td><td rowspan="3">Gain Guarding Opamp (3)</td><td/><td/><td>1.00 1.01</td><td/><td rowspan="3">V</td></tr><tr><td>VGUARD2</td><td>PC0 = 1.0V</td><td/><td>1.02</td><td/></tr><tr><td>VguarD3</td><td/><td/><td>1.03</td><td/></tr><tr><td rowspan="4">R_DIS_SEN</td><td rowspan="4">RDC Temperature \( \mathsf{{Sensor}} \) (2) (6)</td><td>-40 °C</td><td>-</td><td>1047</td><td>-</td><td rowspan="4">Ohm</td></tr><tr><td>\( {35}^{ \circ  }\mathrm{C} \)</td><td>1120</td><td>1330</td><td>1680</td></tr><tr><td>\( {85}^{ \circ  }\mathrm{C} \)</td><td>1200</td><td>1572</td><td>1800</td></tr><tr><td>125 °C</td><td>1360</td><td>1688</td><td>2040</td></tr><tr><td>\( {R}_{R\_ {DIS}\_ {REF}} \)</td><td>RDC Reference (2)</td><td/><td>1100</td><td>1476</td><td>1690</td><td>Ohm</td></tr><tr><td>\( {\mathrm{C}}_{\mathrm{R}} \)</td><td>RDC Internal Capacitance (2)</td><td/><td>65</td><td>94</td><td>122</td><td>pF</td></tr><tr><td>fOLFO</td><td rowspan="4">OLF Frequency (2)</td><td>High temperature</td><td>3.6</td><td>10</td><td>16.5</td><td rowspan="4">kHz</td></tr><tr><td>fOLF1</td><td>minimum values, low</td><td>25</td><td>60</td><td>96.4</td></tr><tr><td>fOLF2</td><td>temperature maximum</td><td>47.6</td><td>100</td><td>171.4</td></tr><tr><td>foLF3</td><td>values</td><td>92.8</td><td>200</td><td>305</td></tr><tr><td>\( {\mathrm{f}}_{\mathrm{{OHF}}} \)</td><td>OHF Frequency (2)</td><td/><td>1.36</td><td>2</td><td>2.6</td><td>MHz</td></tr><tr><td rowspan="3"/><td>NVRAM Data Retention (4) (7)</td><td>3.0V to 3.6V</td><td/><td/><td/><td rowspan="3">Years</td></tr><tr><td>PCap04-Bxxx</td><td>\( {85}^{ \circ  }\mathrm{C} \)</td><td>20</td><td/><td/></tr><tr><td>PCap04-Axxx</td><td>125°C</td><td>20</td><td/><td/></tr><tr><td rowspan="5"/><td>NVRAM Endurance (4) (7)</td><td/><td/><td/><td/><td rowspan="5">Cycles</td></tr><tr><td>PCap04-Bxxx</td><td>\( {25}^{ \circ  }\mathrm{C} \)</td><td>\( {10}^{4} \)</td><td/><td/></tr><tr><td/><td>\( {85}^{ \circ  }\mathrm{C} \)</td><td>\( {10}^{3} \)</td><td/><td/></tr><tr><td>PCap04-Axxx</td><td>25 °C</td><td>\( {10}^{5} \)</td><td/><td/></tr><tr><td/><td>125 °C</td><td>\( {10}^{4} \)</td><td/><td/></tr></table>

## Note(s):

1.100% production tested

2.100% production tested at \( {85}^{ \circ  }\mathrm{C}\left( {-\mathrm{{Bxxx}}}\right) /{125}^{ \circ  }\mathrm{C}\left( {-\mathrm{{Axxx}}}\right) \) wafer sort and guaranteed by design and characterization at specified temperatures.

3. Sample tested only

4. Parameter is guaranteed by design and characterization testing.

5. Parameter is a typical value only

6. \( {100}\% \) production tested at \( {25}^{ \circ  }\mathrm{C} \) and guaranteed by design and characterization for industrial temperature range

7. Important: We guarantee the data for data retention and endurance only under the assumption, that the customer does not change the registers 62 and 63 and NVRAM adr 654 to 959 (Unique ID). In addition, it is mandatory to follow the given procedure for ERASE NVRAM as described in section NVRAM and ROM precisely. Otherwise, we do no longer guarantee the data retention time and endurance cycles.

Figure 9:

Total Current I [μA] as a Function of Conversion Rate (CONV_TIME) and Resolution (C_AVRG) in Triggered Mode

<table><tr><td rowspan="4">LP Oscillator Freq. [kHz]</td><td rowspan="4">CONV TIME</td><td rowspan="4">Measure Rate [Hz]</td><td colspan="6">I [μA]</td></tr><tr><td colspan="6">C AVRG (RMS Resolution [Bits])</td></tr><tr><td>1</td><td>4</td><td>16</td><td>64</td><td>256</td><td>1024</td></tr><tr><td>(13.6)</td><td>(14.6)</td><td>(15.6)</td><td>(16.6)</td><td>(17.8)</td><td>(18.6)</td></tr><tr><td>50</td><td>10000</td><td>2.5</td><td>2.3</td><td>2.5</td><td>2.7</td><td>4.6</td><td>11.8</td><td>44.0</td></tr><tr><td>50</td><td>2500</td><td>10</td><td>2.8</td><td>3.3</td><td>4.6</td><td>12.2</td><td>43.8</td><td/></tr><tr><td>50</td><td>1250</td><td>20</td><td>3.3</td><td>4.2</td><td>7.9</td><td>23.9</td><td/><td/></tr><tr><td>50</td><td>625</td><td>40</td><td>4.6</td><td>6.0</td><td>14.0</td><td/><td/><td/></tr><tr><td>50</td><td>250</td><td>100</td><td>8.3</td><td>12.0</td><td>32.2</td><td/><td/><td/></tr><tr><td>50</td><td>125</td><td>200</td><td>14.3</td><td>22.3</td><td/><td/><td/><td/></tr><tr><td>50</td><td>50</td><td>500</td><td>32.6</td><td>53.8</td><td/><td/><td/><td/></tr><tr><td>50</td><td>25</td><td>1000</td><td>63.9</td><td/><td/><td/><td/><td/></tr><tr><td>50</td><td>12</td><td>2080</td><td>90</td><td/><td/><td/><td/><td/></tr><tr><td>200</td><td>24</td><td>4160</td><td>156</td><td/><td/><td/><td/><td/></tr><tr><td>200</td><td>12</td><td>9320</td><td>305</td><td/><td/><td/><td/><td/></tr></table>

Note(s):

1. Temperature measurement in addition to capacitive measurement will add between \( {2\mu }\mathrm{A} \) and \( {10\mu }\mathrm{A} \) approximately, depending on speed. Total consumption values below \( {30\mu }\mathrm{A} \) may be obtained only when driving the on-chip 1.8 volts core supply generator in an energy-saving mode; ultimate microampere savings also demand to slow down the DSP. Typical data.

## CDC Characteristics

Figure 10:

Electrical Characteristics Note(s):

<table><tr><td rowspan="4">Rate [Hz]</td><td colspan="3">Floating Fully Compensated</td><td colspan="3">Grounded Internally Compensated</td></tr><tr><td rowspan="3">RMS Noise [aF]</td><td colspan="2">Eff. Resolution</td><td rowspan="3">RMS Noise [aF]</td><td colspan="2">Eff. Resolution</td></tr><tr><td colspan="2">[Bits]</td><td colspan="2">[Bits]</td></tr><tr><td>10pF Base</td><td>1pF Span</td><td>10pF Base</td><td>1pF Span</td></tr><tr><td>2.5</td><td>8</td><td>20.2</td><td>16.9</td><td>9</td><td>20.1</td><td>16.8</td></tr><tr><td>5</td><td>12</td><td>19.7</td><td>16.4</td><td>13</td><td>19.6</td><td>16.3</td></tr><tr><td>10</td><td>19</td><td>19.0</td><td>15.7</td><td>19</td><td>19.0</td><td>15.7</td></tr><tr><td>25</td><td>28</td><td>18.4</td><td>15.1</td><td>26</td><td>18.5</td><td>15.2</td></tr><tr><td>100</td><td>56</td><td>17.4</td><td>14.1</td><td>52</td><td>17.5</td><td>14.2</td></tr><tr><td>250</td><td>91</td><td>16.7</td><td>13.4</td><td>78</td><td>17.0</td><td>13.7</td></tr><tr><td>1000</td><td>156</td><td>16.0</td><td>12.7</td><td>148</td><td>16.0</td><td>12.7</td></tr><tr><td>2000</td><td>218</td><td>15.5</td><td>12.2</td><td>192</td><td>15.6</td><td>12.3</td></tr><tr><td>4000</td><td>328</td><td>14.9</td><td>11.6</td><td>272</td><td>15.1</td><td>11.8</td></tr><tr><td>8000</td><td/><td/><td/><td>385</td><td>14.6</td><td>11.3</td></tr></table>

1. Typical capacitive noise and resolution vs. output data rate, 10pF base + 1pF span, fast settle, MR1, V = 3.0V.Span means the maximum variation of the sensor capacitance in the application. The table gives the root mean-square (RMS) noise in aF as a function of output data rate in Hz, measured at 3.0V supply voltage using the maximum possible sample size for in-chip averaging at the minimum possible cycle time. Bit values are calculated as a binary logarithm of noise over the span (BITs = ln(span/noise)/ln(2)). The measurements have been done with the PCap04 evaluation board, with fixed C0G ceramic capacitors, configuration for maximum resolution.

Both, sensor and reference are connected "floating" or "grounded", as indicated. In floating mode compensation mechanisms for both internal and external stray capacitances are activated, in grounded mode only the internal compensation is active.

Figure 11:

Voltage-Dependent Offset Error (PSRR) ams Datasheet

<table><tr><td>Base /Gain</td><td>Mode</td><td>2.4V</td><td>2.7V</td><td>3.0V</td><td>3.3V</td><td>3.6V</td></tr><tr><td>10 pF</td><td rowspan="2">Single-ended, internal compensation</td><td>< 1fF</td><td>< 1fF</td><td>OfF</td><td>< 1fF</td><td><1fF</td></tr><tr><td>150 pF</td><td>< 1fF</td><td>< 1fF</td><td>OfF</td><td>< 1fF</td><td>< 1fF</td></tr><tr><td>10 pF</td><td rowspan="2">Floating, full compensation</td><td>< 1fF</td><td>< 1fF</td><td>OfF</td><td>< 1fF</td><td>< 1fF</td></tr><tr><td>150 pF</td><td>< 1fF</td><td>< 1fF</td><td>OfF</td><td>< 1fF</td><td>< 1fF</td></tr></table>

Figure 12:

Voltage-Dependent Gain Error (PSRR)

<table><tr><td>Base /Gain</td><td>Mode</td><td>2.4V</td><td>2.7V</td><td>3.0V</td><td>3.3V</td><td>3.6V</td></tr><tr><td>10pF / 4.7pF</td><td rowspan="2">Single-ended, internal compensation</td><td>1.9fF</td><td>0.9fF</td><td>OfF</td><td>- 0.7fF</td><td>- 1.2fF</td></tr><tr><td>150pF / 47pF</td><td>- 22fF</td><td>- 10fF</td><td>OfF</td><td>0.7fF</td><td>20fF</td></tr><tr><td>10pF / 4.7pF</td><td rowspan="2">Floating, full compensation</td><td>0.6fF</td><td>6fF</td><td>OfF</td><td>- 0.7fF</td><td>- 1.5fF</td></tr><tr><td>150pF / 47pF</td><td>- 11fF</td><td>- 11fF</td><td>OfF</td><td>8fF</td><td>19fF</td></tr></table>

Figure 13:

Temperature-Dependent Offset and Gain Error

<table><tr><td>Error Type</td><td>Capacitance [pF]</td><td>Mode</td><td>Temperature Range</td><td>Typ. Drift</td></tr><tr><td rowspan="4">Offset drift</td><td>10</td><td rowspan="2">Single-ended, internal compensation</td><td rowspan="8">-10°C to 85°C</td><td>2.5fF</td></tr><tr><td>150</td><td>9fF</td></tr><tr><td>10</td><td rowspan="2">Floating, full compensation</td><td>1.5fF</td></tr><tr><td>150</td><td>12fF</td></tr><tr><td rowspan="4">Gain drift</td><td>\( {10} + {4.7} \)</td><td rowspan="2">Single-ended, internal compensation</td><td>42fF = 94ppm/K</td></tr><tr><td>150 + 47</td><td>69fF = 15ppm/K</td></tr><tr><td>10 + 4.7</td><td rowspan="2">Floating, full compensation</td><td>8fF = 18ppm/K</td></tr><tr><td>150 + 47</td><td>96fF = 22ppm/K</td></tr></table>

RDC Characteristics

Figure 14:

Resolution RDC Unit

<table><tr><td>Measurement Conditions</td><td>R2/Rref Typ.</td><td>RMS Noise R2/Rref</td><td>Typical RMS Noise Temperature (1)</td></tr><tr><td>No averaging, 2 fake measurements</td><td>0.899</td><td>31.7ppm</td><td>12.2mK</td></tr><tr><td>16-fold averaging, 8 fake measurements</td><td>0.897</td><td>20.2ppm</td><td>7.8mK</td></tr><tr><td>Measurement conditions</td><td>10nF @ PTOUT, 25℃</td><td/><td/></tr></table>

Note(s):

1. After linearization in post-processing software Page 14

## am.

Typical linearity error with internal AI-thermometer after linearization and conversion into temperature, assuming a linear relation between temperature and resistivity:

---

- \( {20}^{ \circ  }\mathrm{C} < \) Temp. \( < {0}^{ \circ  }\mathrm{C} \rightarrow  {290}\mathrm{{mK}} \)

- \( {0}^{ \circ  }\mathrm{C} < \) Temp. \( < {80}^{ \circ  }\mathrm{C} \rightarrow  {110}\mathrm{{mK}} \)

---

## amm

## Timing Characteristics

Figure 15:

PCap04 Timing Characteristics

<table><tr><td>Symbol</td><td>Parameter</td><td>Conditions</td><td>Min</td><td>Typ</td><td>Max</td><td>Unit</td></tr><tr><td>tstart</td><td>Start-Up Time</td><td/><td>3.9</td><td/><td>4.0</td><td>ms</td></tr><tr><td>\( {\mathrm{t}}_{\mathrm{C}} \)</td><td>CDC Discharge Time</td><td>Measure range 1</td><td>0</td><td/><td>20</td><td>us</td></tr><tr><td>\( {\mathrm{t}}_{\mathrm{R}} \)</td><td>RDC Discharge Time</td><td>Measure range 1</td><td>0</td><td/><td>20</td><td>us</td></tr><tr><td>\( {f}_{\text{SPI }} \)</td><td>SPI Bus Frequency</td><td>Clock frequency</td><td>0</td><td/><td>20</td><td>MHz</td></tr><tr><td>\( {f}_{12} \) C</td><td>I \( {}^{2} \) C Bus Frequency</td><td>Data rate</td><td>0</td><td>100</td><td/><td>kHz</td></tr></table>

## Detailed Description

PCap04 is an integrated solution for digitizing capacitive and resistive sensors, including a DSP for data processing like linearization and temperature correction. A 6-channel CDC allows to handle grounded and floating sensors in single and differential mode. The capacitance range applicable is from a few pF to hundreds of nanofarads. The RDC unit is mainly intended for measuring temperature, by means of an internal sensor and reference or by means of external resistors like PT1000.

A 32-bit digital signal processor (DSP) in Harvard architecture is integrated to the PCap04. It is responsible for taking the information from the CDC and RDC measuring units, for processing the data and making them available to the user interface. Both, the CDC/RDC raw data as well as the data processed by the DSP are stored in the RAM. The program for the DSP is stored in the NVRAM. The DSP can collect various status information from a set of \( {64}\mathrm{l}/\mathrm{O} \) Bits and write back 16 of those. This way, the DSP can react on and also control the GPIO pins of PCap04. The DSP is internally clocked at approximately 60MHz. The internal clock is stopped through a firmware command, to save power. The DSP starts again upon a GPIO signal or an "end of measurement" condition.

In its simplest form, the DSP transfers the pure time measurement information from the CDC/RDC to the read registers without any further processing. The next higher step is to calculate the capacitance ratios including the information from the compensation measurements, as it is provided in ams standard firmware version PCap04_standard_v01.hex. Finally, ams provides a ready-made linearize firmware that performs a linearization via polynomial of third degree and temperature compensation via polynomial of second degree. Many functional blocks for the linearization firmware are implemented as ROM code. This way, the main firmware can be very compact and can fit into the \( 1\mathrm{\;k} \) NVRAM.

Figure 16:

CDC, RDC and DSP Embedding

![bo_d3r3s93ef24c73d0qhr0_16_445_1625_810_423_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_16_445_1625_810_423_0.jpg)

## amm

The content of the read registers will always depend on the firmware in use. With the standard firmware it will be the pure capacitance and resistance ratios. With the linearization firmware it might the linearized and calibrated result, e.g. a pressure given in Pascal or humidity given in percent.

The DSP is ams proprietary to cover low-power tasks as well as very high data rates. It is programmed in assembler. A user-friendly assembler software with a graphical interface, help text pop-ups as well as sample code sustain programming efforts.

## Register Description

## Configuration Registers

The PCap04 offers 48 registers for configuring the hardware (CDC, RDC, clocks, PDM/PWM, DSP). All these 48 registers are of one byte size. Additional four registers are used as special function registers. The \( {48}^{\text{th }} \) register contains nothing but one single bit, the RUNBIT, which enables/disables the front-end and the DSP.

All configurations are written simultaneously to registers and to the RAM Part of NVRAM and can be read back.

## Register Overview

Figure 17:

Register Overview

<table><tr><td>Addr</td><td>Name</td><td><D7></td><td><D6></td><td><D5></td><td><D4></td><td><D3></td><td><D2></td><td><D1></td><td><D0></td></tr><tr><td colspan="10">Configuration Registers</td></tr><tr><td>0</td><td>CFG0</td><td colspan="2">12C_A</td><td colspan="4">OLF_FTUNE</td><td colspan="2">OLF_CTUNE</td></tr><tr><td>1</td><td>CFG1</td><td>OX_DIS</td><td/><td>OX_DIV4</td><td>OX_ AUTOST OP_DIS</td><td>OX_STOP</td><td colspan="3">OX_RUN</td></tr><tr><td>2</td><td>CFG2</td><td colspan="2">RDCHG_INT_SEL1</td><td colspan="2">RDCHG_INT_SELO</td><td>RDCHG INT_EN</td><td/><td>RDCHG_ EXT_EN</td><td/></tr><tr><td>3</td><td>CFG3</td><td/><td>AUX PD_DIS</td><td>AUX _ CINT</td><td colspan="2">RDCHG _OPEN</td><td>RDCHG _ PERM _ EN</td><td>RDCHG_ EXT _ PERM</td><td>RCHG _ SEL</td></tr><tr><td>4</td><td>CFG4</td><td>C_REF_ INT</td><td/><td>C_ COMP_ EXT</td><td>C_ COMP_ INT</td><td/><td/><td>C_ DIFFERE NTIAL</td><td>C FLOATIN G</td></tr><tr><td>5</td><td>CFG5</td><td>CY_PRE_ MR1_ SHORT</td><td/><td>C_PORT_ PAT</td><td/><td>CY_ HFCLK_ SEL</td><td>CY DIV4_DIS</td><td>CY_PRE_ LONG</td><td>C_DC_ BALANCE</td></tr><tr><td>6</td><td>CFG6</td><td/><td/><td colspan="6">C_PORT_EN</td></tr><tr><td>7</td><td>CFG7</td><td colspan="8">C_AVRG<7:0></td></tr><tr><td>8</td><td>CFG8</td><td/><td/><td/><td colspan="5">C_AVRG<12:8></td></tr><tr><td>9</td><td>CFG9</td><td colspan="8">CONV_TIME<7:0></td></tr><tr><td>10</td><td>CFG10</td><td colspan="8">CONV_TIME<15:8></td></tr><tr><td>11</td><td>CFG11</td><td colspan="8">CONV_TIME<22:16></td></tr><tr><td>12</td><td>CFG12</td><td colspan="8">DISCHARGE_TIME<7:0></td></tr></table>

<table><tr><td>Addr</td><td>Name</td><td><D7></td><td><D6></td><td><D5></td><td><D4></td><td><D3></td><td><D2></td><td><D1></td><td><D0></td></tr><tr><td>13</td><td>CFG13</td><td colspan="2">C_STARTONPIN</td><td/><td colspan="3">C_TRIG_SEL</td><td colspan="2">DISCHARGE_TIME <9:8></td></tr><tr><td>14</td><td>CFG14</td><td colspan="8">PRECHARGE_TIME<7:0></td></tr><tr><td>15</td><td>CFG15</td><td/><td/><td colspan="4">C_FAKE</td><td colspan="2">PRECHARGE_TIME <9:8></td></tr><tr><td>16</td><td>CFG16</td><td colspan="8">FULLCHARGE_TIME <7:0></td></tr><tr><td>17</td><td>CFG17</td><td/><td colspan="5">C_REF_SEL</td><td colspan="2">DISCHARGE_TIME <9:8></td></tr><tr><td>18</td><td>CFG18</td><td>C_G_OP_ RUN</td><td>C_G_OP_ EXT</td><td colspan="6">C_G_EN</td></tr><tr><td>19</td><td>CFG19</td><td colspan="2">C_G_OP_VU</td><td colspan="2">C_G_OP_ATTN</td><td colspan="4">C_G_TIME</td></tr><tr><td>20</td><td>CFG20</td><td>R_CY</td><td/><td/><td/><td/><td colspan="3">C_G_OP_TR</td></tr><tr><td>21</td><td>CFG21</td><td colspan="8">R_TRIG_PREDIV<7:0></td></tr><tr><td>22</td><td>CFG22</td><td/><td colspan="3">R_TRIG_SEL</td><td colspan="2">R_AVRG</td><td colspan="2">R_TRIG_PREDIV <9:8></td></tr><tr><td>23</td><td>CFG23</td><td colspan="2">R_PORT_EN</td><td>R_PORT_ EN_IMES</td><td>R_PORT_ EN_IREF</td><td/><td>R_FAKE</td><td colspan="2">R_STARTONPIN</td></tr><tr><td>24</td><td>CFG24</td><td/><td/><td colspan="2">TDC_CHAN_EN</td><td>TDC ALUPER MOPEN</td><td>TDC_ NOISE_ DIS</td><td colspan="2">TDC_MUPU_SPEED</td></tr><tr><td>25</td><td>CFG25</td><td colspan="6">TDC_MUPU_NO</td><td/><td/></tr><tr><td>26</td><td>CFG26</td><td colspan="6">TDC_QHA_SEL</td><td>TDC_ NOISE_ CY_DIS</td><td/></tr><tr><td>27</td><td>CFG27</td><td colspan="2">DSP_MOFLO_EN</td><td/><td/><td colspan="2">DSP_SPEED</td><td>PG1x PG3</td><td>PG0x PG2</td></tr><tr><td>28</td><td>CFG28</td><td colspan="8">WD_DIS</td></tr><tr><td>29</td><td>CFG29</td><td colspan="4">DSP_STARTONPIN</td><td colspan="4">DSP_FF_IN</td></tr><tr><td>30</td><td>CFG30</td><td>PG5_ INTN_EN</td><td>PG4_ INTN_EN</td><td/><td/><td colspan="4">DSP_START_EN</td></tr><tr><td>31</td><td>CFG31</td><td>PI1_ TOGGLE_ EN</td><td>PIO_ TOGGLE_ EN</td><td colspan="2">PIO_RES</td><td>PIO PDM_SEL</td><td colspan="3">PIO_CLK_SEL</td></tr><tr><td>32</td><td>CFG32</td><td/><td/><td colspan="2">PI1_RES</td><td>PI1_ PDM_SEL</td><td colspan="3">PI1_CLK_SEL</td></tr><tr><td>33</td><td>CFG33</td><td colspan="4">PG_DIR_IN</td><td colspan="4">PG_PU</td></tr><tr><td>34</td><td>CFG34</td><td>INT_ TRIG_BG</td><td>DSP_ TRIG_BG</td><td>BG PERM</td><td>AUTO START</td><td colspan="4"/></tr></table>

<table><tr><td>Addr</td><td>Name</td><td><D7></td><td><D6></td><td><D5></td><td><D4></td><td><D3></td><td><D2></td><td><D1></td><td><D0></td></tr><tr><td>35</td><td>CFG35</td><td colspan="8">CDC_GAIN_CORR<7:0></td></tr><tr><td>36</td><td>CFG36</td><td colspan="8">-</td></tr><tr><td>37</td><td>CFG37</td><td colspan="8">-</td></tr><tr><td>38</td><td>CFG38</td><td colspan="8">BG_TIME</td></tr><tr><td>39</td><td>CFG39</td><td colspan="4">PULSE_SEL1</td><td colspan="4">PULSE_SELO</td></tr><tr><td>40</td><td>CFG40</td><td colspan="8">C_SENSE_SEL</td></tr><tr><td>41</td><td>CFG41</td><td colspan="8">R_SENSE_SEL</td></tr><tr><td>42</td><td>CFG42</td><td/><td>ALARM1 SEL ECT</td><td/><td>ALARMO SEL ECT</td><td>EN ASYNC RD</td><td>HS MODE SEL</td><td>R MEDIAN EN</td><td>C MEDIAN EN</td></tr><tr><td>...</td><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr><tr><td>47</td><td>CFG47</td><td/><td/><td/><td/><td/><td/><td/><td>RUNBIT</td></tr><tr><td>48</td><td>CFG48</td><td/><td/><td/><td/><td colspan="4">MEM_LOCK</td></tr><tr><td>49</td><td>CFG49</td><td colspan="8">SERIAL_NUMBER<7:0></td></tr><tr><td>50</td><td>CFG50</td><td colspan="8">SERIAL_NUMBER<15:8></td></tr><tr><td>...</td><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr><tr><td>54</td><td>CFG54</td><td colspan="8">MEM_CTRL</td></tr><tr><td>...</td><td/><td/><td/><td/><td/><td/><td/><td/><td/></tr><tr><td>62</td><td>CFG62</td><td colspan="8">CHARGE PUMP<7:0></td></tr><tr><td>63</td><td>CFG63</td><td colspan="8">CHARGE PUMP<15:8></td></tr></table>

<table><tr><td>Addr</td><td>Name</td><td><D7></td><td><D6></td><td><D5></td><td><D4></td><td><D3></td><td><D2></td><td><D1></td><td><D0></td></tr><tr><td colspan="10">Read Registers</td></tr><tr><td>0</td><td rowspan="4">RESO</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>1</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>2</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>3</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>4</td><td rowspan="4">RES1</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>5</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>6</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>7</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>8</td><td rowspan="4">RES2</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>9</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>10</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>11</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>12</td><td rowspan="4">RES3</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>13</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>14</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>15</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>16</td><td rowspan="4">RES4</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>17</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>18</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>19</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>20</td><td rowspan="4">RES5</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>21</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>22</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>23</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>24</td><td rowspan="4">RES6</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>25</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>26</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>27</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr></table>

<table><tr><td>Addr</td><td>Name</td><td><D7></td><td><D6></td><td><D5></td><td><D4></td><td><D3></td><td><D2></td><td><D1></td><td><D0></td></tr><tr><td>28</td><td rowspan="4">RES7</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>29</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>30</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>31</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>32</td><td>STATUS_0</td><td>POR FLAG WDG</td><td>POR FLAG CONFIG</td><td>IR FLAG COLL</td><td>AUTOBO OT</td><td/><td>RDC READY</td><td>CDC ACTIVE</td><td>RUNBIT</td></tr><tr><td>33</td><td>STATUS_1</td><td/><td/><td/><td/><td>RDC_ERR</td><td>MUP ERR</td><td>ERR OVFL</td><td>COMB ERR</td></tr><tr><td>34</td><td>STATUS_2</td><td/><td>C PORTERR _INT</td><td>C PORTERR 5</td><td>C PORTERR 4</td><td>C PORTERR 3</td><td>C PORTERR 2</td><td>C PORTERR 1</td><td>C PORTERR 0</td></tr></table>

Note(s):

1. Register 35 to 42 depend on the firmware. The values given are true for the standard firmware.

2. The content of the results registers depend on the firmware.

## amm

## Detailed Configuration Register Description

Configuration Register 0 (Address 0x0)

Figure 18:

Register 0

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:6</td><td>12C_A</td><td>0 to 3</td><td>Complement to the \( {\mathrm{I}}^{2}\mathrm{C} \) -address</td></tr><tr><td>5:2</td><td>OLF_FTUNE</td><td>0 : Minimum 7 : Typ., recommended 15 : Maximum</td><td>Fine-tune the low-frequency clock</td></tr><tr><td>1:0</td><td>OLF_CTUNE</td><td>0 : 10kHz 1 :50kHz 2 :100kHz 3 : 200kHz</td><td>Coarse-tune the low-frequency clock</td></tr></table>

Configuration Register 1 (Address 0x1)

Figure 19:

Register 1

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7</td><td>OX_DIS</td><td>Default : 0</td><td>Disable the OX clock</td></tr><tr><td>5</td><td>OX_DIV4</td><td>0 : No division; f_ox = 2MHz 1 : Division by 4 ; f_ox = 0.5MHz</td><td>OX clock frequency : Raw freq./ 4</td></tr><tr><td>4</td><td>OX_AUTOSTOP_DIS</td><td>Default : 0</td><td>ams internal bits</td></tr><tr><td>3</td><td>OX_STOP</td><td>Default : 0</td><td>ams internal bits</td></tr><tr><td>2:0</td><td>OX_RUN</td><td>0 : Generator off 6 : OX latency = 1 / fOLF 3 : OX latency = 2 / fOLF 2 : OX latency = 31 / fOLF 1 : OX runs permanently</td><td>Control the permanency or the latency of the OX generator. Latency means an oscillator settling time before a measurement starts</td></tr></table>

Configuration Register 2 (Address 0x2)

Figure 20:

Register 2

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:6</td><td>RDCHG_INT_SEL1</td><td rowspan="2">0 : 180kΩ 1 : 90kΩ 2 : 30kΩ (default) 3 : 10kΩ</td><td>Same, but for ports PC4 - PC5</td></tr><tr><td>5:4</td><td>RDCHG_INT_SELO</td><td>Choice of one out of 4 on-chip discharge resistors for the CDC ports PC0 - PC3 plus internal port PC6</td></tr><tr><td>3</td><td>RDCHG_INT_EN</td><td>0 : Off 1 : Internal on (default)</td><td>Enable internal discharge resistors</td></tr><tr><td>1</td><td>RDCHG_EXT_EN</td><td>0 : Off (default) 1 : External on</td><td>Enable external discharge resistor switching on PCAUX during discharge phase (High-Z during pre- and full-charge phase) Note: AUX_PD_DIS (PCAUX pull down disable) : 1</td></tr></table>

Configuration Register 3 (Address 0x3)

Figure 21:

Register 3

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>6</td><td>AUX_PD_DIS</td><td>0 : Pull-down active 1 : Pull-down disabled</td><td>Disable pull-down at PCAUX</td></tr><tr><td>5</td><td>AUX_CINT</td><td>0 : Normal (default) 1: Aux during c-internal active</td><td>Activates auxiliary Port PCAUX during internal c-reference conversion only</td></tr><tr><td>4:3</td><td>RDCHG_OPEN</td><td>2 : Recommended</td><td>ams internal bits</td></tr><tr><td>2</td><td>RDCHG_PERM_EN</td><td>0 : Off (default) 1 : On</td><td>Keep the chip-internal discharge resistor permanently connected.</td></tr><tr><td>1</td><td>RDCHG_EXT_PERM</td><td>0 : Off (default) 1 : On</td><td>Activates auxiliary Port PCAUX permanently for a) permanently discharge or b) to add an offset capacitance to every charge/discharge cycle Note: AUX_PD_DIS (PCAUX pull down disable) : 1</td></tr><tr><td>0</td><td>RCHG_SEL</td><td>0 : 180kΩ 1 : 10kΩ (default)</td><td>Choice of one out of 2 on-chip charging resistors for the CDC, permitting to limit the charging current, avoiding transients</td></tr></table>

## aml

Configuration Register 4 (Address 0x4)

Figure 22:

Register 4

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7</td><td>C_REF_INT</td><td>0: External reference at PC0/GND or PC0/PC1) 1: Internal reference</td><td>Use on-chip reference capacitor at CDC special ports PC6</td></tr><tr><td>5</td><td>C_COMP_EXT</td><td>0 : Idle 1 : Active; must be avoided when C_FLOATING==0</td><td>Activate the compensation mechanism for off-chip parasitic capacitances</td></tr><tr><td>4</td><td>C_COMP_INT</td><td>0 : Idle 1 : Active</td><td>Activate the compensation mechanism for on-chip parasitic capacitances and gain compensation</td></tr><tr><td>1</td><td>C_DIFFERENTIAL</td><td>0 : Ordinary 1 : Differential</td><td>Select between single or differential sensors</td></tr><tr><td>0</td><td>C_FLOATING</td><td>0 : Grounded 1 : Floating</td><td>Select between grounded or floating sensors</td></tr></table>

Configuration Register 5 (Address 0x5)

Figure 23:

Register 5

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7</td><td>CY_PRE_MR1_SHORT</td><td>0: Normal (recommended) 1 : Reduced</td><td>Reduce delays between internal clock paths</td></tr><tr><td>5</td><td>C_PORT_PAT</td><td>0 : Normal 1 : Alternating order of ports</td><td>The order of the measured ports will be reversed after each sequence. If C_ PORT_PAT is activated then C_AVRG + C_ FAKE should be an even number</td></tr><tr><td>3</td><td>CY_HFCLK_SEL</td><td>0 : OLF 1 : OHF</td><td>Clock source for the CDC</td></tr><tr><td>2</td><td>CY_DIV4_DIS</td><td>0 : Off 1 : On</td><td>Quadruple the clock period (only in combination with CY_HFCLK_ SEL == 1)</td></tr><tr><td>1</td><td>CY_PRE_LONG</td><td>0 : Off, recommended 1 : On</td><td>Adds safety delay between internal clock paths</td></tr><tr><td>0</td><td>C_DC_BALANCE</td><td>0 : Off ("single HiZ) 1 : DC free ("both HiZ)</td><td>Only for differential floating mode (other modi are DC free), changes port control to eliminate DC at Capacity sense</td></tr></table>

Note(s):

1. CY_HFCLK_SEL and CY_DIV4_DIS are combined in the evaluation software as 'Cycle Clock Select'

Configuration Register 6 (Address 0x6)

Figure 24:

Register 6

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>5:0</td><td>C_PORT_EN</td><td>0x00 : All off, the CDC will not work 0x01 : Only port PC0 is activated etc. 0x3F : All ports activated</td><td>Enables bitwise the CDC ports from PC0 to PC5, bit #0 for port PC0, #1 for PC1 etc.</td></tr></table>

Configuration Register 7:8 (Address 0x7, 0x8)

Figure 25:

Register 7:8

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>12:0</td><td>C_AVRG</td><td>0,1 : Sample size = 1 2 : Sample size \( = 2 \) 3 : Sample size \( = 3 \) ... 8191 : Maximum sample size</td><td>Sample size for averaging (calculating the mean value) over CDC measurements</td></tr></table>

Configuration Register 11:9 (Address 0x9;0xA;0xB)

Figure 26:

Register 11:9

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>22:0</td><td>CONV_TIME</td><td>Concerning CDC, a particular period for triggering the measurements \( {\mathrm{T}}_{\mathrm{{conv}}./\mathrm{{seq}}} = 2 * \mathrm{{CONV}} \) _____ TIME[..] / fOLF</td><td>Conversion trigger period or: sequence period (in stretched mode)</td></tr></table>

Configuration Register 12 (Address 0xC)

Figure 27:

Register 12

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0 & Reg.13: 1:0</td><td>DISCHARGE_TIME</td><td>OLF: \( {T}_{\text{discharge }} = \left( \text{DISCHARGE_TIME + 1}\right)  * {T}_{\text{cycleclock }} \) OHF: \( {T}_{\text{discharge }} = \left( \text{DISCHARGE_TIME + 0}\right)  * {T}_{\text{cycleclock }} \) 1023 : Off</td><td>Sets CDC discharge time Thischarge. Time interval reserved for discharge time measurement.</td></tr></table>

Configuration Register 13 (Address 0xD)

Figure 28:

Register 13

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:6</td><td>C_STARTONPIN</td><td>0 : PG0, 1 : PG1, 2 : PG2, 3 : PG3</td><td>Selection of the GPIO port that permits triggering a CDC start</td></tr><tr><td>4:2</td><td>C_TRIG_SEL</td><td>0 : Continuous 1 : Read triggered 2 : Timer triggered 3 : Timer triggered (stretched) 4 : n.d. 5 : Pin triggered 6 : Opcode triggered (7 : continuous_exp, not recommended)</td><td>CDC Trigger Mode</td></tr><tr><td>1:0 & Reg12: 7:0</td><td>DISCHARGE_TIME</td><td>See Register 12</td><td>See Register 12</td></tr></table>

Configuration Register 14 (Address 0xE)

Figure 29:

Register 14 Page 28 amsDatasheet

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0 & Reg.15: 1:0</td><td>PRECHARGE_TIME</td><td>OLF: \( {T}_{\text{precharge }} = \left( \text{PRECHARGE_TIME + 1}\right)  * {T}_{\text{cvcleclock }} \) OHF & FULLCHARGE_TIME = 1023: \( {T}_{\text{precharge}} = \left( {\text{PRECHARGE_TIME} + 2}\right)  * {T}_{\text{cycleclock}} \) OLF & FULLCHARGE_TIME!= 0x3FF: \( {T}_{\text{precharge }} = \left( \text{PRECHARGE_TIME + 1}\right)  * {T}_{\text{cvcleclock }} \) 1023: Off</td><td>Sets CDC discharge time Tprecharge- Time interval reserved for discharge time measurement.</td></tr></table>

Document Feedback

Configuration Register 15 (Address 0xF)

Figure 30:

Register 15

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>5:2</td><td>C_FAKE</td><td>0 : None 1 : 1 fake ... 15: 15 fakes</td><td>Number of "fake" or "warm-up" measurements for the CDC, performed just before the "real" ones; the "fake" values do not count</td></tr><tr><td>1:0 & Reg14: 7:0</td><td>PRECHARGE_TIME</td><td>See Register 14</td><td>See Register 14</td></tr></table>

Configuration Register 16 (Address 0x10)

Figure 31:

Register 16

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0 & Reg.17: 1:0</td><td>FULLCHARGE_TIME</td><td>OLF: \( {T}_{\text{fullcharge }} = \left( \text{FULLCHARGE_TIME + 1}\right)  * {T}_{\text{cvcleclock }} \) OHF: \( {T}_{\text{fullcharge }} = \left( \text{FULLCHARGE_TIME + 2}\right)  * {T}_{\text{cycleclock }} \)</td><td>Sets CDC discharge time \( {t}_{\text{fullcharge }} \) . Time interval reserved for discharge time measurement.</td></tr></table>

## Configuration Register 17 (Address 0x11)

Figure 32:

Register 17

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>1:0 & Reg.16: 7:0</td><td>FULLCHARGE_TIME</td><td>See Register 16</td><td>See Register 16</td></tr><tr><td>6:2</td><td>C_REF_SEL</td><td>0 : Minimum 1 : Approx.1 pF ... 31 : Maximum (approx. 31pF)</td><td>Setting the on-chip reference capacitor for the CDC Note: Step width varies from 0.3pF to 1.5pF</td></tr></table>

## aml

## Configuration Register 18 (Address 0x12)

Figure 33:

Register 18

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7</td><td>C_G_OP_RUN</td><td>Guard: OP Mode</td><td>0 : Permanent 1: Pulsed (set OP to sleep mode between conversions)</td></tr><tr><td>6</td><td>C_G_OP_EXT</td><td>Guard: Activate external OP</td><td>0 : Internal OP 1: External OP, PG3 as C_G_MUX_SEL</td></tr><tr><td>5:0</td><td>C_G_EN</td><td>Guard Enable, for each port</td><td>b'xxxxx1 : Activates port PC0 b'xxxx1x : Activates port PC1 b'xxx1xx : Activates port PC2 b'xx1xxx : Activates port PC3 b'x1xxxx : Activates port PC4 b'1xxxxx : Activates port PC5</td></tr></table>

Configuration Register 19 (Address 0x13)

Figure 34:

Register 19

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:6</td><td>C_G_OP_VU</td><td>Guard: OP gain (from Sense Port to Guard)</td><td>0 : x 1.00 1 : x 1.01 2 : x 1.02 3 : x 1.03</td></tr><tr><td>5:4</td><td>C_G_OP_ATTN</td><td>Guard: OP attenuation</td><td>0 : 0.5aF 1 : 1.0aF 2 : 1.5aF 3 : 2.0aF</td></tr><tr><td>3:0</td><td>C_G_TIME</td><td>Guard: Time during Precharge to switch Guard Port from "direct connected" to OP</td><td>t : C_G_TIME * 500ns</td></tr></table>

## Configuration Register 20 (Address 0x14)

Figure 35:

Register 20

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td colspan="3">Bit Description</td></tr><tr><td rowspan="5">7</td><td rowspan="5">R_CY</td><td rowspan="5">Cycle-time for the RDC Precharge/Charge/ Discharge, depending on OLF frequency</td><td>OLF f</td><td>R_CY=0</td><td>R_CY=1</td></tr><tr><td>10kHz</td><td>100μs</td><td>200μs</td></tr><tr><td>50kHz</td><td>20μs</td><td>40μs</td></tr><tr><td>100kHz</td><td>10μs</td><td>20μs</td></tr><tr><td>200kHz</td><td>20μs</td><td>40μs</td></tr><tr><td>2:0</td><td>C_G_OP_TR</td><td>Guard OP current trim</td><td colspan="3">0 : ... 7 : Recommended</td></tr></table>

Configuration Register 21 (Address 0x15)

Figure 36:

Register 21

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0 & Reg22: 1:0</td><td>R_TRIG_PREDIV</td><td>\( 0,1 : \) Every signal triggers 2 : Every 2 \( {}^{\text{nd }} \) signal triggers 3 : Every \( {3}^{\text{rd }} \) signal triggers ... 1023 : Maximum factor</td><td>Pre-divider, permits to make less temperature measurements than capacitance measurements. This is a factor between measurement rates of CDC over RDC. It is used also as OLF clock divider if OLF is used as trigger source.</td></tr></table>

Configuration Register 22(Address 0x16)

Figure 37:

Register 22

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>6:4</td><td>R_TRIG_SEL</td><td>0 : Off 1 : Timer triggered 3 : Pin triggered 5 : CDC asynchronous (recommended) 6 : CDC synchronous</td><td>Trigger source selection for the RDC 5 & 6: triggered by the end of CDC conversion</td></tr><tr><td>3:2</td><td>R_AVRG</td><td>0: Not averaged 1 : 4-fold averaged 2 : 8-fold averaged 3 : 16-fold averaged</td><td>Sample size for the mean value calculation (averaging) in the RDC part</td></tr><tr><td>1:0 & Reg21: 7:0</td><td>R_TRIG_PREDIV</td><td>0,1 : Every signal trigger 2 : Every 2 \( {}^{\text{nd }} \) signal triggers 3 : Every \( {3}^{\text{rd }} \) signal triggers ... 1023 : Maximum factor</td><td>Pre-divider, permits to make less temperature measurements than capacitance measurements. This is a factor between measurement rates of CDC over RDC. It is used also as OLF clock divider if OLF is used as trigger source.</td></tr></table>

Configuration Register 23 (Address 0x17)

Figure 38:

Register 23

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:6</td><td>R_PORT_EN</td><td>‘bx0 : Disabled ‘bx1 : Activates port PTOREF ‘b0x : Disabled ‘b1x : Activates port PT1</td><td>Port activation for the RDC part</td></tr><tr><td>5</td><td>R_PORT_EN_IMES</td><td>0 : Disabled 1 : Enabled</td><td>Port activation for internal aluminum temperature sensor</td></tr><tr><td>4</td><td>R_PORT_EN_IREF</td><td>0 : Disabled 1 : Enabled</td><td>Port activation for internal reference resistor</td></tr><tr><td>3</td><td>-</td><td>-</td><td>-</td></tr><tr><td>2</td><td>R_FAKE</td><td>0:2 fake cycles per average value 1: 8 fake cycle per average value</td><td>Number of "fake" or "warm-up" measurements for the RDC, performed just before the "real" ones; the "fake" values do not count</td></tr><tr><td>1:0</td><td>R_STARTONPIN</td><td>0 : PGO 1 : PG1, 2 : PG2 3 : PG3</td><td>Selection of the GPIO port that permits triggering a RDC start</td></tr></table>

Configuration Register 24 (Address 0x18)

Figure 39:

Register 24

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:6</td><td>-</td><td>-</td><td>-</td></tr><tr><td>5:4</td><td>TDC_CHAN_EN</td><td>Mandatory : 3</td><td>ams internal bits</td></tr><tr><td>3</td><td>TDC_ALUPERMOPEN</td><td>Mandatory : 0</td><td>ams internal bits</td></tr><tr><td>2</td><td>TDC_NOISE_DIS</td><td>Mandatory : 0</td><td>ams internal bits</td></tr><tr><td>1:0</td><td>TDC_MUPU_SPEED</td><td>Mandatory : 3</td><td>ams internal bits</td></tr></table>

## Configuration Register 25 (Address 0x19)

Figure 40:

Register 25

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:2</td><td>TDC_MUPU_NO</td><td>Mandatory : 1</td><td>ams internal bits</td></tr><tr><td>1:0</td><td>-</td><td>-</td><td>-</td></tr></table>

## Configuration Register 26 (Address 0x1A)

Figure 41:

Register 26

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:2</td><td>TDC_QHA_SEL</td><td>Mandatory : 20</td><td>ams internal bits</td></tr><tr><td>1</td><td>TDC_NOISE_CY_DIS</td><td>Mandatory : 1</td><td>ams internal bits</td></tr><tr><td>0</td><td>-</td><td>-</td><td>-</td></tr></table>

## Configuration Register 27 (Address 0x1B)

Figure 42:

Register 27

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:6</td><td>DSP_MOFLO_EN</td><td>0 : Off 3 : On</td><td>Enable the mono-flop (anti-bouncing filter)” in the GPIO pulse line.</td></tr><tr><td>5:4</td><td>-</td><td>-</td><td>-</td></tr><tr><td>3:2</td><td>DSP_SPEED</td><td>0 : Fastest 1 : Fast 2 : Slow, recommended 3 : Slowest</td><td>DSP speed</td></tr><tr><td>1</td><td>PG1xPG3</td><td>0 : Pulse output at PG3 1 : Pulse output at PG1</td><td>Switch PG1/PG3 wiring to/from DSP</td></tr><tr><td>0</td><td>PG0xPG2</td><td>0 : Pulse output at PG2 1 : Pulse output at PG0</td><td>Switch PG0/PG2 wiring to/from DSP</td></tr></table>

Configuration Register 28 (Address 0x1C)

Figure 43:

Register 28

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0</td><td>WD_DIS</td><td>0x5A : Watchdog disabled (off) 0x00 (recommended) / else : Watchdog enabled</td><td>Watchdog Disable, to disable Watchdog 0x5A has to be written to this register. The watchdog period is between 9s and 15s</td></tr></table>

## Configuration Register 29 (Address 0x1D)

Figure 44:

Register 29

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:4</td><td>DSP_STARTONPIN</td><td>Bitwise PG0 to PG3</td><td>Pin mask for starting the DSP - This mask permits assigning one or more GPIO pins to start the DSP</td></tr><tr><td>3:0</td><td>DSP_FF_IN</td><td>Bitwise DSP_IN_0 to DSP_ IN_3</td><td>Pin mask for flip-flop activation</td></tr></table>

## Configuration Register 30 (Address 0x1E)

Figure 45:

Register 30

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7</td><td>PG5_INTN_EN</td><td>0 : PG5 normal operation 1 : PG5 <== INTN</td><td>Route INTN Signal to PG5</td></tr><tr><td>6</td><td>PG4_INTN_EN</td><td>0 : PG4 normal operation 1 : PG4 <== INTN</td><td>Route INTN Signal to PG4</td></tr><tr><td>5:3</td><td>-</td><td>-</td><td>-</td></tr><tr><td>2:0</td><td>DSP_START_EN</td><td>'bxxx1 : Trigger by end of CDC 'bxx1x : Trigger by end of RDC (recommended) 'bx1xx : Trigger by timer</td><td>DSP Trigger Enable</td></tr></table>

## amm

Configuration Register 31 (Address 0x1F)

Figure 46:

Register x

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7</td><td>PI1_TOGGLE_EN</td><td>0 : Normal operation 1 : Toggle flip flop active</td><td>Activates toggle flip flop at Pulse Interface 1 Output especially for PDM to create 1:1 duty factor</td></tr><tr><td>6</td><td>PIO_TOGGLE_EN</td><td>0 : Normal operation 1 : Toggle flip flop active</td><td>Activates toggle flip flop at Pulse Interface 0 Output especially for PDM to create 1:1 duty factor</td></tr><tr><td>5:4</td><td>PIO_RES</td><td>0 : 10 bit 1 : 12 bit 2 : 14 bit 3 : 16 bit</td><td>Resolution of the pulse-code interfaces</td></tr><tr><td>3</td><td>PIO_PDM_SEL</td><td>0 : PWM 1 : PDM</td><td>Pulse Interface 0 PWM / PDM switch</td></tr><tr><td>2:0</td><td>PIO_CLK_SEL</td><td>0 : Off 1 : OLF / 1 2 : OLF / 2 3 : OLF / 4 4 : OX / 1 5 : OX / 2 6 : OX / 4 7 : n.d.</td><td>Pulse Interface 0 Clock Select</td></tr></table>

Configuration Register 32 (Address 0x20)

Figure 47:

Register 32

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:6</td><td>-</td><td>-</td><td>-</td></tr><tr><td>5:4</td><td>PI1_RES</td><td>0 : Off 1 : OLF / 1 2 : OLF / 2 3 : OLF / 4 4 : OX / 1 5 : OX / 2 6 : OX / 4 7 : n.d.</td><td>Pulse Interface 1 Clock Select</td></tr><tr><td>3</td><td>PI1_PDM_SEL</td><td>0 : PWM 1 : PDM</td><td>Resolution of the pulse-code interfaces</td></tr><tr><td>2:0</td><td>PI1_CLK_SEL</td><td>0 : 10 bit 1 : 12 bit 2 : 14 bit 3 : 16 bit</td><td>Pulse Interface 1 PWM / PDM switch</td></tr></table>

Configuration Register 33 (Address 0x21)

Figure 48:

Register 33

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:4</td><td>PG_DIR_IN</td><td>0 : Output 1 : Input</td><td>Toggles general-purpose port direction between input and output #4: PG0 #5: PG1 #6: PG2 #7: PG3</td></tr><tr><td>3:0</td><td>PG_PU</td><td>0 : Pull-up disabled 1 : Pull-up active</td><td>Activates protective pull-up resistors at general-purpose ports #0: PG0 #1: PG1 #2: PG2 #3: PG3</td></tr></table>

## aml

Configuration Register 34 (Address 0x22)

Figure 49:

Register 34

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7</td><td>INT_TRIG_BG</td><td>0 : Disabled 1 : Enabled</td><td>End of Reading triggers Bandgap</td></tr><tr><td>6</td><td>DSP_TRIG_BG</td><td>0 : Disabled 1 : Enabled</td><td>Bandgap refresh is triggered by the DSP bit setting</td></tr><tr><td>5</td><td>BG_PERM</td><td>1 : Bandgap permanent enabled 0 : Bandgap pulsed</td><td>Activate Bandgap permanently. With BG_PERM = 1 the current consumption rises by approx. \( {20\mu }\mathrm{A} \)</td></tr><tr><td>4</td><td>AUTOSTART</td><td>0 : Disabled 1 : CDC trigger after Power On</td><td>For standalone operation, triggers CDC after Power On</td></tr><tr><td>3:0</td><td>-</td><td>Mandatory : 7</td><td>ams internal bit</td></tr></table>

Configuration Register 35 (Address 0x23)

Figure 50:

Register 35

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0</td><td>CDC_GAIN_CORR[7:0]</td><td>Recommended \( {1.25} =  =  > \) 0x40</td><td>Firmware defined configuration of the gain correction factor. Bits 0 to 7 of 8fpp 0.0 n : 1 + n/256</td></tr></table>

Configuration Register 36 (Address 0x24)

Figure 51:

Register 36

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0</td><td>-</td><td/><td>Not used</td></tr></table>

## Configuration Register 37 (Address 0x25)

Figure 52:

Register 37

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0</td><td>-</td><td/><td>Not used</td></tr></table>

## Configuration Register 38 (Address 0x26)

Figure 53:

Register 38

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0</td><td>BG_TIME</td><td>0: Recommended</td><td>Firmware defined</td></tr></table>

## Configuration Register 39 (Address 0x27)

Figure 54:

Register 39

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:4</td><td>PULSE_SEL1</td><td>0 to 5 : Res0 to Res5 (C0..5 /Cref @PCap04_standard) 6 : Res6 (PT1/Ref @PCap04_ standard) 7 : Res7 (Alu/Ref @PCap04_ standard)</td><td>Firmware defined, select source for Pulse IF 1</td></tr><tr><td>3:0</td><td>PULSE_SELO</td><td>0 to 5 : Res0 to Res5 (C0..5 /Cref @PCap04_standard) 6 : Res6 (PT1/Ref @PCap04_ standard) 7 : Res7 (Alu/Ref @PCap04_ standard)</td><td>Firmware defined, select source for Pulse IF 0</td></tr></table>

Configuration Register 40 (Address 0x28)

Figure 55:

Register 40

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0</td><td>C_SENSE_SEL</td><td>PCap04_linearize firmware only, select \( \mathrm{C} \) ratio for linearization 0..5 : C0 to 5 / Cref</td><td>Firmware defined</td></tr></table>

## Configuration Register 41 (Address 0x29)

Figure 56:

Register 41

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0</td><td>R_SENSE_SEL</td><td>PCap04_linearize firmware only, select \( R \) ratio for temperature determination</td><td>Firmware defined</td></tr></table>

## Configuration Register 42 (Address 0x30)

Figure 57:

Register 42

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7</td><td>-</td><td rowspan="4">PCap04_linearize firmware only Polarity Select 0 : Z; 1 : Theta</td><td rowspan="4">Firmware defined. Select source of alarm signals at PG0 and PG1 Active High</td></tr><tr><td>6</td><td>ALARM1_SELECT</td></tr><tr><td>5</td><td>-</td></tr><tr><td>4</td><td>ALARMO_SELECT</td></tr><tr><td>3</td><td>EN_ASYNC_READ</td><td>1 : Active</td><td>Values in result registers Res0 to Res7 are only updated if the previous value has been read</td></tr><tr><td>2</td><td>HS_MODE_SEL</td><td>0 : Mandatory</td><td>ams internal bit</td></tr><tr><td>1</td><td>R_ MEDIAN_EN</td><td rowspan="2">PCap04_linearize firmware only</td><td rowspan="2">Enable median filters for ci/ri in linearize firmware</td></tr><tr><td>0</td><td>C_MEDIAN_EN</td></tr></table>

## Configuration Register 47 (Address 0x2F)

Figure 58:

Register 47

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:1</td><td>Not used</td><td/><td/></tr><tr><td>0</td><td>RUNBIT</td><td>0 : Off = the chip system is idle and protected 1 : On = the protection is removed, and the system may run</td><td>On/off switch for front-end and DSP: It should be "off" during programming and any registry modification, thus protecting the chip from any undesirable/unspecified states</td></tr></table>

Configuration Register 48 (Address 0x30)

Figure 59:

Register 48

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:4</td><td>Not used</td><td/><td/></tr><tr><td>3:0</td><td>MEM LOCK</td><td>'bxxx1 : NVRAM range `d0 to 703 'bxx1x : NVRAM range `d704 to 831 'bx1xx : NVRAM range `d832 to 959 'b1xxx : NVRAM range `d960 to 1007 and NVRAM range `d1022 to 1023</td><td>Data secure function to safe parts of NVRAM from reading and writing via SIF</td></tr></table>

## Configuration Register 49 (Address 0x31)

Figure 60:

Register 49

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0</td><td>SERIAL_NUMBER[7:0]</td><td>Free disposal for customer. Could only be written as far as the byte is zero. Afterwards it could just be cleared by an complete Erase</td><td>Lower byte reserved for serial number</td></tr></table>

Configuration Register 50 (Address 0x32)

Figure 61:

Register 50

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0</td><td>SERIAL_NUMBER[15:8]</td><td>Free disposal for customer. Could only be written as far as the byte is zero. Afterwards it could just be cleared by an complete Erase</td><td>Higher byte reserved for serial number</td></tr></table>

Configuration Register 51 to 53: ams internal Registers, 0x00 mandatory

## Configuration Register 54 (Address 0x36)

Figure 62:

Register 54 Configuration Register 55 to 61: ams internal Registers, 0x00 mandatory

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0</td><td>MEM_CTRL</td><td>0x2d : NVRAM store enable 0x59 : NVRAM recall enable 0xb8 : NVRAM erase Register is reset automatically after following SIF activity</td><td>Memory control</td></tr></table>

## Configuration Register 62 (Address 0x3e)

Figure 63:

Register 62

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0</td><td>CHARGE_PUMP[7:0]</td><td>Individual, device-specific setting. Not allowed to be changed</td><td>Lower byte of NVRAM charge pump trim</td></tr></table>

Configuration Register 63 (Address 0x3f)

Figure 64:

Register 63

<table><tr><td>Bit</td><td>Bit Name</td><td>Settings</td><td>Bit Description</td></tr><tr><td>7:0</td><td>CHARGE_PUMP[15:8]</td><td>Individual, device-specific setting. Not allowed to be changed</td><td>Higher byte of NVRAM charge pump trim</td></tr></table>

Important Note: We guarantee the data for data retention and endurance only under the assumption, that the customer does not change the registers 62 and 63. In addition, it is mandatory to follow the given procedure for ERASE NVRAM as described in section NVRAM and ROM precisely. Otherwise, we do no longer guarantee the data retention time and endurance cycles.

Read Registers

PCap04 has 35 byte of RAM for read access, combined as quadruples of 4 byte.

Figure 65:

Read Registers

<table><tr><td>Addr</td><td>Name</td><td><D7></td><td><D6></td><td><D5></td><td><D4></td><td><D3></td><td><D2></td><td><D1></td><td><D0></td></tr><tr><td>0</td><td rowspan="4">RESO</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>1</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>2</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>3</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>4</td><td rowspan="4">RES1</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>5</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>6</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>7</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>8</td><td rowspan="4">RES2</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>9</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>10</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>11</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>12</td><td rowspan="4">RES3</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>13</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>14</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>15</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>16</td><td rowspan="4">RES4</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>17</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>18</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>19</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>20</td><td rowspan="4">RES5</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>21</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>22</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>23</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr></table>

<table><tr><td>Addr</td><td>Name</td><td><D7></td><td><D6></td><td><D5></td><td><D4></td><td><D3></td><td><D2></td><td><D1></td><td><D0></td></tr><tr><td>24</td><td rowspan="4">RES6</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>25</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>26</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>27</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>28</td><td rowspan="4">RES7</td><td>7</td><td/><td/><td/><td/><td/><td/><td>0</td></tr><tr><td>29</td><td>15</td><td/><td/><td/><td/><td/><td/><td>8</td></tr><tr><td>30</td><td>23</td><td/><td/><td/><td/><td/><td/><td>16</td></tr><tr><td>31</td><td>31</td><td/><td/><td/><td/><td/><td/><td>24</td></tr><tr><td>32</td><td>STATUS_0</td><td>POR FLAG WDG</td><td>POR FLAG CONFIG</td><td>IR FLAG COLL</td><td>AUTOBO OT</td><td/><td>RDC READY</td><td>CDC_ ACTIVE</td><td>RUNBIT</td></tr><tr><td>33</td><td>STATUS_1</td><td/><td/><td/><td/><td>RDC_ ERR</td><td>MUP_ ERR</td><td>ERR_ OVFL</td><td>COMB_ ERR</td></tr><tr><td>34</td><td>STATUS_2</td><td/><td>C PORTER R_INT</td><td>C PORTER R5</td><td>C_ PORTER R4</td><td>C PORTER R3</td><td>C PORTER R2</td><td>C PORTER R1</td><td>C PORTER R0</td></tr></table>

The read registers are made of 7 result registers. Addresses 32 to 34 contain the status register.

## Result Registers

The content of the results registers depend on the firmware. The following describes the result registers as they are used by the standard firmware.

Figure 66:

Result Registers

<table><tr><td rowspan="2">Name</td><td rowspan="2">Length</td><td rowspan="2">Format</td><td colspan="2">Bit Description</td></tr><tr><td>Grounded C</td><td>Differential C</td></tr><tr><td>Res0</td><td rowspan="8">32 bits</td><td rowspan="8">E.g. \( \mathrm{C}0 = \) Unsigned fixed-point number: 5 bits integer 27 bits fractional Min = 0x0 = \( = {0.0000000} \) Max \( = \) 0xFFFFFFF \( = \) = 31.9999995</td><td>Ratio C0 / Cref</td><td>Ratio C1 / C0</td></tr><tr><td>Res1</td><td>Ratio C1 / Cref</td><td>C3/C2</td></tr><tr><td>Res2</td><td>C2 / Cref</td><td>C5/C4</td></tr><tr><td>Res3</td><td>C3 / Cref</td><td/></tr><tr><td>Res4</td><td>C4 / Cref</td><td>Zero</td></tr><tr><td>Res5</td><td>C5 / Cref</td><td>Zero</td></tr><tr><td>Res6</td><td>PT1/PTref</td><td>PT1/PTref</td></tr><tr><td>Res7</td><td>PTinternal/PTref</td><td>PTinternal/PTref</td></tr></table>

The user is free to assign any data to the results registers in his own firmware.

## Status Registers

Figure 67:

STATUS –0 (Address 32) amm

<table><tr><td>Bit</td><td>Bit Name</td><td>Bit Description</td></tr><tr><td>7</td><td>POR_Flag_Wdog</td><td>A watchdog overflow has been detected and has provoked a power-on reset. Perhaps the firmware has hung up in an unwanted endless loop or, more likely, a CDC/RDC trigger signal has been lost.</td></tr><tr><td>6</td><td>POR_Flag_Config</td><td>One or more configuration bits toggled by interferences and has provoked a power-on-reset.</td></tr><tr><td>5</td><td>POR_CDC_DSP_COLL</td><td>If a CDC sequence is triggered while DSP is still active an Initial Reset is provoked.</td></tr><tr><td>4</td><td>AutoBoot busy</td><td/></tr><tr><td>3</td><td/><td/></tr><tr><td>2</td><td>RDC ready</td><td/></tr><tr><td>1</td><td>CDC active</td><td>Warning: Traffic on interface may enhance noise in measurement</td></tr><tr><td>0</td><td>RUNBIT</td><td>The RUNBIT from write register 47 is mirrored here</td></tr></table>

Figure 68:

STATUS 1 (Address 33)

<table><tr><td>Bit</td><td>Bit Name</td><td>Bit Description</td></tr><tr><td>7:4</td><td>n.c.</td><td>Test bits</td></tr><tr><td>3</td><td>RDC_Err</td><td>Some kind of error occurred when the RDC unit was busy</td></tr><tr><td>2</td><td>Mup_Err</td><td>A particular kind of TDC error occurred when the CDC unit was busy</td></tr><tr><td>1</td><td>Err_OvfI</td><td>An overflow error occurred when the CDC unit was busy</td></tr><tr><td>0</td><td>Comb_Err</td><td>All error bits, from here onward, disjunctively combined (using bit-or)</td></tr></table>

Figure 69:

STATUS_2 (Address 34)

<table><tr><td>Bit</td><td>Bit Name</td><td>Port</td><td>Bit Description</td></tr><tr><td>6</td><td>C_PortError Internal Reference</td><td>PC internal ref</td><td rowspan="7">In the CDC unit, one or several ports are affected by some error like a short-circuit to ground. May also be a charge/ discharge resistivity too big, a capacitance too big, or an ill-defined precharge/fullcharge/discharge time.</td></tr><tr><td>5</td><td>C_PortError5</td><td>PC5</td></tr><tr><td>4</td><td>C_PortError4</td><td>PC4</td></tr><tr><td>3</td><td>C_PortError3</td><td>PC3</td></tr><tr><td>2</td><td>C_PortError2</td><td>PC2</td></tr><tr><td>1</td><td>C_PortError1</td><td>PC1</td></tr><tr><td>0</td><td>C_PortError0</td><td>PC0</td></tr></table>

## Principles of Operation

## Converter Frontend

The device uses "discharge time measurement" as a principle for measuring either capacitances (CDC unit) or resistances (RDC unit). It addresses all ports (PC..., PT...) in time multiplex, the time measurement being done by means of a high-resolution TDC (time-to-digital converter).

## Capacitance-to-Digital Converter (CDC)

Measuring Principle

In PCap04, capacitance measurement is done by measuring discharge times of RC-networks. The measurements are ratiometric. This means that the capacitors are compared to a fixed reference or, like in differential sensors, to capacitors with change in opposite direction. Thanks to the short time intervals and special compensation methods, the ratio of discharge times is directly proportional to the ratio of capacitors. The discharge time is defined by the capacitor and the selected discharge resistor.

(EQ1) \( \frac{{\tau }_{N}}{{\tau }_{ref}} = \frac{{C}_{N}}{{C}_{ref}}\;\tau  = k \times  R \times  C \)

Connecting Sensors

PCap04 can handle single and differential sensors in grounded or floating connection. PCap04 has integrated reference capacitors. They are programmable in a range from \( 1\mathrm{{pF}} \) to \( {31}\mathrm{{pF}} \) in steps of 1pF.

Figure 70:

Connecting Sensors

![bo_d3r3s93ef24c73d0qhr0_46_205_1467_1283_613_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_46_205_1467_1283_613_0.jpg)

## amm

Discharge Resistors

The PCap04 has two sets of discharge resistors already integrated. One resistor set \( \left( {{10}\mathrm{k}/{30}\mathrm{k}/{90}\mathrm{k}/{180}\mathrm{k}\text{ohm}}\right) \) is for measurements on port PC0 to PC3 and the internal reference port PC6. The other resistor set \( \left( {{10}\mathrm{k}/{30}\mathrm{k}/{90}\mathrm{k}/{180}\mathrm{k}\text{ohm}}\right) \) is for ports PC4 and PC5. This way, it is possible to measure different sensors with strongly deviated capacitance like pressure and humidity with one and the same chip. Parameters RCHG_xxx select the resistors. Cycle

Figure 71:

Integrated Discharge Resistors

![bo_d3r3s93ef24c73d0qhr0_47_427_752_835_576_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_47_427_752_835_576_0.jpg)

The user can define which resistor he uses for the internal compensation measurement. It is selected by DSP_RDCHG_ COMP_INT_SEL (0 = RCHG0 (default),1 = RCHG1).

There is the possibility to use an external discharge resistor for handling big capacitances.

In PCap04 the measurement principle is based on a three-step cycle.

- In the pre-charge phase the capacitor is charged up via a series resistor to a level close to Vdd. The resistor reduces the charge current and reduces the mechanical stress on the sensing capacitor. This can be necessary in some MEMS applications. Further, this is a measure to detect a short circuit and to limit the current even in such an error case.

- In full-charge phase, the capacitor is charged up finally to Vdd without any series resistor.

- Then, in the third step, the capacitor is discharged via the discharge resistor down to 0V. The CDC measures the time interval until a trigger level is reached. All this is called a single "cycle".

Figure 72:

Single Cycle Timing

![bo_d3r3s93ef24c73d0qhr0_48_494_1003_702_382_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_48_494_1003_702_382_0.jpg)

In applications that do not need the slow charge up but high conversion rate, it is possible to disable the pre-charge option and to start charge up directly without any series resistor.

Figure 73:

Single Cycle, Fast Charge

![bo_d3r3s93ef24c73d0qhr0_49_489_373_708_363_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_49_489_373_708_363_0.jpg)

In both cases the capacitors are discharged for the full discharge time period and then connected to GND.

In case of a short circuit, the voltage never reaches the trigger level of the comparator. In such a case the measurement cycle is stopped, no low-resistive full-charge follows. This way the current in a short-circuit case is limited. Sequence

Figure 74:

Short Circuit Detection

![bo_d3r3s93ef24c73d0qhr0_49_463_1312_773_428_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_49_463_1312_773_428_0.jpg)

A "sequence" is made of a set of cycles, namely those for the various active ports as well as combinations of them as given by the compensation measurements. The number and kind of single cycles depend on the way of how the sensors are connected, the number of capacitors and the selected compensation options.

For grounded sensors, the sequence starts always with PCO (reference) and then one or more of the other 5 ports. Normally, internal compensation is activated. So the sequence ends with the measurement Cint of the internal stray capacitance/delays. For compensating internal parasitic capacitance and the comparator delay the CDC measures the discharge time with all ports being off (Cint).

The following figure shows the sequence for a grounded sensor with internal compensation.

Figure 75:

Sequence Grounded

![bo_d3r3s93ef24c73d0qhr0_50_546_1011_603_361_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_50_546_1011_603_361_0.jpg)

Sequence for 1 reference and 1 sensor in grounded connection, compensated for internal capacitance

For floating sensors, the sequence starts always with PCO/PC1 (reference), followed by one to three pairs of ports for the sensors. Normally, both compensations (internal and external) are activated.

For compensation of external parasitic capacitances the CDC makes a measurement for each capacitor with both ports being opened. So, for each capacitor 3 measurements are made, e.g. \( \mathrm{{PC}}0,\mathrm{{PC}}1 \) and \( \mathrm{{PC}}0 + \mathrm{{PC}}1 \) . The sequence ends with the internal compensation measurement Cint. The following figures show the sequence for 1 floating sensor with full compensation.

Figure 76:

Sequence Floating

![bo_d3r3s93ef24c73d0qhr0_51_348_378_992_364_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_51_348_378_992_364_0.jpg)

Sequence for 1 reference and 1 sensor in floating connection, fully compensated for parasitic capacitances

Conversion

Finally, the combination of various sequences and delays in between the sequences define a single "conversion". Once triggered, a conversion is automatically completed, including all fake measurements and all real measurements defined by sample size for averaging. At the end of a conversion the measurement results are ready for further processing and readout. The end of the conversion is indicated by flag to the DSP and also the RDC unit.

Figure 77:

Cycle-Sequence-Conversion

![bo_d3r3s93ef24c73d0qhr0_51_197_1376_1295_597_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_51_197_1376_1295_597_0.jpg)

## amm

Various sources are available to trigger the CDC.

- Continuous mode: In this mode the CDC starts automatically after POR. The end of the DSP processing triggers directly the next measurement. This mode allows the fastest sample rate, but with the risc that communication will continue while the next measurement is started. Noise will increase.

- Read triggered mode: In this mode the very first measurement is triggered via SIF. When the measurement is completed the interrupt goes LOW. An external microcontroller can react on this and read the data. The end of the read via SIF triggers the next measurement. This mode allows fastest measurement without having the interface disturb the measurement.

- Timer triggered mode: In this mode the PCAP04 timer triggers the measurements. This is preferred in applications with low sample rate.

- Opcode or pin triggered mode: In this mode the external microcontroller has full control on when measurements are triggered. This might be valuable when the measurement needs to be synchronized with other tasks.

Figure 78:

Conversion Modes

![bo_d3r3s93ef24c73d0qhr0_53_208_267_1277_1473_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_53_208_267_1277_1473_0.jpg)

## CDC Compensation Options

Internal Compensation

For the internal compensation measurement, both switches A1 and A0 are open. Only the internal parasitic capacitance and the comparator propagation delay will thus be measured.

It is recommended to have internal compensation active in any application.

Figure 79:

Internal Compensation Measurement

![bo_d3r3s93ef24c73d0qhr0_54_579_683_528_494_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_54_579_683_528_494_0.jpg)

## External Compensation

With floating capacitors we have the additional option to compensate external parasitic capacitances against ground. On the PCB, the wire capacitance typically refers to ground. For long wires, it is recommended to use shields which should be grounded at their PCB side.

## Figure 80:  Shielded Cables

![bo_d3r3s93ef24c73d0qhr0_54_597_1714_499_287_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_54_597_1714_499_287_0.jpg)

How to connect shielded cables for compensation of the external parasitic capacitances.

amm

Three measurements are necessary for each capacitor in case of floating sensors. This is shown in the Figure 81. First, the electrode at PC0 is loaded to VDD18. The discharge time is defined by the sensor capacitance, the parasitic capacitance of the connection, including the chip pad, and the internal capacitance. Second, the same measurement is done for the electrode at PC1. Third, both electrodes are set at VDD18. Therefore the field across the sensor is zero and has no impact. The discharge time includes only the connection and pad capacitance as well as the internal capacitance. Now it is possible to correct mathematically for the parasitic capacitance. This correction is covered by the ams firmware.

Figure 81:

External Compensation

![bo_d3r3s93ef24c73d0qhr0_55_197_750_1297_554_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_55_197_750_1297_554_0.jpg)

Floating capacitors, external compensation measurements, the three measurements that are made for each floating capacitor.

## DC Balance

When driving floating sensors the sensors' supply is typically DC free.

With differential floating sensors symmetry would be broken. Therefore, PCap04 has the possibility to change the port controlling that the sensors are operated DC free (set by C_DC_ BALANCE).

In applications with grounded sensors the sensors cannot be DC fee by principle.

## Gain Correction

Comparable to classical A/D converters, the PCap04 shows a gain error. But in case of PCap04 the gain error is mainly given by internal parasitic capacitances and the propagation delay of the internal comparator. With internal compensation being active this delay is subtracted from the original measurement. The temperature drift can be approximated linearly and corrected mathematically just by a gain factor. In the standard firmware the gain correction factor could be set in register 35 with fpp 8 . The correction factor depends on the discharge time and therefore the RC combination. It has to be evaluated individually for every single application. E.g., with \( {22}\mathrm{{pF}} \) and 30kOhm the correction factor is 1.25 (0x40). CDC_GAIN_CORR = (gain_corr-1)*256 Empirical method to find the right gain correction factor:

Replace the sensor with a temperature stable capacitor of the same size (ceramic C0G) as your reference capacitor. (Therefore: quotient \( = 1 \) , gain \( = 0 \) ). Set the gain correction factor to 1.0. Put the system (PCap04 on PCB) into a temperature chamber and measure the offset drift over temperature. Add an additional temperature stable capacitor to simulate your gain. Measure the gain drift. Increase the gain correction factor and measure the gain drift again. With a gain correction factor >1.0 the gain drift will decrease. If the gain correction factor is set too big then you will see a negative gain drift due to over compensation. The right gain correction factor is found, if the drift is reduced to what you measured at the initial offset drift measurement. Write back the new CDC_GAIN_CORR value into register 35.

## CDC Important Parameters

## Cycle Clock

The basic period \( {\mathrm{t}}_{\text{cycle }} \) that defines the cycle time can be derived from the low frequency oscillator or the high frequency oscillator. Parameters CY_HFCLK_SEL selects in between the two, parameter CY_DIV4_DIS select between the original \( 2\mathrm{{MHz}} \) or a \( {0.5}\mathrm{{MHz}} \) generated by a divider by 4 .

Figure 82:

Configuration of Cycle Clock

<table><tr><td>CY_HFCLK_SEL</td><td>CY DIV4 DIS</td><td>Cycle Time Base</td></tr><tr><td>0</td><td>0</td><td>\( {\mathrm{t}}_{\text{cvcle }} = {\mathrm{t}}_{\mathrm{{OLF}}};{\mathrm{t}}_{\mathrm{{OLF}}} = \) period low-frequency oscillator</td></tr><tr><td>1</td><td>0</td><td>\( {\mathrm{t}}_{\text{cvcle }} = {4}^{ * }{\mathrm{t}}_{\mathrm{{OHF}}};{\mathrm{t}}_{\mathrm{{OHF}}} = \) period high-frequency oscillator.</td></tr><tr><td>1</td><td>1</td><td>\( {\mathrm{t}}_{\mathrm{{cvcle}}} = {\mathrm{t}}_{\mathrm{{OHF}}};{\mathrm{t}}_{\mathrm{{OHF}}} = \) period high-frequency oscillator.</td></tr></table>

Cycle Time

The pre-charge, full-charge and discharge times of a single cycle are defined in multiples of \( {t}_{\text{cycle }} \) . Those are selected by:

Figure 83:

Cycle Time Configuration

<table><tr><td>Reg.</td><td>Configuration Parameter</td><td>Description</td></tr><tr><td>14,15</td><td>PRECHARGE_TIME</td><td>Time to charge via resistor for current limitation. Depends on the cycle clock and, with OHF, on the FULLCHARGE_TIME. 1023 = No pre-charge phase OLF: 0 to 1022: \( {T}_{\text{precharge }} = \left( {\text{PRECHARGE_TIME} + 1}\right)  * {t}_{\text{cycle }} \) OHF & FULLCHARGE_TIME = 1023: 0 to 1022: \( {T}_{\text{precharae }} = \left( {\text{PRECHARGE_TIME} + 2}\right)  * {t}_{\text{cvcle }} \) OHF & FULLCHARGE_TIME != 1023: 0 to 1022: \( {T}_{\text{precharge }} = \left( {\text{PRECHARGE_TIME} + 1}\right)  * {t}_{\text{cycle }} \)</td></tr><tr><td>16,17</td><td>FULLCHARGE_TIME</td><td>Time for final charge without current limitation. Depends on the cycle clock. 1023 = No full-charge phase OLF: 0 to 1022: \( {T}_{\text{fullcharge }} = \left( {\mathbf{{FULLCHARGE}\_ {TIME}} + 1}\right)  * {t}_{\text{cvcle }} \) OHF: 0 to 1022: \( {T}_{\text{fullcharge }} = \left( \text{FULLCHARGE_TIME + 2}\right)  * {t}_{\text{cycle }} \)</td></tr><tr><td>12,13</td><td>DISCHARGE_TIME</td><td>Time to discharge the capacitor. Depends on the cycle clock. OLF: 0 to 1023: \( {T}_{\text{discharge }} = \left( {\mathbf{{DISCHARGE}\_ {TIME}} + 1}\right)  * {t}_{\text{cvcle }} \) OHF: 0 to 1023: \( {T}_{\text{discharge }} = \left( \text{DISCHARGE_TIME + 0}\right)  * {t}_{\text{cycle }} \)</td></tr></table>

Sequence

The length of a sequence depends on the kind and number of sensors, the selected compensation methods and the averaging sample size. The following parameters affect the sequence:

Figure 84:

Sequence Configuration

<table><tr><td>Reg.</td><td>Configuration Parameter</td><td>Description</td></tr><tr><td>6</td><td>C_PORT_EN</td><td>Bitwise enable of the capacitance ports PC0 to PC5 0 : Port disabled 1 : Port active</td></tr><tr><td>4</td><td>C_REF_INT</td><td>Switches between external and internal reference capacitors. Cannot be used with differential sensors. 0 : External, PC0 or PC0 & PC1 1 : Internal, PC6</td></tr><tr><td>4</td><td>C_DIFFERENTIAL</td><td>Switches between single and differential sensors 0 : Single 1 : Differential</td></tr><tr><td>4</td><td>C_FLOATING</td><td>Switches between grounded and floating sensors 0 : Grounded 1 : Floating</td></tr><tr><td>4</td><td>C_COMP_INT</td><td>Turns on compensation of internal capacitances/delays 0 : Off 1: On, recommended</td></tr><tr><td>4</td><td>C_COMP_EXT</td><td>Turns on compensation of external parasitic capacitances. Available only with floating sensors. 0 : Off 1: On, recommended</td></tr><tr><td>5</td><td>C DC BALANCE</td><td>Changes Port Control for Differential Floating Mode 0 : Off (single HighZ) 1 : DC-Free (both HighZ)</td></tr></table>

Conversion

The duration of a full conversion has a lower limit given by the number of fake measurements, the averaging and eventually an inter-sequence delay:

Figure 85:

Conversion Configuration

<table><tr><td>Reg.</td><td>Configuration Parameter</td><td>Description</td></tr><tr><td>15</td><td>C_FAKE</td><td>Number of fake measurements (cycles with results being ignored) 0 : No dummy cycles 1 : 1 dummy cycle ... 15 : 15 dummy cycles</td></tr><tr><td>7, 8</td><td>C_AVRG</td><td>Sample size for averaging within one conversion. \( 0 \mathrel{\text{:=}} \) No averaging ... 8191 : Maximum sample size</td></tr></table>

The Start of the next conversion depends on the selection of the measurement trigger:

Figure 86:

Conversion Configuration

<table><tr><td>Reg.</td><td>Configuration Parameter</td><td>Description</td></tr><tr><td>13</td><td>C_TRIG_SEL</td><td>First trigger selection for CDC trigger 0 : Continuous 1 : Read triggered 2 : Timer triggered 3: Timer triggered (stretched) 4 : n.d. 5 : Pin triggered 6 : Opcode triggered (7 : continuous_exp, not recommended)</td></tr><tr><td>13</td><td>C_STARTONPIN</td><td>Selects the GPIO that triggers the CDC measurement</td></tr><tr><td>9, 10, 11</td><td>CONV_TIME</td><td>Sets the conversion time in multiples of twice the period of the low-frequency clock. \( {\mathrm{t}}_{\mathrm{{conv}}} = 2 * \mathbf{{CONV}\_ {TIME}} * {\mathrm{t}}_{\mathrm{{ofl}}} \)</td></tr></table>

## Guarding

Depending on the sensor topology it may be necessary to add an active shield to suppress disturbing capacitances. The guard electrode is an additional metal area behind the sensing electrode, which is kept at the same potential as the sensing electrode. So all material in between the sensing electrode and the guard electrode are potential-free and therefore have no capacitive effect. It eliminates material-depending temperature drifts of the sensor PCB. Further, things behind the shield are separated from the senor by the potential-free zone.

In PCap04 the driver for the guard is integrated. This amplifier needs to have a low-capacitive input to not disturb the measurement path. Gain is ideally one. The gain can be set \( > 1 \) (overcompensation) by means of C_G_OP_VU so that in combination with an external voltage divider it is possible to match the port and wire resistance. The guard is connected to pin PCAUX (other functions of this pin are then not available). In-active ports are also switched to guard so that there is no additional capacitance seen between guard and inactive ports.

Figure 87:

Guarding with Floating Capacitors

![bo_d3r3s93ef24c73d0qhr0_60_644_1082_417_435_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_60_644_1082_417_435_0.jpg)

Figure 88:

Guarding with Grounded Capacitors

![bo_d3r3s93ef24c73d0qhr0_61_633_330_421_448_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_61_633_330_421_448_0.jpg)

Figure 89:

Port Voltages with Guarding

![bo_d3r3s93ef24c73d0qhr0_61_480_1086_734_335_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_61_480_1086_734_335_0.jpg)

With guarding, also ports are set to VDD18, even the ones that are not measured. This ensures that electric fields between those ports and the active port are zero. Internally, those ports are not connected to the time measuring path but to the guard driver.If the guard electrode is so big that it cannot be driven by the internal amplifier it is possible to add an external one. An external analog multiplexer will be needed, too. The external amplifier is connected to PCAUX. The SEL port of the multiplexer is connected to PG3.

Figure 90:

Guarding with External Amplifier

![bo_d3r3s93ef24c73d0qhr0_62_529_365_644_384_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_62_529_365_644_384_0.jpg)

Figure 91:

Important Parameters are Set in Register 18:

<table><tr><td>Reg.</td><td>Configuration Parameter</td><td>Description</td></tr><tr><td>18</td><td>C_G_EN[5:0]</td><td>Individual guard enable for each port PC0 to PC5</td></tr><tr><td>18</td><td>C_G_OP_RUN</td><td>0 : Permanent: Guarding OP is permanent activated (additional power consumption) 1 : Pulsed: Guarding OP set to sleep mode between CDC conversions</td></tr><tr><td>19</td><td>C_G_OP_ATTN</td><td>Capacitive attenuation of guarding OP: 0 : 0.5pF 1 : 1.0pF 2 : 1.5pF 3 : 2.0pF</td></tr><tr><td>19</td><td>C_G_OP_VU</td><td>OP Gain (from sense port to guard) 0 : 1.00 1 : 1.01 2 : 1.02 3 : 1.03</td></tr><tr><td>20</td><td>C_G_OP_TR</td><td>Trim power consumption and driving strength of guarding OP 0 : Min. ... 7 : Max.</td></tr><tr><td>18</td><td>C_G_OP_EXT</td><td>Switch between internal guarding OP and an optional external OP 0 : Internal OP 1: External OP, PG3 as C_G_MUX_SEL</td></tr><tr><td>19</td><td>C_G_TIME</td><td>\( {t}_{pp1} = {t}_{OHF} \cdot  C\_ G\_ {TIME} \)</td></tr></table>

## amm

- C_G_EN[5:0] guarding is activated individually for each port PC0 to PC5. One or more ports can be enabled. The guard output (PCAUX) drives voltage the enabled ports are enabled.

- C_G_TIME controls the pre-charge phase. Because internal circuits the pre-charge phase is divided into two phases:

- Pre-charge phase 1: PCAUX is directly connected with active PC.

- Pre-charge phase 2: PCAUX is driven by OP, V_ PCAUX=gain_guardOP-V_PCactive.PCAUX is driven by OP until finishing current port cycle.

Attention: For guarding, the internal OX/OHF is mandatory:

- OX_RUN > 0, OX_DIS = 0; OX_STOP = 0; OX_DIV4 = 0;

- CY_HFCLK_SEL = 1;

## RDC Resistance-to-Digital Converter

Measuring Principle

In PCap04 resistance measurement is also done by measuring discharge times. The measurements are ratiometric. This means, the temperature-sensitive resistances are compared with a fixed reference. The ratio of discharge times is directly proportional to the ratio of resistors. The discharge time is defined by the resistors and the load capacitance.

\[
\text{(EQ2)}\frac{{\tau }_{N}}{{\tau }_{\text{ref }}} = \frac{{R}_{\theta }}{{R}_{\text{ref }}}\;\tau  = k \times  R \times  C
\]

Connecting Sensors

The chip device has two on-chip resistor elements for the measurement of temperature, an aluminum strip with \( \mathrm{{TK}} \approx  {2800}\mathrm{{ppm}}/\mathrm{K} \) as a sensor and a poly-silicon resistor with TK "close to zero" as a reference. In the range \( {0}^{ \circ  }\mathrm{C} \) to \( {100}^{ \circ  }\mathrm{C} \) the aluminum sensor can be well approximated by a linear function of temperature.

As an alternative, it is possible to connect up to two external sensors. One of those can be used as external reference alternately. External and internal thermometers/reference may be mixed, e.g. an external PT1000 may be compared to the internal Poly-Si resistor.

The chip has an internal capacitor of about \( {94}\mathrm{{pF}} \) . In combination with the internal resistors the discharge time is about \( {500}\mathrm{\;{ns}} \) and the typical resolution of the resistance ratio is better than 13 bits. For precision measurements we recommend to connect an external capacitor of about \( {10}\mathrm{{nF}} \) . With \( {10}\mathrm{{nF}} \) the discharge time is in the order of \( {20\mu }\mathrm{s} \) and the resolution in the order of 15 bits.

Discharge time must not exceed \( {20\mu }\mathrm{s} \) . For the capacitor, \( \mathrm{{COG}} \) ceramics yields best performance, while X7R material yields fair results. recommended to have short cables ( \( \leq  {0.5}\mathrm{\;m} \) ), ideally twisted and shielded.

Figure 92:

Connecting Temperature Sensors

![bo_d3r3s93ef24c73d0qhr0_64_458_380_770_404_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_64_458_380_770_404_0.jpg)

Note(s):

1. The RDC measurement is based on an AC principle. Long cables with their parasitic capacitance and resistance will disturb and it is

## Cycle & Conversion

In PCap04 the resistance measurement is running in three phases, like in capacitance measurement:

Pre-charge - Full-charge - Discharge. The timing is based on the internal low-frequency oscillator (OLF). The duration of full and discharge phases can be 1 or 2 periods of this reference. The conversion starts with 2 or 8 fake measurements to improve the stability of data. For each single conversion the averaging can be selected with sample size1,4,8or 16 .

Figure 93:

RDC Conversion

![bo_d3r3s93ef24c73d0qhr0_64_267_1571_1166_444_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_64_267_1571_1166_444_0.jpg)

RDC Conversion: R_AVRG = 1, Reference and sensor, 2 fake measurements

## amm

## Trigger

Various sources can trigger the RDC. The trigger rate can be set to a divider of the CDC trigger rate by means of parameter \( {R}_{ - } \) TRIG_PREDIV (1 to 1023).

Parameter R_TRIG_SEL defines the various possibilities to trigger a resistance measurement:

- Serial Interface command, PIN or DSP (Figure 64)

- Timer triggered, based on the OLF (Figure 64)

- CDC end of conversion

- Asynchronous: The DSP is triggered by the RDC end of conversion. If RDC rate is less than CDC rate the DSP is triggered directly from the CDC for inactive RDC conversions (Figure 95).

- Synchronous: The DSP is triggered by the RDC end of conversion. Assuming that RDC rate is less than the CDC rate, the inactive RDC conversions are replaced by a delay (Figure 96).

Figure 94:

RDC Timing, Triggered by Timer, SIF or Pin

![bo_d3r3s93ef24c73d0qhr0_65_195_974_1292_428_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_65_195_974_1292_428_0.jpg)

Figure 95:

RDC Timing, Triggered by DSP in Asynchronous Mode

![bo_d3r3s93ef24c73d0qhr0_65_193_1539_1305_423_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_65_193_1539_1305_423_0.jpg)

R_TRIG_PREDIV = 3, R_TRIG_SEL = 3'b101, DSP_START_EN: CDC_TRIG_EN = 0, RDC_TRIG_EN = 1

Figure 96:

RDC Timing, Triggered by DSP in Synchronous Mode

![bo_d3r3s93ef24c73d0qhr0_66_193_276_1308_427_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_66_193_276_1308_427_0.jpg)

R_TRIG_PREDIV = 3, R_TRIG_SEL = 3'b110, DSP_START_EN: CDC_TRIG_EN = 1, RDC_TRIG_EN = 0

## RDC Important Parameters

Cycle Clock

The base frequency for the temperature measurement is the low frequency oscillator (OLF). A further bit, R_CY, specifies whether 1 or 2 periods define the length of the three phases.

Figure 97:

Cycle Clock Configuration

<table><tr><td rowspan="2">OLF Frequency</td><td colspan="2">\( {t}_{\text{precharge }} = {t}_{\text{fullcharge }} = {t}_{\text{discharge }} \)</td></tr><tr><td>R_CY = 0</td><td>R_CY = 1</td></tr><tr><td>10 kHz</td><td>100μs</td><td>200μs</td></tr><tr><td>50 kHz</td><td>20μs</td><td>40μs</td></tr><tr><td>100 kHz</td><td>10μs</td><td>20μs</td></tr><tr><td>200 kHz</td><td>20μs</td><td>40μs</td></tr></table>

Sequence

The major settings for the sequence are the number of ports, the fakes, the reference and averaging.

Figure 98:

Sequence Configuration

<table><tr><td>Reg.</td><td>Configuration Parameter</td><td>Description</td></tr><tr><td>23</td><td>R_PORT_EN</td><td>Enable ports PTOREF, PT1</td></tr><tr><td>23</td><td>R_PORT_EN_IREF</td><td>Enable the internal reference resistor</td></tr><tr><td>23</td><td>R_PORT_EN_IMES</td><td>Enable the internal temperature sensor</td></tr><tr><td>22</td><td>R_AVRG</td><td>Set averaging for T measurement</td></tr><tr><td>23</td><td>R_FAKE</td><td>Set number of fake measurements</td></tr></table>

## Conversion

Figure 99:

RDC Trigger Configuration

<table><tr><td>Reg.</td><td>Configuration Parameter</td><td>Description</td></tr><tr><td>22</td><td>R_TRIG_SEL</td><td>Selection of trigger source for RDC unit</td></tr><tr><td>21, 22</td><td>R_TRIG_PREDIV</td><td>Pre-divider to set the RDC rate as fraction of the CDC rate but also to the OLF_CLK when OLF_CLK is selected as RDC Trigger \( 0 = 1 : \) RDC conversion with each CDC conversion 2 : RDC conversion every second CDC conversion ... 1023 : Maximum setting</td></tr><tr><td>23</td><td>R_STARTONPIN</td><td>Select Pin for pin triggered</td></tr></table>

RDC Results, Ratios

PCap04_standard and PCap04_linearize firmware are determining ratios between sense ports and reference ports.

If the internal reference port is activated (R_PROT_EN_IREF: 1) for all other ports (internal sense, PT0 and PT1) the internal reference is automatically selected for ratios.

If R_PORT_EN_IREF: 0, external port PT0/Ref is selected as reference value for all other ports (internal sense, PT1)

## Interfaces (Serial & PDM/PWM)

## Serial Interfaces (SIF)

Two types of serial interfaces are available for communication with a microcontroller and for programming the device: SPI and IIC. Only one interface is available at a time, selected by pin IIC_ EN. On both interfaces, the PCap04 can operate as slave only.

Figure 100:

Serial Interface Selection

<table><tr><td>Pin</td><td>Description</td></tr><tr><td>IIC_EN = GROUND</td><td>4-wire SPI interface General-purpose I/O pins PG0 and PG1 are not available</td></tr><tr><td>IIC_EN = VDD</td><td>2-wire \( {\mathrm{I}}^{2}\mathrm{C} \) interface All general-purpose I/O pins are available</td></tr></table>

IIC_EN may not be floating. Connect IIC_EN to VDD if there is no need for a controller interface.

The serial interfaces allow read access to the read registers (results and status), read/write access to the configuration registers and read/write access to the NVRAM (explicitly the SRAM part of the NVRAM).

All commands for write or read to memory or configuration / read registers may use explicit addressing or address auto-increment.

## amm

Opcodes Figure 101: Opcodes

<table><tr><td>Description</td><td colspan="8">Byte 2</td><td colspan="3">Byte 1</td><td>Byte 0</td></tr><tr><td>wr_mem (NVRAM)</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td colspan="5">add<9...0>(2)</td><td>data<7...0></td></tr><tr><td>rd_mem (NVRAM)</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td colspan="5">add<9...0>(2)</td><td>data<7...0></td></tr><tr><td>Write configuration</td><td>1</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>add<5...0> (2)</td><td>data<7...0></td></tr><tr><td>Read configuration</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>add<5...0>(2)</td><td>data<7...0></td></tr><tr><td>Read result (RAM)</td><td>0</td><td>1</td><td colspan="6">add<5...0>(2) (3)</td><td colspan="3">data<7...0></td><td rowspan="9"/></tr><tr><td>POR (Power-on Reset)</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>0</td><td>0</td><td/><td/><td/></tr><tr><td>Initialize</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td/><td/><td/></tr><tr><td>CDC Start conversion</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td/><td/><td/></tr><tr><td>RDC Start conversion</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td/><td/><td/></tr><tr><td>dsp_trig</td><td>1</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>1</td><td/><td/><td/></tr><tr><td>nv_store(1)</td><td>1</td><td>0</td><td>0</td><td>1</td><td>0</td><td>1</td><td>1</td><td>0</td><td/><td/><td/></tr><tr><td>nv_recall (1)</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>0</td><td>0</td><td>1</td><td/><td/><td/></tr><tr><td>nv_erase(1)</td><td>1</td><td>0</td><td>0</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td/><td/><td/></tr><tr><td>Test read</td><td>0</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>1</td><td>0</td><td>0</td><td>0</td><td>010001</td><td/></tr></table>

Note(s):

1. Set MEM_CTRL before using nv_store, nv_recall or nv_erase

2. Auto-incremental write/read is supported by both, SPI and \( {\mathrm{I}}^{2}\mathrm{C} \)

3. Address range for Read result is 0 to \( {24}\left( {8 \times  {32}\text{bit result registers and}3 \times  8\text{bit status registers}}\right) \)

The serial interface is tested most easily by performing a test read:

Write opcode 0x7e to SIF and read 1 byte. Compare this byte to following patterns:

- 0x11 : Expected value, read cycle performed correctly

- 0x88 : Failure: there is a big/little-endian swap

- 0xEE : Failure: during read cycle all bits are inverted

- 0x77 : Failure: inverted bits and bit/little-endian swap

## Synchronous Read

For best results it is recommended to read all values from the result registers synchronized by the INTN signal. The INTN signal can be routed to PG4 or PG5 by PG4_INTN_EN and PG5_INTN_ EN at Register 30. The INTN signal is low active, which means the negative edge of INTN signals new values are available at Res0 to Res7. The INTN is set back to High by a positive edge at SSN (SPI) or a stop condition \( \left( {{\mathrm{I}}^{2}\mathrm{C}}\right) \) .

## Asynchronous Read

If it is not possible to read synchronously as described above for any reason, asynchronous read (EN_ASYNC_RD) has to be enabled in register 42. In this mode values in result registers Res0 to Res7 are only updated if the previous value has been read (INTN is reset to High by a positive edge of SSN or a stop condition).

## I \( {}^{2} \) C Compatible Interface

The present paragraph outlines the PCap04 device specific use of the \( {\mathrm{I}}^{2}\mathrm{C} \) interface. The external \( {\mathrm{I}}^{2}\mathrm{C} \) master begins the communication by creating a start condition, a falling edge on the SDA line while SCL is HIGH. It stops the communication by a stop condition, a rising edge on the SDA line while SCK is high. Data bits are transferred with the rising edge of SCK.

On \( {\mathrm{I}}^{2}\mathrm{C} \) buses, every slave holds an individual 7-bit device address with 5 fixed and 2 configurable bits. This address has always to be sent as the first byte after the start condition, the eighth bit indicating the direction of the following data transfer (R=read=1 and W=write=0).

Figure 102:

Address Byte

<table><tr><td>MSB</td><td/><td/><td/><td/><td/><td/><td>LSB</td></tr><tr><td>0</td><td>1</td><td>0</td><td>1</td><td>0</td><td>A1</td><td>A0</td><td>R/W</td></tr><tr><td colspan="5">Fixed</td><td colspan="2">Variable</td><td>key</td></tr></table>

\( {I}^{2}C \) Timing

The address byte is followed by the opcode and eventually the payload. Each byte is followed by an acknowledge bit \( ( = 0 \) , when a slave acknowledges).

Figure 103:

l2C Typical Sequence

![bo_d3r3s93ef24c73d0qhr0_71_192_463_1303_294_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_71_192_463_1303_294_0.jpg)

l’C Write

During write transactions, the master alone sends data, the addressed slave just sends the acknowledge bits. The master first sends the slave address plus the write bit. Then it sends the PCap04 specific opcode including the register address in the slave. Finally it sends the payload ("Data").

Incremental writing is possible, means, for a consecutive set of data only the start address has to be sent and a various number of data could be sent in one row.

Figure 104:

l2C Write Procedure \( {I}^{2}C \) Read

![bo_d3r3s93ef24c73d0qhr0_71_293_1355_1090_279_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_71_293_1355_1090_279_0.jpg)

Example: Write 0xFF as a datum to the SRAM at address 0x147.

During read transactions, the direction of communication has to be commuted. Therefore, the master creates again a start condition (resp. restart: start without stop condition in between) and sends the slave address plus the read bit to switch into read mode. Figure 105 shows an example with op code "read from SRAM".

Figure 105:

\( {\mathrm{I}}^{2}\mathrm{C} \) Read Procedure

![bo_d3r3s93ef24c73d0qhr0_72_194_569_1290_355_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_72_194_569_1290_355_0.jpg)

Example: Read from SRAM address 0x147, we find 0xFF having been programmed before.

After arrival of the first (or any) data byte, the master may either signal

- Not-Acknowledge \( = \mathrm{N} = 1 \) to indicate "end read","stop sending" to the slave, or

- Acknowledge \( = A = 0 \) to indicate "continue in automatic address-increment mode" and thus receive many bytes in a row. As one can see, automatic address increment is particularly useful and efficient with the \( {\mathrm{I}}^{2}\mathrm{C} \) interface.

## SPI Interface

Clock Polarity, Clock Phase and Bit Order: The following choices are necessary for successful operation.

Figure 106:

SPI Settings

<table><tr><td>SPI - Parameter</td><td>Description</td><td>Setting</td></tr><tr><td>CPOL</td><td>Clock polarity</td><td>0</td></tr><tr><td>CPHA</td><td>Clock phase</td><td>1</td></tr><tr><td>Mode</td><td>SPI Mode</td><td>1</td></tr><tr><td>DORD</td><td>Bit sequence order</td><td>0, MSB first</td></tr></table>

## amm

![bo_d3r3s93ef24c73d0qhr0_73_183_176_1329_694_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_73_183_176_1329_694_0.jpg)

Figure 108: SPI Read

![bo_d3r3s93ef24c73d0qhr0_73_209_998_1283_494_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_73_209_998_1283_494_0.jpg)

Figure 109:

SPI Timing

<table><tr><td>Name</td><td>Symbol</td><td>\( {VDD} = {2.2V} \)</td><td>VDD=3.0V</td><td>VDD=3.6V</td><td>Units</td></tr><tr><td>Serial clock frequency</td><td>fSPI-bus</td><td>10</td><td>17</td><td>20</td><td>MHz</td></tr><tr><td>Serial clock pulse width HI state</td><td>\( {t}_{pwh} \)</td><td>50</td><td>30</td><td>25</td><td>ns</td></tr><tr><td>Serial clock pulse width LO state</td><td>\( {t}_{\text{pwl }} \)</td><td>50</td><td>30</td><td>25</td><td>ns</td></tr><tr><td>SSN enable-to-valid latch</td><td>\( {\mathrm{t}}_{\text{sussn }} \)</td><td>10</td><td>8</td><td>7</td><td>ns</td></tr><tr><td>SSN pulse width between write cycles</td><td>\( {t}_{\text{pwssn }} \)</td><td>50</td><td>30</td><td>25</td><td>ns</td></tr><tr><td>Data setup time prior to clock edge</td><td>\( {t}_{\text{sud }} \)</td><td>7</td><td>6</td><td>5</td><td>ns</td></tr><tr><td>Data hold time after clock edge</td><td>\( {t}_{hd} \)</td><td>5</td><td>4</td><td>3</td><td>ns</td></tr><tr><td>Data valid after clock edge</td><td>\( {t}_{vd} \)</td><td>40</td><td>26</td><td>16</td><td>ns</td></tr></table>

## GPIO and PDM/PWM

This section is about the general purpose ports and their use as Pulse-Density / Pulse Width Modulated outputs (PDM/PWM). PCap04 is very flexible with assignment of the various GPIO pins to the DSP inputs/outputs. The following table shows the 6 general purpose ports and their possible assignment.

Figure 110:

General Purpose Port Assignment

<table><tr><td>External Port Name</td><td>Description</td><td>Direction In or Out</td></tr><tr><td rowspan="4">PG0</td><td>SSN (in SPI-Mode), serial select</td><td>In</td></tr><tr><td>DSPØ or DSP2, I/O for the DSP</td><td>In (1) / Out</td></tr><tr><td>FF0 or FF2, I/O for the DSP with Flip-Flop</td><td>\( {\ln }^{\left( 1\right) } \)</td></tr><tr><td>Pulse0, PDM or PWM output</td><td>Out</td></tr><tr><td rowspan="4">PG1</td><td>MISO (in SPI-Mode)</td><td>Out</td></tr><tr><td>DSP1 or DSP3, I/O for the DSP</td><td>In(1) / Out</td></tr><tr><td>FF1 or FF3, I/O for the DSP with Flip-Flop</td><td>In (1)</td></tr><tr><td>Pulse1, PDM or PWM output</td><td>Out</td></tr><tr><td rowspan="3">PG2</td><td>DSPØ or DSP2, I/O for the DSP</td><td>In \( {}^{\left( 1\right) } \) /Out</td></tr><tr><td>FF0 or FF2, I/O for the DSP with Flip-Flop</td><td>\( \ln \left( 1\right) \)</td></tr><tr><td>Pulse0, PDM or PWM output</td><td>Out</td></tr><tr><td rowspan="4">PG3</td><td>DSP1 or DSP3, I/O for the DSP</td><td>\( {\ln }^{\left( 1\right) }/ \) Out</td></tr><tr><td>FF1 or FF3, I/O for the DSP with Flip-Flop</td><td>\( \ln \left( 1\right) \)</td></tr><tr><td>Pulse1, PDM or PWM output</td><td>Out</td></tr><tr><td>C_G_MUX_SEL output</td><td>Out</td></tr><tr><td rowspan="2">PG4</td><td>DSP4 (output only)</td><td>Out</td></tr><tr><td>INTN</td><td>Out</td></tr><tr><td rowspan="2">PG5</td><td>DSP5 (output only)</td><td>Out</td></tr><tr><td>INTN</td><td>Out</td></tr></table>

Note(s):

1. These ports provide an optional debouncing filter and an optional pull-up resistor.

Figure 111:

GPIO Assignment

![bo_d3r3s93ef24c73d0qhr0_76_227_272_1243_1664_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_76_227_272_1243_1664_0.jpg)

## Debouncing Filter

There is a possibility to activate a \( {40}\mathrm{\;{ms}} \) debounce filter ("monoflop") for the ports in case these are used as push button inputs. This might be useful especially in case the DSP is started by the pins (signals FF0, FF2). Figure 112 shows the effect of the monoflop filter.

Figure 112:

Port Trigger Timing

![bo_d3r3s93ef24c73d0qhr0_77_202_567_1293_591_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_77_202_567_1293_591_0.jpg)

## PDM and PWM

There is a possibility to generate two pulse density modulated output signals. In general, PDM is preferred because of better noise behavior. The output is based on the content of RAM registers PIO_REF, PI1_REF (DSP write addresses 109, 110. Width 16 bit each). The content of those RAM cells depends on the firmware. The description in this datasheet is based on the standard firmware, which writes the capacitance ration to PIO_ REF, the Resistance ratio to PI1_REF.

The pulse interfaces can be switched on individually. The resolution can be programmed from 10 to 16 bit. There is a broad range of clock signals that can be selected as base for the pulse interfaces, derived from the \( {50}\mathrm{{kHz}} \) low-frequency oscillator or the \( 2\mathrm{{MHz}} \) internal oscillator. The output pins may be PG0 or PG2 and PG1 or PG3.

The PDM signal can be converted into an analog voltage by means of a simple RC-filter. A first-order filter made of \( {220}\mathrm{k}\Omega / \) 100nF is sufficient. By the choice or the resistor and capacitor values the user can optimize for reaction time vs. ripple.

Filter configuration instructions:

The resistor should be \( \geq  {50}\mathrm{{kOhm}} \) . The internal DC resistance of the output buffer is typ. \( {100\Omega } \) 1. Settling time (for PDM and PWM) If the output value changes, the settling time to reach 90% is 2.3 x Tau, Tau \( = \mathrm{R} \times  \mathrm{C} \) Example: \( {200}\mathrm{k}\Omega  \times  {100}\mathrm{{nF}} \times  {2.3} = {50}\mathrm{\;{ms}} \)

The smaller is Tau the faster is the settling but the higher

is the ripple.

2. Voltage Ripple

Calculation Method:

\[
{V}_{DD} \cdot  \left( {1 - {e}^{\frac{1}{{f}_{0} \cdot  R \cdot  C}}}\right) \text{with}\left( {{f}_{0} « \frac{1}{R \cdot  C}}\right)
\]

\[
{v}_{pp} = \frac{{V}_{DD}}{{f}_{0} \cdot  R \cdot  C}
\]

\( {v}_{pp} = \) ripple voltage (peak to peak)

\[
{f}_{0} = \text{for PWM :}\frac{1}{\text{ period }} = {f}_{\text{clk }}/{2}^{{PWM}\text{ resolution } \mid  \text{ bit }}
\]

\[
\text{for}\mathrm{{PDM}} : \frac{1}{{t}_{\text{pulsewidth }}}
\]

In the standard firmware, the result of measurement from capacitance or temperature is a 32-bit value. The DSP linearizes this 32-bit result to a value according to the resolution settings of the pulse interface. The parameters pi<n>_result0, pi<n>_ result1, pi<n>_pulse0 and pi<n>_pulse1 of the linear function are configurable in NVRAM, calibration space 800 to 822. The parameters are describing the edges for a simple scaling (1 \( {}^{st} \) order linearization), whereby pi<n>_pulse0 is also the minimum clipping values and pi<n>_pulse1 the maximum clipping value for the pulse output. Pi<n>_pulse0 must be always smaller than pi<n>_pulse1. For negative slopes just pi<n>_result0 has to be larger than pi<n>_result1. A 12-bit resolution thus limits the result value between 0 and 4096 . For lower-bit resolutions, the range reduces accordingly.

The pulse_out is determined like this:

\[
p{i}_{n}\text{out} = \frac{p{i}_{n}\text{pulse}1 - p{i}_{n}\text{pulse}0}{p{i}_{n}\text{result}1 - p{i}_{n}\text{result}0} \cdot  \left( {\text{result} - p{i}_{n}\text{result}0}\right)  + p{i}_{n}\text{pulse}0
\]

\[
p{i}_{n}\text{result}1 > p{i}_{n}\text{result}0
\]

\[
0 \leq  p{i}_{n}\text{pulse}1 \leq  {2}^{\text{pulse resolution }}
\]

\[
0 \leq  p{i}_{n}\text{pulse}0 \leq  {2}^{\text{pulse resolution }}
\]

The following figure depicts how the result is processed to generate the pulsed output.

Figure 113:

PDM and PWM Pulse Generation

![bo_d3r3s93ef24c73d0qhr0_79_209_279_1278_633_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_79_209_279_1278_633_0.jpg)

The following figure shows a sample linear function and its parameters graphically. In this graph, the result C1/C0 has been taken on the x-axis, assuming that this result is to be pulse modulated. A 12 bit resolution has been configured.

The settings for the PDM and PWM interface are made in configuration registers 27 and 29 to 33 .

The lower limit (pi<n>_pulse0) of the valid range corresponds to 0% modulation (all bits are 0), The upper limit (pi<n>_pulse1) of the valid range corresponds to 100% modulation (all bits are 1), and this is the maximum possible value of output. 12 bit resolution implies that this maximum value is 4095 . For lower-bit resolutions, this maximum value will come down accordingly. In terms of voltage, the two limits correspond to 0V and VDD.

Figure 114:

PDM and PWM Linearization

![bo_d3r3s93ef24c73d0qhr0_80_473_333_761_528_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_80_473_333_761_528_0.jpg)

## Applications:

- A typical case would be outputting capacitance results through PG0 and temperature results through PG1. Calculation and transfer to the output registers will be performed by firmware.

- Main applications will be that an analog interface is demanded by the final customer.

- Applications where the serial interface cannot be used due to speed limitations or other reasons.

- Finally, a temperature-coded pulse stream could be low-pass filtered and then directly used for temperature control.

Please note that the entire linearization task as described here is performed by firmware, especially the PCap04_standard and PCap04_linearization firmware.

## amm

## Oscillators

PCap04 offers a low frequency oscillator (OLF_CLK) and an integrated \( 2\mathrm{{MHz}} \) high frequency oscillator (OHF_CLK). OLF_ CLK is running all the time and cannot be turned off.

OLF_CLK is used for:

- CDC cycle time

- RDC cycle time

- PDM/PWM time base

- Watchdog for Standalone Applications

The OHF_CLK can be used alternatively for

- CDC cycle time

- PDM/PWM time base

The OLF_CLK can be trimmed for various typical frequencies :

Figure 115:

OLF Trimming

<table><tr><td>OLF CTUNE</td><td>OLF FTUNE</td><td>OLF Frequency</td></tr><tr><td>3 :(10kHz)</td><td>1</td><td>5kHz</td></tr><tr><td>3 :(10kHz)</td><td>7</td><td>10kHz</td></tr><tr><td>2 :(50kHz)</td><td>0</td><td>28kHz</td></tr><tr><td>2 :(50kHz)</td><td>3</td><td>48kHz</td></tr><tr><td>1 : (100kHz)</td><td>4</td><td>100kHz</td></tr><tr><td>0 : (200kHz)</td><td>5</td><td>200kHz</td></tr></table>

Note(s): The internal oscillators are not very precise and stable. The frequency varies from chip to chip, with temperature and voltage.

- Variation over batch \( \pm  {20}\% \)

- Variation with temperature \( \pm  5\% \) ,

- Variation with voltage. VDD \( \pm  2\% \)

The OHF_CLK can be switched off, turned on with delay before further tasks like measurement follow, or turned on continuously:

OX_RUN[2:0]0 : Generator off

\( 6 : \) OX latency \( = 1/{\mathrm{f}}_{\mathrm{{OLF}}} \)

\( 3 : \) OX latency \( = 2/{\mathrm{f}}_{\text{OLF }} \)

\( 2 : \) OX latency \( = {31}/{\mathrm{f}}_{\mathrm{{OLF}}} \)

1 : OX runs in permanence

By means of OX_DIV4 it can be divided by 4 to generate 500 kHz,

## DSP & Memory

This section describes the 32bit-DSP of the PCap04.

A 32-bit digital signal processor (DSP) in Harvard architecture was integrated to the PCap04. It is responsible for taking the information from the CDC and RDC measuring units, for processing the data and making them available to the user interface. Both, the CDC/RDC raw data as well as the data processed by the DSP are stored in the RAM. The program for the DSP is stored either in the NVRAM. The DSP can collect various status information from a set of \( {64}\mathrm{l}/\mathrm{O} \) Bits and write back 16 of those. This way the DSP can react on and also control the GPIO pins of PCap04. The DSP is internally clocked at approximately \( {60}\mathrm{{MHz}} \) . The internal clock is stopped through a firmware command, to save power. The DSP starts again upon a GPIO signal or an "end of measurement" condition.

In its simplest form, the DSP transfers the pure time measurement information from the CDC/RDC to the read registers without any further processing. The next higher step is to calculate the capacitance ratios including the information from the compensation measurements, as it is provided in ams' standard firmware version PCap04_standard_v01.hex. Finally, ams provides a ready-made linearize firmware that performs a linearization via polynomial of third degree and temperature compensation via polynomial of second degree. Many functional blocks for the linearization firmware are implemented as ROM code. This way, the main firmware can be very compact and can fit into the \( 1\mathrm{\;k} \) NVRAM.

Figure 116:

DSP Embedding

![bo_d3r3s93ef24c73d0qhr0_82_399_1419_899_467_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_82_399_1419_899_467_0.jpg)

## amm

The content of the read registers will always depend on the firmware in use. With the standard firmware it will be the pure capacitance and resistance ratios. With the linearization firmware it might the linearized and calibrated result, e.g. a pressure given in Pascal or humidity given in percent.

The DSP is ams proprietary to cover low-power tasks as well as very high data rates. It is programmed in Assembler. A user-friendly assembler software with a graphical interface, help text pop-ups as well as sample code sustain programming efforts.

## DSP & Environment

The DSP reads the RDC and CDC raw data from the RAM, processes then and writes the results back to the RAM. The program is stored in the NVRAM. It may use subroutines that are available from the ROM. The DSP reacts on flags and controls flags. It controls the GPIO and accordingly the PDM/PWM interface.

Figure 117:

DSP Environment

![bo_d3r3s93ef24c73d0qhr0_83_202_981_1290_888_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_83_202_981_1290_888_0.jpg)

The DSP is designed in Harvard architecture for 32 bit wide parallel data processing. It is coupled to a \( {128} \times  {32} \) bit RAM,96 x 32 bit thereof freely accessible. In read access, the DSP can get the MEM_DATA from address space 112 to 120 , the CDC- and RDC-frontend control from address space 121 to 124 . By write access the DSP provides the output data to the PDM/PWM interfaces (addresses 109, 110).

A detailed description of the RAM is given is section 2.1. The DSP operates with two accumulators A and B and has direct access to the RAM, which can be seen as a third accumulator. The RAM address pointer is of 7 bit size, and there is a 6-fold stack for RAM addresses.

The program counter has 12 bit and there is an 8-fold stack for the program counter.

Finally, the DSP can get a lot of information from the 64 I/O bits. The read information covers the ALU status, trigger information, some of the configuration bits and the information about the status of the GPIOs. 16 of those bits can be used as outputs, setting the GPIOs and also some internal information. The DSP can read these bits by means of instruction jcd (conditional jump) and set those bits by means of instructions bitS/bitC (bit Set/Clear).

The ALU flags overflow, carry, equal/not equal and pos./neg. are used directly as condition for the jcd instructions and are also mirrored in the I/O bits.

## RAM Structure

The RAM plays a key role. It is made of 128 words with size of maximum 32 bit. The DSP has free write and read access to registers address 0 to 96 of those words, all 32 bits wide. The RAM space addresses 97 to 104,109 to 111 and 115 and higher has different meaning for read and write operations.

The main data in the read section are the raw data as they come from the CDC and the RDC. Also the parameters are in the RAM as part of the configuration registers and they are set via the serial interface or copied from the NVRAM.

The DSP reads the raw data, does the data processing and writes back the results into the write section of the RAM. From there, the user can read the final results through the serial interface.

Some of the RAM cells are dedicated to special functions and will be described in the following in detail.

Figure 118:

RAM Structure in Detail

<table><tr><td colspan="3">RAM: DSP Read</td><td rowspan="2"/><td colspan="3">RAM: DSP Write</td></tr><tr><td>Addr</td><td>Description</td><td>Bits</td><td>Addr</td><td>Description</td><td>Bits</td></tr><tr><td>127</td><td colspan="5">Reserved</td><td>-</td></tr><tr><td>126</td><td>PORTINFO</td><td>24</td><td rowspan="11"/><td/><td/><td/></tr><tr><td>124</td><td>R_ADD_PTR</td><td>2</td><td/><td/><td/></tr><tr><td>123</td><td>C_ADD_PTR</td><td>4</td><td/><td/><td/></tr><tr><td>122</td><td>TDC_STOP</td><td>27</td><td/><td/><td/></tr><tr><td>121</td><td>TDC_START</td><td>27</td><td/><td/><td/></tr><tr><td>120</td><td>MEM_DATA_u08b</td><td>32</td><td/><td/><td/></tr><tr><td>119</td><td>MEM_DATA_u16b</td><td>32</td><td/><td/><td/></tr><tr><td>118</td><td>MEM_DATA_u24b</td><td>32</td><td/><td/><td/></tr><tr><td>117</td><td>MEM_DATA_s08b</td><td>32</td><td/><td/><td/></tr><tr><td>116</td><td>MEM_DATA_s16b</td><td>32</td><td/><td/><td/></tr><tr><td>115</td><td>MEM_DATA_s24b</td><td>32</td><td/><td/><td/></tr><tr><td>114</td><td colspan="5">MEM_DATA (wr & 4Byte rd)</td><td>32</td></tr><tr><td>113</td><td colspan="5">MEM_ADD</td><td>10</td></tr><tr><td>112</td><td colspan="5">MEM_CTRL</td><td>16</td></tr><tr><td/><td/><td/><td/><td>111</td><td>TIMERO</td><td>16</td></tr><tr><td/><td/><td/><td/><td>110</td><td>PI1_REF</td><td>16</td></tr><tr><td/><td/><td/><td/><td>109</td><td>PIO_REF</td><td>16</td></tr><tr><td>108</td><td colspan="5">DPTR3</td><td>7</td></tr><tr><td>107</td><td colspan="5">DPTR2</td><td>7</td></tr><tr><td>106</td><td colspan="5">DPTR1</td><td>7</td></tr><tr><td>105</td><td colspan="5">DPTRO</td><td>7</td></tr><tr><td/><td/><td/><td rowspan="5"/><td>104</td><td>RES7</td><td>32</td></tr><tr><td>103</td><td>rad_stack_6b</td><td>6</td><td>103</td><td>RES6</td><td>32</td></tr><tr><td>102</td><td>rad_stack_12b</td><td>12</td><td>102</td><td>RES5</td><td>32</td></tr><tr><td>101</td><td>rad_stack_18b</td><td>18</td><td>101</td><td>RES4</td><td>32</td></tr><tr><td>100</td><td>rad_stack_24b</td><td>24</td><td>100</td><td>RES3</td><td>32</td></tr></table>

<table><tr><td colspan="3">RAM: DSP Read</td><td rowspan="2"/><td colspan="3">RAM: DSP Write</td></tr><tr><td>Addr</td><td>Description</td><td>Bits</td><td>Addr</td><td>Description</td><td>Bits</td></tr><tr><td>99</td><td>rad_stack_30b</td><td>30</td><td rowspan="3"/><td>99</td><td>RES2</td><td>32</td></tr><tr><td>98</td><td>rad_stack_32b</td><td>32</td><td>98</td><td>RES1</td><td>32</td></tr><tr><td>97</td><td>2 last_RAM_address</td><td>32</td><td>97</td><td>RESO</td><td>32</td></tr><tr><td>96</td><td colspan="5">Flags & extended GPIO's</td><td>32</td></tr><tr><td>95</td><td colspan="5">(free) User RAM</td><td>32</td></tr><tr><td>...</td><td colspan="5">...</td><td>32</td></tr><tr><td>0</td><td colspan="5">(free) User RAM</td><td>32</td></tr></table>

Registers 0 to 95, User RAM

This is normal RAM space without any special functions. It is readable and writable via instruction rad.

Example:

Add content of RAM address 12 and 13 and write the result into RAM address 13 rad 12 move a, r rad 13 add r, a

Register 96, Flags & Internal Control Signals Figure 119: Flags

<table><tr><td>Bit</td><td>Flag Name</td><td>Default (after Reset)</td><td>Description</td></tr><tr><td>0</td><td>FIRSTART_N</td><td>0</td><td>Indicates first DSP-Trigger until set to 1 by firmware</td></tr><tr><td>1..2</td><td>Free to use</td><td>0</td><td/></tr><tr><td/><td/><td/><td/></tr><tr><td>3</td><td>RDCHG_COM_INT_SEL</td><td>0</td><td>0 : Use RDCHG_IN_SEL0 1 : Use RDCHG_IN_SEL1 For internal compensation</td></tr><tr><td>4</td><td>Free to use</td><td>0</td><td/></tr><tr><td rowspan="2">5</td><td>FLAG_CDC_INV</td><td>0</td><td>Temporary parameter to ROM routine _ROM_ cdc_____ 0 : Determine inverse ratios reference/sense 1 : Determine ratios sense/reference</td></tr><tr><td>SIGNED_VALUE_NV</td><td>0</td><td>Temporary parameter to ROM routines _ROM_NVblock_copy_32b_ _ROM_NVblock_copy_24b_ _ROM_NVblock_copy_16b_ _ROM_NVblock_copy_08b_ 0 : Treat data from NVRAM as unsigned 1 : Treat data from NVRAM as signed</td></tr><tr><td>6..7</td><td>Reserved</td><td>0</td><td>Temporarily used flags within ROM routines</td></tr><tr><td>8</td><td>RST_RDC</td><td>Pulsed</td><td>Temperature reset. This flag has to be set 1 , after each RDC measurement. Otherwise a new RDC measurement is not possible. This flag is set back to 0 automatically</td></tr><tr><td/><td/><td/><td/></tr><tr><td>9..15</td><td>Reserved</td><td/><td/></tr><tr><td>16..31</td><td>Free to use</td><td>Unknown</td><td/></tr></table>

DSP Read Register 97

This register is there to get the N-th power of 2 . The exponent \( \mathrm{N} \) needs to be written to the RAD stack. The result can be read from register 81. In the assembler, the necessary three

instructions are merged into one:

load2exp a, \( {10};\mathrm{a} = {2}^{10} = {1024} \)

A very simple and efficient method to set an accumulator \( = 1 \) is

load2exp b, \( 0\;;b = {2}^{0} = 1 \) DSP Read Registers 98 to 103

These registers contain the content of the RAM address stack. The 32 bit data is made of the 6 last 6-bit RAM addresses. This address can be used to load 32 bit constants from the program memory into the data space. The necessary instructions are merged into one single instruction by the assembler. (Hint: The assembler accepts negative values as well as decimal and hexadecimal numbers. Depending on the constant to be load, the assembler converts this instruction into 3 to 8 operations)

load a, 1715956 ; a = 1715956

is the same as

rad 0x06

\[
\text{; 0x06 *}{2}^{18}
\]

rad 0x22 ;+0x22 * \( {2}^{12} \)

rad 0x3b ;+0x3b * \( {2}^{6} \)

rad 0x34 ;+ 0x34 = 1715956

rad 100 ; rad_stack_24b

move a, r

DSP Read/Write Registers 105 to 108, Data Pointer

These registers may be used for indirect addressing. They are 7 bits wide.

Load a register with the address you want to manipulate:

load a, <myaddress> load a, <myaddress> rad DPTR0 rad 105 move r, a move \( r \) , a

Load a RAM address pointer with content of DPTR0:

rad_at_DPTR0; now ram address pointer is set to content of DPTRO

Hint: In the <pcap_standard.h> "_at_DPTR0" to "_at_DPTR3" are set to values of 284 to 287. These are no valid RAM addresses but just indicators to the assembler to generate the corresponding opcodes. DSP Read Register 126, PORTINFO (PORTERR<7...0>, PORTMASK<7...0>) The low 8 bits mirror the port enable setting as defined by configuration parameter C_PORT_EN in register 12. Bits 8 to 17 are error flags for the capacitance ports including the internal reference ports. DSP Write Registers 97 to 104, RES00...RES07 These are the result registers to which the DSP has to write the output data so that the user can read those through the SPI/IIC interface as Res 0 to Res 7.

Example direct memory address: Copy a memory block from one address to another:

<table><tr><td>_____sub_dma__:</td><td/><td>; DPTR1 : source_address; DPTR0 :</td></tr><tr><td>not b</td><td>; initialize loop counter</td><td>destination address; b: length of dma</td></tr><tr><td>inch</td><td>; with - <length></td><td/></tr><tr><td>_sub_dma_loop_:</td><td>;</td><td/></tr><tr><td>rad_at_DPTR1</td><td>; copy a : @DPTR1</td><td/></tr><tr><td>move a, r</td><td/><td/></tr><tr><td>rad_at_DPTRO</td><td>; copy @DPTR0 : a</td><td/></tr><tr><td>move r, a</td><td/><td/></tr><tr><td/><td/><td/></tr><tr><td>rad DPTR0</td><td>; increment destination</td><td/></tr><tr><td>incr</td><td>; address</td><td/></tr><tr><td>rad DPTR1</td><td>; increment source add</td><td/></tr><tr><td>incr</td><td>;</td><td/></tr><tr><td>inc b</td><td>; increment loop</td><td/></tr><tr><td/><td>; counter</td><td/></tr><tr><td>jNE __sub_dma_loop__ jrt</td><td>; loop body</td><td/></tr></table>

All addresses are 32 bit wide.

!!! Attention: These Registers are write only! The DSP cannot read from these Registers !!!

DSP Write Registers 109, 110, PIO_REF...PI1_REF

These registers contain the data that is used to generate the PWM/PDM output signals. After the DSP has calculated and scaled the output data, it writes those into these two registers. The data are 16 bit wide.

DSP Write Register 111, TIMERO

The DSP has a 16-bit timer based on the OLF clock. This timer may be used to generate long delays while the DSP is halted. Bit #3 (timer) in DSP_START_EN must be set!

By writing a value to Register 111 the timer starts to count up from 0 each OLF-clock cycle until the written value has been reached. Then a DSP_START_TRIG is generated.

If the DSP is not halted the TIMERO_IRQ_N Flag could be tested anyway. am. Example 1 (without halting DSP):

CONST wait_time_1ms50 ;50*20μs (@50kHz)

...

load a, wait_time_1ms

rad TIMERO

move r, a

timer_wait_loop:

jcd TIMERO_IRQ_N, timer_wait_loop

## Example 2 (with halting DSP, DSP run on internal oscillator):

CONST wait_time_1ms50 ;50*20μs (@50kHz)

...

ORG 0

jcd TIMERO_IRQ_N, Skip_Timer0_process

jsb Triggered_by_Timer0

Skip_Timer0_process:

...

load a, wait_time

rad TIMERO

move r, a

stop

Triggered_by_Timer0:

...

DSP Read/Write Registers 112 to 120, MEM_CTRL, MEM_ ADD, MEM_DATA

Those registers are used by ROM routines for the transfer of data between NVRAM and RAM. It is possible to transfer data between NVRAM and accumulators a and b, from 1 to 4 bytes, signed and unsigned.

- MEM_CTRL: defines the operation. The four options are

- MEM_STORE: write to NVRAM

- MEM_RECALL: read from NVRAM

- MEM_WE: enable writing

- MEM_WR_PROTECT: protect against arbitrary writing

- MEM_ADD: defines the target address in the NVRAM

- MEM_DATA_xxx: registers for write or read data. Data that shall be written into NVRAM data need to be in RAM address 114. Data that have been read from NVRAM can be found in addresses 114 to 120 , depending on the format.

## amm

These calls are used e.g. to copy constants and calibration data from the NVRAM to the RAM.

---

Example: Copying the NV_C_sens_sel register to RAM

load a, NV_C_sens_sel ; mem_add : NV_C_sens_sel

rad mem_add

	move r, a

jsb _ROM_memory_rd_a_u08b _ ; A contains

	content of NV_C_sens_sel

rad RAM_C_sens_sel

	move ríng

---

These registers may be used by the DSP to change the configuration on the fly. Important note: After writing to the NVRAM it is necessary to do an ini_reset. Therefore the DSP has to do the following sequence of setting flags DSP_6 and DSP_7.

; Initreset

bitC 7

bitC 6

bits 6

bitC 6

bitS 6

DSP Read Registers 121 to 124, TDC_START, TDC_STOP, C_ADD_PTR, R_ADD_PTR

ams internal data, used by ROM routine _____tdc_dispatch_____

## NVRAM and ROM

The total program memory is made of \( 1\mathrm{\;k} \) NVRAM and \( 3\mathrm{\;k} \) ROM. The NVRAM holds configuration data, 960 byte of user code and some special registers. The ROM holds useful mathematical routines that make programming very efficient.

## NVRAM Structure

The user space is split in three sections. The reason is that the NVRAM can be read/write protected by section. A big section of 704 byte is for program code, two smaller sections of 128 byte may be used for calibration data or additional firmware.

Figure 120:

NVRAM Organization

<table><tr><td colspan="2">Address</td><td colspan="2">NVRAM (1k x 8 bit)</td><td>Memory Lock</td></tr><tr><td>Decimal</td><td>Hexadecimal</td><td>Contents</td><td>Length [Byte]</td><td>Settings</td></tr><tr><td>1023 to 1022</td><td>3FF to 3FE</td><td>CHARGE_PUMP</td><td>2</td><td>MEM_LOCK<3></td></tr><tr><td>1021 to 1011</td><td>3FD to 3F3</td><td>Reserved</td><td>11</td><td/></tr><tr><td>1010 to 1009</td><td>3F2 to 3F1</td><td>S/N customer</td><td>2</td><td/></tr><tr><td>1008</td><td>3F0</td><td>MEM_LOCK</td><td>1</td><td/></tr><tr><td>1007 to 960</td><td>3EF to 3C0</td><td>Configuration Registry</td><td>48</td><td>MEM_LOCK<3></td></tr><tr><td>959 to 832</td><td>3BF to 340</td><td>User Space (FW/CAL1)</td><td>128</td><td>MEM_LOCK<2></td></tr><tr><td>831 to 704</td><td>33F to 2C0</td><td>User Space (FW/CALO)</td><td>128</td><td>MEM_LOCK<1></td></tr><tr><td>703 to 0</td><td>2BF to 0</td><td>User Space (FW)</td><td>704</td><td>MEM_LOCK<0></td></tr></table>

The NVRAM consists of two parts: a volatile SRAM and a non-volatile memory (FLASH). There is a store/recall method to copy (store) the complete SRAM content to FLASH or to recall it from FLASH back to SRAM.

Different methods of operation apply:

## Stand Alone:

Configuration data, firmware and calibration values are stored once to non-volatile memory and autoboot is selected. After a power-on the device starts immediately with the measurement.

## Pre-Configured:

Configuration data, firmware and calibration values are stored once to nonvolatile memory, RUNBIT and autoboot are disabled. After power-on, the device is programmed and configured, but in idle mode, waiting for instructions.

## Pure Slave:

Configuration data, firmware and calibration values are written to the SRAM (volatile memory) after each power on by an external \( \mu \mathrm{C} \) .

## amm

NVRAM Access

There are three commands available to handle the NVRAM, Store, Recall & Erase, each one protected to avoid accidental trigger during communication over the serial interface. It is mandatory to send first an activation code to register 54 (MEM_ CTRL). This is followed by the according opcode \( (\parallel  = \) termination of SIF, e.g. setting SSN = HIGH):

Store SRAM content into NVRAM: Activation code in MEM_CTRL: 0x2D Store NVRAM opcode: 0x96 (Send via SIF: 0xA3F62D || 0x96, wait minimum 12 ms)

Recall from NVRAM into SRAM: Activation in MEM_CTRL: 0x59 Recall from NVRAM opcode: 0x99 (Send via SIF: 0xA3F659 || 0x99)

Erase NVRAM: Read trim bits adr 1022&1023 and Unique ID from adr 954 to 959 Activation in MEM_CTR: 0xB8 Erase NVRAM opcode: 0x9C (Send via SIF: 0xA3F6B8 || 0x9C, wait minimum 12ms) Write back trim bits adr 1022&1023 and Unique ID to adr 954 to 959 Activation code in MEM_CTRL: 0x2D Store NVRAM opcode: 0x96

Important Note: We guarantee the data for data retention and endurance only under the assumption, that the customer does not change the registers 62 and 63 and NVRAM adr 954 to 959 (Unique ID). In addition, it is mandatory to follow the given procedure for ERASE NVRAM as described in section NVRAM and ROM precisely. Otherwise, we do no longer guarantee the data retention time and endurance cycles.

## ROM Structure

The limitation in size for the NVRAM is compensated by having many functions integrated hard-wired in \( 3\mathrm{k} \) ROM. The ROM routines range from simple shift functions over filters to polynomial linearization of \( {4}^{\text{th }} \) degree. This allows to keep the user code very compact.

The assembler comes with header file PCap04_ROM_ addresses_standard.h that lists the jump-in addresses for the various ROM routines. For details see section Sample Code / Libraries.

## DSP Inputs & Outputs

The DSP has access to 64 bits of information on ALU status, start trigger, configuration, input / output pins.

This information can be interpreted by means of instructions jcd or conditional jump.

Instruction conditional jump looks like:

jcd \( \;{p1},{p2} \) : if \( {p1} =  = 1 \) then jump to \( {p2},{p1} = \) flag number

16 of those bits can be set by the DSP, e.g. to set a GPIO or to select between RDC and CDC data. The bits are controlled by means of instructions bitS / bitC (bit Set/bit Clear).

Figure 121:

DSP Inputs / Outputs

<table><tr><td>Bit Name</td><td>Description</td><td>Type</td><td>Read Bit #</td><td>Write Bit #</td></tr><tr><td>DSP_OUT<7...0></td><td>Status feedback of the 8 general DSP outputs (Write bits 0 to 7).</td><td>IN</td><td>56 to 63</td><td/></tr><tr><td>SIF_TRIGGERED_N (1)</td><td>Flag \( = \) LOW indicates that a falling edge at a pin or an SPI/IIC opcode has started the DSP. This flag is reset by a STOP instruction at the end of the firmware.</td><td>Start trigger</td><td>55</td><td/></tr><tr><td>PIN_TRIGGERED_N (1)</td><td>Flag \( = \) LOW indicates a GPIO has started the DSP</td><td/><td>54</td><td/></tr><tr><td/><td/><td/><td/><td/></tr><tr><td>TDC_TRIGGERED_R_N (1)</td><td>Flag \( = \) Low indicates that a single time-values from Resistance (Temperature) measurement are available and must be processed (done by ROM routine _ROM_tdc_dispatch__)</td><td/><td/><td/></tr><tr><td>TDC_TRIGGERED_C_N (1)</td><td>Flag \( = \) LOW indicates that time-values from Capacitance measurement are available and must be processed (done by ROM routine _ ROM_tdc_dispatch__)</td><td>Start trigger</td><td>52</td><td/></tr><tr><td>INTN_TRIGGERED_N (1)</td><td>Flag \( = \) LOW indicates the DSP is started by rising edge of INTN-Signal</td><td>Start trigger</td><td>51</td><td/></tr><tr><td>TIMERO_IRQ_N (1)</td><td>Flag \( = \) LOW indicates the DSP is started by the internal timer</td><td>Start trigger</td><td>50</td><td/></tr><tr><td>RDC_TRIGGERED_N (1)</td><td>Flag \( = \) LOW indicates that an RDC measurement has started the DSP. Therefore, DSP STARTONTEMP has to be set (configuration register 8). This flag is reset by a STOP instruction at the end of the firmware.</td><td>Start trigger</td><td>49</td><td/></tr><tr><td>CDC_TRIGGERED_N (1)</td><td>Indicates the DSP is started by the end of the capacitance conversion.</td><td>Start trigger</td><td>48</td><td/></tr></table>

<table><tr><td>Bit Name</td><td>Description</td><td>Type</td><td>Read Bit #</td><td>Write Bit #</td></tr><tr><td>ALU_OFL_N</td><td rowspan="8">ALU flags for overflow, carry, equal and sign. The ALU flags are used by the jump instruction of the assembler</td><td>Status</td><td>47</td><td/></tr><tr><td>ALU_OFL</td><td>Status</td><td>46</td><td/></tr><tr><td>ALU_CAR_N</td><td>Status</td><td>45</td><td/></tr><tr><td>ALU_CAR</td><td>Status</td><td>44</td><td/></tr><tr><td>ALU_EQ / ALU_ZERO</td><td>Status</td><td>43</td><td/></tr><tr><td>ALU_NE / ALU_ZERO_N</td><td>Status</td><td>42</td><td/></tr><tr><td>ALU_POS</td><td>Status</td><td>41</td><td/></tr><tr><td>ALU_NEG</td><td>Status</td><td>40</td><td/></tr><tr><td>FLAGREG_N[7:0]</td><td>Lower 8bits, inverted Flags from FLAGREG (register 96)</td><td>Flag</td><td>32..39</td><td/></tr><tr><td>AWAKE_TRIGGERED_N</td><td>After setting RUNBIT to 1 the DSP is triggered immediately. This flag shows this trigger source. Used for initialize raw result registers before first measurement (used by ROM routine _ROM_tdc_dispatch_)</td><td>Start Trigger</td><td>31</td><td/></tr><tr><td/><td/><td/><td/><td/></tr><tr><td>TDC_RDY</td><td>Flag \( = \) Low indicates TDC-Ring oscillator is running</td><td>Status</td><td>28</td><td/></tr><tr><td>POR_CDC_DSP_COLL</td><td>Flag \( = \) Low indicates reset forced by a CDC / DSP collision</td><td>Status</td><td>27</td><td/></tr><tr><td>LAST_CYCLE_ACTIVE_N</td><td>Flag \( = \) Low indicates that this is the last CDC measurement in the current sequence (used for ROM routine _ROM_tdc_dispatch__)</td><td>Status</td><td>26</td><td/></tr><tr><td/><td/><td/><td/><td/></tr><tr><td>CYC_ACTIVE</td><td>Flag \( = \) bit 23 of status register. Indicates that the CDC frontend is active. (not negated)</td><td>Status</td><td>25</td><td/></tr><tr><td>POR_FLAG_WD</td><td>Flag \( = \) Low indicates a reset was forced by watchdog timeout</td><td>Status</td><td>24</td><td/></tr><tr><td>POR_FLAG_PARITY</td><td>Flag \( = \) Low indicates a reset was forced by one or more configuration bits toggled by interferences.</td><td>Status</td><td>23</td><td/></tr><tr><td>CONTINUOUS_N</td><td>Low : Continuous mode is activated</td><td>Config Reg</td><td>22</td><td/></tr><tr><td>AUTOSTART_N</td><td>Bit from configuration register</td><td>Config Reg</td><td>21</td><td/></tr><tr><td>C_REF_INT</td><td>Bit from configuration register</td><td>Config Reg</td><td>20</td><td/></tr></table>

<table><tr><td>Bit Name</td><td>Description</td><td>Type</td><td>Read Bit #</td><td>Write Bit #</td></tr><tr><td>TIMER_TRIG_DSP</td><td/><td/><td>19</td><td/></tr><tr><td>(TRUE)</td><td>Constant 1, usable for "goto" jcd TRUE, <jump_ address></td><td/><td>18</td><td/></tr><tr><td>INT_TRIG_BG_N</td><td>Bit from configuration register</td><td>Config Reg</td><td>17</td><td/></tr><tr><td>CDC_TRIG_BG_N</td><td>Bit from configuration register</td><td>Config Reg</td><td>16</td><td/></tr><tr><td>C_COMP_EXT_N</td><td>Bit from configuration register</td><td>Config Reg</td><td>15</td><td/></tr><tr><td>C_COMP_IN_N</td><td>Bit from configuration register</td><td>Config Reg</td><td>14</td><td/></tr><tr><td>C_SINGLE / C_DIFFERENTIAL_N</td><td>Bit from configuration register</td><td>Config Reg</td><td>13</td><td/></tr><tr><td>C_GROUNDED / C_FLOATING_N</td><td>Bit from configuration register</td><td>Config Reg</td><td>12</td><td/></tr><tr><td>ERR_OVFLN</td><td>Flag \( = \) bit 16 of status register. Indicates an overflow or other error in the TDC.</td><td>Status</td><td>11</td><td/></tr><tr><td>COMB_ERRN</td><td>Flag \( = \) bit 16 of status register. This is a combined condition of all known error conditions.</td><td>Status</td><td>10</td><td/></tr><tr><td>CYC_ACTIVE_N</td><td>Flag \( = \) bit 23 of status register. Indicates that the CDC frontend is active. (negated)</td><td>Status</td><td>9</td><td/></tr><tr><td>SIF_RES_RD_BSY</td><td/><td>Status</td><td>8</td><td/></tr><tr><td>RAM_BUSY</td><td>Indicates, NVRAM is busy</td><td>Status</td><td>7</td><td/></tr><tr><td>Interrupt_In</td><td>Port INTN will be reset by a positive edge on SSN (SPI) or a stop condition \( \left( {{\mathrm{I}}^{2}\mathrm{C}}\right) \) , whith this flag the current status of INTN can be detected</td><td>Status</td><td>6</td><td/></tr><tr><td>TEMPERR_N</td><td>Flag \( = \) bit 3 of status register 1 . Indicates whether an error occurred during the temperature measurement. 0 : Error, 1 : No error</td><td>Status</td><td>5</td><td/></tr><tr><td>RDC_BUSY</td><td>Flag \( = \) bit 2 of status register. Indicates RDC unit is busy. 0 : Measurement done, 1 : Measurement running.</td><td>Status</td><td>4</td><td/></tr><tr><td>TRIG_BG</td><td>This parameter starts the Bandgap (to synchronize with measurement) (pulse, automatically set to 0)</td><td>Out</td><td/><td>15</td></tr><tr><td>(MEM_PUSH)</td><td>Reserved, only usable by ROM routines</td><td>Out</td><td/><td>14</td></tr></table>

<table><tr><td>Bit Name</td><td>Description</td><td>Type</td><td>Read Bit #</td><td>Write Bit #</td></tr><tr><td>RST_CDC</td><td>CDC reset. This flag has to be set 1 , after each CDC measurement. Otherwise, a new CDC measurement is not possible. This flag is set back to 0 automatically</td><td>Out</td><td/><td>13</td></tr><tr><td>(MEM_RD)</td><td>Reserved, only usable by ROM routines</td><td>Out</td><td/><td>12</td></tr><tr><td>Interrupt_Out</td><td>Sets the interrupt (pin PG4 or PG5, see register 30) (pulse, automatically set to 0)</td><td>Out</td><td/><td>11</td></tr><tr><td>(PAGE)</td><td>Reserved, do not use</td><td>Out</td><td/><td>10</td></tr><tr><td>TRIG_RDC</td><td>This bit starts a new RDC measurement. (pulsed, automatically set to 0)</td><td>Out</td><td/><td>9</td></tr><tr><td>TRIG_CDC</td><td>This bit starts a new CDC measurement (pulsed, automatically set to 0)</td><td>Out</td><td/><td>8</td></tr><tr><td>DSP_7</td><td>Those two outputs are used by the DSP for - Reset watchdog - INI_RESET by DSP (Pattern combination of both Outputs are used to prevent these actions triggered accidentally) ; Initreset</td><td>Out</td><td/><td>7</td></tr><tr><td>DSP_6</td><td>bitC 7 bitC 6 bits 6 bitC 6 bitS 6</td><td>Out</td><td/><td>6</td></tr><tr><td>DSP_5</td><td>Sets the general purpose output pin PG5</td><td>Out</td><td/><td>5</td></tr><tr><td>DSP_4</td><td>Sets the general purpose output pin PG4</td><td>Out</td><td/><td>4</td></tr><tr><td>DSP_3</td><td>When the Pulse1 is switched OFF then this bit can be used to set and clear the general purpose output pin PG3. When the Pulse1 is ON then this bit must be cleared so that the Pulse1 output appears on PG3.</td><td>In/Out</td><td>3</td><td>3</td></tr><tr><td>DSP_2</td><td>When the Pulse0 is switched OFF then this bit can be used to set and clear the general purpose output pin PG2. When the Pulse0 is ON then this bit must be cleared so that the Pulse0 output appears on PG2</td><td>In/Out</td><td>2</td><td>2</td></tr><tr><td>DSP_1</td><td rowspan="2">Set or read the general purpose \( 1/{Osat} \) pins \( {PG0} \) & PG1. The assignment is programmable and shown in detail below.</td><td>In/Out</td><td>1</td><td>1</td></tr><tr><td>DSP_0</td><td>In/Out</td><td>0</td><td>0</td></tr></table>

## Note(s):

1. A negative edge on those inputs start the DSP. The status of the start trigger is memorized till the next reset or stop of the DSP. The start trigger information can be read from inputs 48 to 55 by jcd.

ALU Flags

Every ALU operation sets flags. The ALU has four flags: overflow, carry, equal and sign. The following table shows an overview: Figure 122: ALU Flags

<table><tr><td>Flag</td><td>Description</td><td>Format</td><td>Modified by Instructions:</td><td>Interpreted by Instructions:</td><td>Range</td></tr><tr><td>ON</td><td>No Overflow</td><td rowspan="2">signed</td><td rowspan="2">add, sub, mult, div</td><td rowspan="2">jOvIC, jOvIS</td><td>>=- \( {2}^{31} \) and \( <  = {2}^{31} - 1 \)</td></tr><tr><td>O</td><td>Overflow</td><td>\( <  - {2}^{31} \) and \( > {2}^{31} - 1 \)</td></tr><tr><td>CN</td><td>No Carry (1)</td><td rowspan="2">unsigned</td><td rowspan="2">add, sub, mult, div</td><td rowspan="2">jCarC, jCarS</td><td>\( < {2}^{32} \)</td></tr><tr><td>C</td><td>Carry (1)</td><td>>= 2</td></tr><tr><td>Z</td><td>Equal / Zero</td><td rowspan="2">signed / unsigned</td><td rowspan="2">add, sub, mult, div, move, shiftL, shiftR</td><td rowspan="2">jEQ, jNE</td><td>\( =  = 0 \)</td></tr><tr><td>ZN</td><td>Not Equal / Not Zero</td><td>!=0</td></tr><tr><td>S</td><td>Positive</td><td rowspan="2">signed</td><td rowspan="2">add, sub, mult, div, move, shiftL, shiftR</td><td rowspan="2">jPos, jNeg</td><td>>= 0</td></tr><tr><td>SN</td><td>Negative</td><td>\( < 0 \)</td></tr></table>

Note(s):

1. During addition, the carry \( \mathrm{C} \) is set when a carry-over takes place from the most significant bit, else \( \mathrm{C} \) remains at0.

During subtraction, carry \( \mathrm{C} \) is by default 1. Carry \( \mathrm{C} \) is cleared only when the minuend < subtrahend.

E.g. for \( A - B \) : if \( A \geq  B \rightarrow  C = 1 \) ; if \( A < B \rightarrow  C = 0 \) .

In other words, the carry \( C \) is actually the status of the carry of the addition operation \( A + 2 \) ’s complement (B).

## amm

DSPOUT – GPIO Assignment

PCap04 is very flexible with assignment of the various GPIO pins to the DSP inputs/outputs. The following table shows the possible combinations.

Figure 123:

Pin Assignment

<table><tr><td>External Port</td><td>Description</td><td>In/Out</td></tr><tr><td rowspan="4">PGO</td><td>SSN (in SPI-Mode)</td><td>In</td></tr><tr><td>DSP_x_0 or DSP_x_2</td><td>\( {\ln }^{\left( 1\right) }/ \) Out</td></tr><tr><td>FF0 or FF2</td><td>\( {\ln }^{\left( 1\right) } \)</td></tr><tr><td>Pulse0</td><td>Out</td></tr><tr><td rowspan="4">PG1</td><td>MISO (in SPI-Mode)</td><td>Out</td></tr><tr><td>DSP_x_1 or DSP_x_3</td><td>In(1) / Out</td></tr><tr><td>FF1 or FF3</td><td>\( {\ln }^{\left( 1\right) } \)</td></tr><tr><td>Pulse1</td><td>Out</td></tr><tr><td rowspan="3">PG2</td><td>DSP_x_0 or DSP_x_2</td><td>\( {\ln }^{\left( 1\right) }/ \) Out</td></tr><tr><td>FF0 or FF2</td><td>\( {\ln }^{\left( 1\right) } \)</td></tr><tr><td>Pulse0</td><td>Out</td></tr><tr><td rowspan="4">PG3</td><td>DSP_x_1 or DSP_x_3</td><td>\( {\ln }^{\left( 1\right) }/ \) Out</td></tr><tr><td>FF1 or FF3</td><td>In(1)</td></tr><tr><td>Pulse1</td><td>Out</td></tr><tr><td>C_G_MUX_SEL</td><td>Out</td></tr><tr><td rowspan="2">PG4</td><td>DSP_OUT_4 (output only)</td><td>Out</td></tr><tr><td>INTN</td><td>Out</td></tr><tr><td rowspan="2">PG5</td><td>DSP_OUT_5 (output only)</td><td>Out</td></tr><tr><td>INTN</td><td>Out</td></tr></table>

Note(s):

1. These ports provide an optional debouncing filter and an optional pull-up resistor.

Figure 124:

GPIO Assignment

![bo_d3r3s93ef24c73d0qhr0_100_192_274_1272_1737_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_100_192_274_1272_1737_0.jpg)

Figure 125:

Port Trigger Timing

![bo_d3r3s93ef24c73d0qhr0_101_529_379_636_1130_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_101_529_379_636_1130_0.jpg)

There is a possibility to activate a \( {40}\mathrm{\;{ms}} \) debounce filter ("monoflop") for the ports in case these are used as inputs. This might be useful especially in case the DSP is started by the pins (signals FF0, FF2). Figure 125 shows the effect of the monoflop filter.

The settings for this are made in the following configuration registers:

Figure 126:

Ports for Pulse Output

<table><tr><td>Reg</td><td>Parameter</td><td>Settings</td><td>Description</td></tr><tr><td>27</td><td>DSP_MOFLO_EN</td><td>Bit 6 for PGO Bit 7 for PG1</td><td>Activates anti-bouncing filter in PG0 and PG1 lines</td></tr><tr><td>27</td><td>PG0xPG2</td><td>0 : PGO 1 : PG2</td><td rowspan="2">The pulse codes can be output at ports PG0 & PG1 or PG2 &PG3. In \( {\mathrm{I}}^{2}\mathrm{C} \) mode they can be optionally given out on PG2 and PG3, instead of PG0 and PG1.</td></tr><tr><td>27</td><td>PG1xPG3</td><td>0 : PG1 1 : PG3</td></tr><tr><td>29</td><td>DSP_FF_IN</td><td>Bit 0 : PGO Bit 1 : PG1 Bit 2 : PG2 Bit 3 : PG3</td><td>Pin mask for latching flip-flop activation</td></tr><tr><td>30</td><td>PG4_INTN_EN</td><td>Bit 6</td><td>Activates INTN at port PG4</td></tr><tr><td>30</td><td>PG5_INTN_EN</td><td>Bit 7</td><td>Activates INTN at port PG5</td></tr><tr><td>33</td><td>PG_DIR_IN</td><td>0 : Output 1 : Input</td><td>Toggles outputs to inputs (PG3/bit7 to PG0/bit4).</td></tr><tr><td>33</td><td>PG_PU</td><td>Bit 0 : PGO Bit 1 : PG1 Bit 2 : PG2 Bit 3 : PG3</td><td>Activates pull-up resistors in PG0 to PG3 lines; useful for mechanical switches.</td></tr></table>

## aml

## DSP Configuration

Configuration register 8 defines the DSP operation. Relevant bits are:

DSP_SRAM_SEL, DSP_START, DSP_STARTONOVL, DSP_ STARTONTEMP, DSP_STARTPIN, DSP_WATCHDOG_LENGTH, DSP_SPEED

Figure 127:

DSP Configuration

<table><tr><td>Reg</td><td>Parameter</td><td>Settings</td><td>Description</td></tr><tr><td>27</td><td>DSP_SPEED</td><td>0 : Fastest 1 : Fast 2 : Recommended 3 : Low-current (slow)</td><td>Setting the DSP speed</td></tr><tr><td>29</td><td>DSP_STARTONPIN</td><td>0 : FFO 1 : FF1 2 : FF2 3 : FF3</td><td>Pin mask for DSP trigger</td></tr><tr><td>30</td><td>DSP_START_EN<2..0></td><td/><td>DSP trigger enable 'bxxx1 : Trigger by end of CDC 'bxx1x : Trigger by end of RDC (recommended) 'bx1xx : Trigger by timer 'b1xxx : Obsolete</td></tr><tr><td>34</td><td>DSP_TRIG_BG</td><td>0 : Disabled 1 : Enabled</td><td>Bandgap refresh is triggered by start of DSP determination.</td></tr></table>

DSP Start

There are various options to trigger the DSP.

In slave operation:

- Trigger by external controller. This is done by sending opcode "CDC Start conversion" or "DSP_TRIG".

In stand-alone operation:

- Trigger by pin. The trigger pin is selected between pins PGO to PG3 by configuration parameters DSP_STARTPIN and PG0_X_PG2/PG1_X_PG3. Signal FFx triggers the DSP. FFx has to be reset in the firmware by setting DSP_x, e.g. BitS DSP_2

BitC DSP_2

- Trigger by the end of

CDC

RDC

Timer

Or by an interrupt. The option is selected by configuration parameter DSP_START_EN.

(Hint: DSP is also triggered by

- Toggling RUNBIT from 0 to 1 . This is indicated by Flag “AWAKE_TRIGGERED_N”.

- After each CDC or RDC cycle. This is indicated by Flags TDC_C_TRIGGERED_N and TDC_R_TRIGGERED_N)

## Watchdog

The watchdog is based on the OLF clock and counts always, even if the DSP is halted. If the DSP doesn't reset the Watchdog within 9 s to 15 s a power-on reset is generated \( \Rightarrow \) auto-boot. Status Flag POR_FLAG_Wdog is set.

The watchdog is implemented to handle situations where no CDC or RDC is running.

In applications as slave, the watchdog has to be disabled. This can be done by writing a 0x5A to WD_DIS. If the watchdog is used disarm the watchdog in advance to any SIF-Communication.

## System Reset

In case the PCap04 is operated as a slave, not in self-boot mode, it is necessary to do the following actions after applying power:

1. Send opcode Power-on Reset via the serial interface, opcode 0x88 .

2. Write the firmware into the SRAM by means of opcode "Write to SRAM".

3. Write the configuration registers by means of opcode "Write Config". Register 47 with the RUNBIT has to be the last one in order.

4. Send a start command, opcode 0x8C

## amm

## Instruction Set

The complete instruction set of the PCap04 consists of 29 core instructions that have unique op-code decoded by the CPU. Further, ams offers a set of libraries including common constant definitions and mathematical operations

The library family is intended to be continuously expanded and be a great help during software development.

Figure 128:

Instruction Set ams Datasheet [v1-03] 2018-Apr-04

<table><tr><td>Simple Arithmetic</td><td>Miscellaneous</td><td>RAM Access</td><td>Bitwise Operation</td></tr><tr><td>add</td><td>init</td><td>rad</td><td>not</td></tr><tr><td>sign</td><td>nop</td><td>clear</td><td>and</td></tr><tr><td>sub</td><td>rst</td><td>load</td><td>or</td></tr><tr><td>inc</td><td>stop</td><td>load2exp</td><td>xor</td></tr><tr><td/><td>wdr</td><td>mov push pop</td><td/></tr></table>

<table><tr><td>Complex Arithmetic</td><td>Shift & Rotate</td><td>Unconditional Jump</td><td>Bitwise</td></tr><tr><td>div</td><td>shiftL</td><td>goto jsb</td><td>bitC</td></tr><tr><td>mult</td><td>shiftR</td><td>jrt</td><td>bits</td></tr></table>

<table><tr><td colspan="3">Conditional Jump</td></tr><tr><td>jcd</td><td>jEQ</td><td>jOfIC</td></tr><tr><td>jCarC</td><td>jNE</td><td>jOfIS</td></tr><tr><td>jCarS</td><td>jNeg</td><td>jPOS</td></tr></table>

Instructions

<table><tr><td>and</td><td>Bitwise AND</td></tr><tr><td>Syntax:</td><td>and p1, p2</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b, r] p2 = ACCU [a, b, r] p1 != p2</td></tr><tr><td>Calculus:</td><td>p1 : p1 & p2</td></tr><tr><td>Flags affected:</td><td>COSZ</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Bitwise AND (conjunction)</td></tr><tr><td>Category:</td><td>Bitwise operation</td></tr></table>

<table><tr><td>add</td><td>Addition</td></tr><tr><td>Syntax:</td><td>add p1, p2</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b, r] p2 = ACCU [a, b, r]</td></tr><tr><td>Calculus:</td><td>p1 : p1 + p2</td></tr><tr><td>Flags affected:</td><td>COSZ</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Addition of two registers</td></tr><tr><td>Category:</td><td>Simple arithmetic</td></tr></table>

<table><tr><td>bitC</td><td>Clear single bit</td></tr><tr><td>Syntax:</td><td>bitC p1</td></tr><tr><td>Parameters:</td><td>p1 = number 0 to 15</td></tr><tr><td>Calculus:</td><td>Set bit number p1 of the DSP output bits bit \( = 0 \)</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Clear a single bit in the DSP output bits</td></tr><tr><td>Category:</td><td>Bitwise</td></tr></table>

## amm

<table><tr><td>bits</td><td>Set single bit</td></tr><tr><td>Syntax:</td><td>bitS p1</td></tr><tr><td>Parameters:</td><td>p1 = number 0 to 15</td></tr><tr><td>Calculus:</td><td>Set bit number p1 of the DSP output bits bit = 1</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Set a single bit in the DSP output bits</td></tr><tr><td>Category:</td><td>Bitwise</td></tr></table>

<table><tr><td>clear</td><td>Clear register</td></tr><tr><td>Syntax:</td><td>clear p1</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b, r]</td></tr><tr><td>Calculus:</td><td>p1 : 0</td></tr><tr><td>Flags affected:</td><td>S Z</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Clear addressed register to 0</td></tr><tr><td>Category:</td><td>RAM access</td></tr></table>

<table><tr><td>div</td><td>Unsigned division</td></tr><tr><td>Syntax:</td><td>div</td></tr><tr><td>Parameters:</td><td>-</td></tr><tr><td>Calculus:</td><td>Single div code: \( b : \left( {a/r}\right) , a : \) Remainder * 2 N div codes: b : (a/r)*2^(N-1), a : Remainder * (2^N)</td></tr><tr><td>Flags affected:</td><td>S Z</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Unsigned division of two 32-bits registers. When the div opcode is used once, the resulting quotient is assigned to register 'b'. The remainder can be calculated from 'a'. When N div opcodes are used one after another, the result in b : (a/r)*2^(N-1). See also ROM routine div_xx. Before executing the first division step, the following conditions must be satisfied: 'b' = 0, and 0<'a' < 2*'r'. If this condition is not satisfied, you can shift 'a' until this is satisfied. After shifting, if a -> \( \mathrm{a} * \left( {2 \uparrow  \mathrm{{ea}}}\right) \) and \( \mathrm{r} \rightarrow  {\mathrm{r}}^{ * }\left( {2 \uparrow  \mathrm{{er}}}\right) \) , then the resulting quotient \( \mathrm{b} \) for \( \mathrm{N} \) division steps is b: (a/r) * 2^(1+ea-er-N) a = Remainder * (2^N)</td></tr><tr><td>Category:</td><td>Complex arithmetic</td></tr></table>

<table><tr><td>inc</td><td>Increment register</td></tr><tr><td>Syntax:</td><td>inc p1</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b, r]</td></tr><tr><td>Calculus:</td><td>p1 : p1 + 1</td></tr><tr><td>Flags affected:</td><td>COSZ</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Increment register</td></tr><tr><td>Category:</td><td>Simple arithmetic</td></tr></table>

amm

<table><tr><td>init</td><td>Init reset</td></tr><tr><td>Syntax:</td><td>Init</td></tr><tr><td>Parameters:</td><td>-</td></tr><tr><td>Calculus:</td><td>-</td></tr><tr><td>Flags affected:</td><td>COSZ</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Initialization and reset. Sets back CDC, RDC and CPU. Copies configuration from NVRAM into configuration registers.</td></tr><tr><td>Category:</td><td>Miscellaneous</td></tr></table>

<table><tr><td>jCarC</td><td>Jump on Carry Clear</td></tr><tr><td>Syntax:</td><td>jCarC p1</td></tr><tr><td>Parameters:</td><td>p1 = jumplabel</td></tr><tr><td>Calculus:</td><td>if (carry == 0) PC : p1</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Jump on carry clear. Program counter will be set to target address if carry is clear. The target address is given by using a jumplabel. The conditional jump does not serve the stack. Therefore it is not possible to return by jrt. If the target address is beyond the range of current address (PC) -128/+127 bytes, then the assembler software will substitute this opcode for the following optimization: jCarS new_label jsb p1 jrt new_label: In this case the stack will be loaded with p1, and therefore the stack capacity will be reduced by one.</td></tr><tr><td>Category:</td><td>Conditional jump</td></tr></table>

<table><tr><td>jCarS</td><td>Jump on Carry Set</td></tr><tr><td>Syntax:</td><td>jCarS p1</td></tr><tr><td>Parameters:</td><td>p1 = jumplabel</td></tr><tr><td>Calculus:</td><td>if (carry == 1) PC : p1</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Jump on carry set. Program counter will be set to target address if carry is set. The target address is given by using a jumplabel. The conditional jump does not serve the stack. Therefore it is not possible to return by jrt. If the target address is beyond the range of current address (PC) -128/+127 bytes, then the assembler software will substitute this opcode for the following optimization: jCarC new_label jsb p1 jrt new_label: In this case the stack will be loaded with p1, and therefore the stack capacity will be reduced by one.</td></tr><tr><td>Category:</td><td>Conditional jump</td></tr></table>

<table><tr><td>jcd</td><td>Conditional Jump</td></tr><tr><td>Syntax:</td><td>jcd p1, p2</td></tr><tr><td>Parameters:</td><td>p1 = Flag or input port bit [63...0]. See section 2.3 for DSP Inputs. p2 = jumplabel</td></tr><tr><td>Calculus:</td><td>If ( p1 == 1 ) PC : p2</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Program counter is set to target address if the bit given by p1 is set to one. The target address is given by using a jumplabel. The conditional jump does not serve the stack. Therefore it is not possible to return by jrt. If the target address is beyond the range of current address (PC) -128/+127 bytes, then the assembler software will substitute this opcode for the following optimization: jcd p1, new_label1 jsb new_label2 jrt new_label1: jsb p2 jrt new_label2: i…</td></tr><tr><td>Category:</td><td>Conditional jump</td></tr></table>

ams Datasheet

[v1-03] 2018-Apr-04 amm am.

<table><tr><td>jEQ</td><td>Jump on Equal</td></tr><tr><td>Syntax:</td><td>jEQ p1</td></tr><tr><td>Parameters:</td><td>p1 = jumplabel</td></tr><tr><td>Calculus:</td><td>if (Z == 0) PC : p1</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Jump on equal resp. zero. Program counter will be set to target address if the foregoing result is zero. The target address is given by using a jumplabel. The conditional jump does not serve the stack. Therefore it is not possible to return by jrt. If the target address is beyond the range of current address (PC) -128/+127 bytes, then the assembler software will substitute this opcode for the following optimization: jNE new_label jsb p1 jrt new_label: In this case the stack will be loaded with p1, and therefore the stack capacity will be reduced by one.</td></tr><tr><td>Category:</td><td>Conditional jump</td></tr></table>

<table><tr><td>jNE</td><td>Jump on Not Equal</td></tr><tr><td>Syntax:</td><td>jNE p1</td></tr><tr><td>Parameters:</td><td>p1 = jumplabel</td></tr><tr><td>Calculus:</td><td>if (Z == 1) PC : p1</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Jump on not equal resp. not zero. Program counter will be set to target address if the foregoing result is zero. The target address is given by using a jumplabel. The conditional jump does not serve the stack. Therefore it is not possible to return by jrt. If the target address is beyond the range of current address (PC) -128/+127 bytes, then the assembler software will substitute this opcode for the following optimization: jEQ new_label jsb p1 jrt new_label: In this case the stack will be loaded with p1, and therefore the stack capacity will be reduced by one.</td></tr><tr><td>Category:</td><td>Conditional jump</td></tr></table>

<table><tr><td>jNeg</td><td>Jump on Negative</td></tr><tr><td>Syntax:</td><td>jNeg p1</td></tr><tr><td>Parameters:</td><td>p1 = jumplabel</td></tr><tr><td>Calculus:</td><td>if (S == 1) PC : p1</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Jump on negative. Program counter will be set to target address if the foregoing result is negative (Bit \( {31} =  = 1 \) ). The target address is given by using a jumplabel. If the target address is beyond the range of current address (PC) -128/+127 bytes, then the assembler software will substitute this opcode for the following optimization: jPos new_label jsb p1 jrt new_label: In this case the stack will be loaded with p1, and therefore the stack capacity will be reduced by one.</td></tr><tr><td>Category:</td><td>Conditional jump</td></tr></table>

<table><tr><td>jOvIC</td><td>Jump on Overflow Clear</td></tr><tr><td>Syntax:</td><td>jOvIC p1</td></tr><tr><td>Parameters:</td><td>p1 = jumplabel</td></tr><tr><td>Calculus:</td><td>if (O == 0) PC : p1</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Jump on overflow clear. Program counter will be set to target address if the overflow flag of the foregoing operation is clear. The target address is given by using a jumplabel. The conditional jump does not serve the stack. Therefore it is not possible to return by jrt. If the target address is beyond the range of current address (PC) -128/+127 bytes, then the assembler software will substitute this opcode for the following optimization: jOfIS new_label jsb p1 jrt new_label: In this case the stack will be loaded with p1, and therefore the stack capacity will be reduced by one.</td></tr><tr><td>Category:</td><td>Conditional jump</td></tr></table>

<table><tr><td>jOvIS</td><td>Jump on Overflow Set</td></tr><tr><td>Syntax:</td><td>jOvIS p1</td></tr><tr><td>Parameters:</td><td>p1 = jumplabel</td></tr><tr><td>Calculus:</td><td>if (O == 1) PC : p1</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Jump on overflow set. Program counter will be set to target address if the overflow flag of the foregoing operation is set. The target address is given by using a jumplabel. The conditional jump does not serve the stack. Therefore it is not possible to return by jrt. If the target address is beyond the range of current address (PC) -128/+127 bytes, then the assembler software will substitute this opcode for the following optimization: jOfIC new_label jsb p1 jrt new_label: In this case the stack will be loaded with p1, and therefore the stack capacity will be reduced by one.</td></tr><tr><td>Category:</td><td>Conditional jump</td></tr></table>

<table><tr><td>jPos</td><td>Jump on Positive</td></tr><tr><td>Syntax:</td><td>jPos p1</td></tr><tr><td>Parameters:</td><td>p1 = jumplabel</td></tr><tr><td>Calculus:</td><td>if (S == 0) PC : p1</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Jump on positive. Program counter will be set to target address if the foregoing result is positive \( \left( {\text{Bit }{31} =  = 0}\right) \) . The target address is given by using a jumplabel. The conditional jump does not serve the stack. Therefore it is not possible to return by jrt. If the target address is beyond the range of current address (PC) -128/+127 bytes, then the assembler software will substitute this opcode for the following optimization: jNeg new_label jsb p1 jrt new_label: In this case the stack will be loaded with p1, and therefore the stack capacity will be reduced by one.</td></tr><tr><td>Category:</td><td>Conditional jump</td></tr></table>

<table><tr><td>jrt</td><td>Return from subroutine</td></tr><tr><td>Syntax:</td><td>jrt</td></tr><tr><td>Parameters:</td><td>-</td></tr><tr><td>Calculus:</td><td>PC : PC from jsub-call</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Return from subroutine. A subroutine can be called via 'jsb' and exited by using jrt. The program is continued at the next command following the jsb-call. You have to close a subroutine with jrt - otherwise there will be no jump back. The stack is decremented by 1 .</td></tr><tr><td>Category:</td><td>Unconditional Jump</td></tr></table>

<table><tr><td>goto</td><td>Unconditional relative Jump</td></tr><tr><td>Syntax:</td><td>goto p1</td></tr><tr><td>Parameters:</td><td>p1 = jumplabel</td></tr><tr><td>Calculus:</td><td>PC : p1</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Jump to jumplabel. Program counter will be set to target address. The target address is given by using a jumplabel. The goto command does not serve the stack. Therefore it is not possible to return by jrt. If the target address is beyond the range of current address (PC) -128/+127 bytes, then the assembler software will substitute this opcode for the following optimization: goto new_label1 jsb new_label2 jrt new_label1: jsb p2 jrt new_label2: i…</td></tr><tr><td>Category:</td><td>Unconditional Jump</td></tr></table>

<table><tr><td>jsb</td><td>Unconditional Jump</td></tr><tr><td>Syntax:</td><td>jsb p1</td></tr><tr><td>Parameters:</td><td>p1 = jumplabel</td></tr><tr><td>Calculus:</td><td>PC : PC from jsub-call</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Jump to subroutine without condition. The programm counter is loaded by the address given through the jumplabel. The subroutine is processed until the keyword 'jrt' occurs. Then a jump back is performed and the next command after the jsub-call is executed. This opcode needs temporarily a place in the program counter stack (explanation see below). The stack is incremented by 1 .</td></tr><tr><td>Category:</td><td>Unconditional Jump</td></tr></table>

<table><tr><td>load</td><td>Load Accumulator</td></tr><tr><td>Syntax:</td><td>load p1, p2</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b] p2 = 6..32-bit integer number (positive/negative, decimal or hexadecimal)</td></tr><tr><td>Calculus:</td><td>p1 : p2</td></tr><tr><td>Flags affected:</td><td>S Z</td></tr><tr><td>Bytes:</td><td>3..8 (depending on p2)</td></tr><tr><td>Description:</td><td>Move constant to p1 (p1=ACCU, p2=NUMBER) The following instruction is not allowed: load r, NUMBER This instruction is a macro that is replaced by the following opcodes: rad NUMBER[23:18] rad NUMBER[17:12] rad NUMBER[11:6] rad NUMBER[5:0] rad rad_stack_24b move [a, b], r Here the 24-bits number is split into four pieces, the symbol [xx:yy] indicates the individual bit range belonging to each piece. Please notice that the ram address pointer is changed during the operations, keep this in mind while coding.</td></tr><tr><td>Category:</td><td>RAM access</td></tr></table>

<table><tr><td>load2exp</td><td>Load Accumulator with 2exp</td></tr><tr><td>Syntax:</td><td>load2exp p1, p2</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b] p2 = 6-bit number</td></tr><tr><td>Calculus:</td><td>p1 : 2^p2</td></tr><tr><td>Flags affected:</td><td>S Z</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Move 2^(p2) to p1(p1=ACCU, p2=NUMBER) The following instruction is not allowed: load r, NUMBER This instruction is a macro that is replaced by the following opcodes: rad NUMBER[5:0] rad load2exp move [a, b], r</td></tr><tr><td>Category:</td><td>RAM access</td></tr></table>

<table><tr><td>mov</td><td>Move</td></tr><tr><td>Syntax:</td><td>mov p1, p2</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b, r] p2 = ACCU [a, b, r]</td></tr><tr><td>Calculus:</td><td>p1 : p2</td></tr><tr><td>Flags affected:</td><td>S Z</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Move content of p2 to p1 Assembler will understand also the old opcode move</td></tr><tr><td>Category:</td><td>RAM access</td></tr></table>

<table><tr><td>mult</td><td>Multiply</td></tr><tr><td>Syntax:</td><td>mult</td></tr><tr><td>Parameters:</td><td>-</td></tr><tr><td>Calculus:</td><td>ab : (b * r)</td></tr><tr><td>Flags affected:</td><td>S Z</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Unsigned multiplication of the content of ab and \( r \) registers. ab is the composition of the registers a and b, forming an 64-bits long register, where 'a' takes the most significant bits, and register 'b' takes the less significant ones. The result is stored in the composed register a and b. The register ’a’ must be previously cleared. This instruction only executes one multiplication step, to execute a full 32-bits multiplication, this instruction must be executed 32 times. This has the disadvantage of being tedious to code, but also has the advantage of executing only the amount of arithmetic needed, if you do not need a 32-bits multiplication but \( \mathrm{N} \) , where \( \mathrm{N} < {32} \) , then you have only to execute \( \mathrm{N} \) multiplication steps in order to complete the full \( \mathrm{N} \) -bits multiplication. After one multiplication step, register 'a' contains ((a+(b[0]*r))>>1), and register 'b' contains \( \{ \mathrm{a}\left\lbrack  0\right\rbrack  ,\mathrm{b}\left\lbrack  {3 : 1}\right\rbrack  \} \) . For example: lets denote the individual bits of register ’ \( \mathrm{a} \) ’ as a \( \left\lbrack  {31}\right\rbrack \) , a[30], a[29].....a[2], a[1], a[0], and lets denote a range of bits of 'a' as: a[3:0], meaning the 4 less significant bits of register ‘a’ Then, after one multiplication step, a[30:0] = (a[31:0] + r[31:0] * b[0]) >> 1, where >> 1, means right shift by one position; the value of a[31] is zero, and b[31] = (a[0] + r[0] * b[0]), and \( \mathrm{b}\left\lbrack  {{30} : 0}\right\rbrack   = \mathrm{b}\left\lbrack  {311}\right\rbrack \) . The register \( \mathrm{r} \) remains unchanged.</td></tr><tr><td>Category:</td><td>Complex arithmetic</td></tr></table>

<table><tr><td>nop</td><td>No operation</td></tr><tr><td>Syntax:</td><td>-</td></tr><tr><td>Parameters:</td><td>-</td></tr><tr><td>Calculus:</td><td>-</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Placeholder code or timing adjust (no function)</td></tr><tr><td>Category:</td><td>Miscellaneous</td></tr></table>

<table><tr><td>not</td><td>Bitwise NOT</td></tr><tr><td>Syntax:</td><td>not p1</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b, r]</td></tr><tr><td>Calculus:</td><td>p1 : ~p1</td></tr><tr><td>Flags affected:</td><td>COSZ</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Invert register (negation)</td></tr><tr><td>Category:</td><td>Bitwise operation</td></tr></table>

<table><tr><td>or</td><td>Bitwise OR</td></tr><tr><td>Syntax:</td><td>or p1, p2</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b, r] p2 = ACCU [a, b, r] p1 != p2</td></tr><tr><td>Calculus:</td><td>p1 : p1 | p2</td></tr><tr><td>Flags affected:</td><td>COSZ</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Bitwise OR (disjunction)</td></tr><tr><td>Category:</td><td>Bitwise operation</td></tr></table>

<table><tr><td>pop</td><td>Remove address</td></tr><tr><td>Syntax:</td><td>pop</td></tr><tr><td>Parameters:</td><td>-</td></tr><tr><td>Calculus:</td><td>-</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Roll back ram-address stack</td></tr><tr><td>Category:</td><td>RAM access</td></tr></table>

<table><tr><td>rst</td><td>Power On Reset</td></tr><tr><td>Syntax:</td><td>rst</td></tr><tr><td>Parameters:</td><td>-</td></tr><tr><td>Calculus:</td><td>-</td></tr><tr><td>Flags affected:</td><td>S Z</td></tr><tr><td>Bytes:</td><td>5</td></tr><tr><td>Description:</td><td>This is a symbolic opcode which is equivalent to the following instruction sequence: bitC 54 bitC 55 bitS 55 bitS 54 bitC 55 The assembler understands also the old powerOnReset</td></tr><tr><td>Category:</td><td>Miscellaneous</td></tr></table>

<table><tr><td>push</td><td>Put data into stack memory</td></tr><tr><td>Syntax:</td><td>push p1</td></tr><tr><td>Parameters:</td><td>p1 = NUMBER [6-bit]</td></tr><tr><td>Calculus:</td><td>-</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Writes p1 to RAM address stack (range: 0 to 63). Commit constant value to ROM routines. push 22 ; number of fractional digits for CDC ratios push 4 ; Port Number for reference value (PC4) jsb _ROM_CDC_ Note: for advanced users only. Better use rad</td></tr><tr><td>Category:</td><td>RAM access</td></tr></table>

<table><tr><td>rad</td><td>Set RAM Address Pointer</td></tr><tr><td>Syntax:</td><td>rad p1</td></tr><tr><td>Parameters:</td><td>p1 = NUMBER [7-bit]</td></tr><tr><td>Calculus:</td><td>-</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>2</td></tr><tr><td>Description:</td><td>Set pointer to RAM address (range: 0 to 127) in the RAM address stack. Note: Internally the RAM is made of 2 pages, 64 words each. The assembler translates the combination of a bitS/C and a push instruction into the rad instruction. rad 15 move \( r, b \) will move the content of \( b \) the address 15</td></tr><tr><td>Category:</td><td>RAM access</td></tr></table>

<table><tr><td>wdr</td><td>Clear watch dog timer</td></tr><tr><td>Syntax:</td><td>wdr</td></tr><tr><td>Parameters:</td><td>-</td></tr><tr><td>Calculus:</td><td>-</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>5</td></tr><tr><td>Description:</td><td>Clear watchdog timer. This is a symbolic opcode which is equivalent to the following instruction sequence: bitC 54 bitC 55 bitS 54 bitS 55 bitC 54 The assembler understands also the old resetWDG opcode</td></tr><tr><td>Category:</td><td>Miscellaneous</td></tr></table>

<table><tr><td>shiftL</td><td>Shift Left</td></tr><tr><td>Syntax:</td><td>shiftL p1</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b]</td></tr><tr><td>Calculus:</td><td>p1 : p1 << 1</td></tr><tr><td>Flags affected:</td><td>S Z</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Shift p1 left -> shift p1 register to the left, fill LSB with 0, MSB is placed in carry register</td></tr><tr><td>Category:</td><td>Shift and rotate</td></tr></table>

<table><tr><td>shiftR</td><td>Shift Right</td></tr><tr><td>Syntax:</td><td>shiftR p1</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b]</td></tr><tr><td>Calculus:</td><td>p1: p1>> 1</td></tr><tr><td>Flags affected:</td><td>S Z</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Signed shift right of p1 -> shift p1 right, MSB is duplicated according to whether the number is positive or negative</td></tr><tr><td>Category:</td><td>Shift and rotate</td></tr></table>

<table><tr><td>sign</td><td>Sign</td></tr><tr><td>Syntax:</td><td>sign p1</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b]</td></tr><tr><td>Calculus:</td><td>If \( \mathrm{{SF}} = 0 =  > \mathrm{p}1 : \left| {\mathrm{p}1}\right| ,\mathrm{{SF}} : \mathrm{S}\left( {\mathrm{p}1}\right) \) If \( \mathrm{{SF}} = 1 =  > \mathrm{p}1 :  - \left| {\mathrm{p}1}\right| ,\mathrm{{SF}} : \mathrm{S}\left( {\mathrm{p}1}\right) \)</td></tr><tr><td>Flags affected:</td><td>SZSF</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>The intention of this opcode is to take the absolute value of one parameter before multiplication or division and to restore the sign after this operation. Assuming the Signum flag is zero, the absolute value of accumulator is taken and the sign from accumulator is stored to SF. At the second time this opcode is used the sign to p1 will be restored from SF Zero is assumed to be positive.</td></tr><tr><td>Category:</td><td>Simple arithmetic</td></tr></table>

<table><tr><td>stop</td><td>Stop</td></tr><tr><td>Syntax:</td><td>stop</td></tr><tr><td>Parameters:</td><td>-</td></tr><tr><td>Calculus:</td><td>-</td></tr><tr><td>Flags affected:</td><td>-</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Stop of the PCAP-Controller. The clock generator is stopped, the PCAP-Controller go to standby. A restart can be achieved by an external event like 'watchdog timer', 'external switch'or'new capacitive measurement results'. Usually this opcode is the last command in the assembler listing.</td></tr><tr><td>Category:</td><td>Miscellaneous</td></tr></table>

<table><tr><td>sub</td><td>Subtraction</td></tr><tr><td>Syntax:</td><td>sub p1, p2</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b, r] p2 = ACCU [a, b, r] p1 != p2</td></tr><tr><td>Calculus:</td><td>p1: p1 – p2</td></tr><tr><td>Flags affected:</td><td>COSZ</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Subtraction of 2 registers. The following instructions are not allowed: sub a, a. sub b, b. sub r, r</td></tr><tr><td>Category:</td><td>Simple arithmetic</td></tr></table>

<table><tr><td>xor</td><td>Bitwise XOR</td></tr><tr><td>Syntax:</td><td>xor p1, p2</td></tr><tr><td>Parameters:</td><td>p1 = ACCU [a, b, r] p2 = ACCU [a, b, r] p1 != p2</td></tr><tr><td>Calculus:</td><td>p1 : p1 ^ p2</td></tr><tr><td>Flags affected:</td><td>COSZ</td></tr><tr><td>Bytes:</td><td>1</td></tr><tr><td>Description:</td><td>Bitwise XOR (antivalence)</td></tr><tr><td>Category:</td><td>Bitwise operation</td></tr></table>

## Instruction Details

## Pointer

; Copying the Cratio results to the persistent bank in RAM

load b, 6

load a, _____sub_cdc_C0_Ratio_temp

rad DPTR1

mover, a

load a, C0_Ratio_RAM

rad DPTRO

mover, a

jsb _ ROM_dma_

rad_at_DPTR0 to rad_at_DPTR3 are special instructions for indirect addressing._at_DPTR0 to_at_DPTR3 are special RAM addresses 284 and 287 that have been defined in the firmware. RAM addresses 105 to 108 are used as data pointers, named DPTR0 to DTPTR3.

By means of

CROLD

move r, a

an address is loaded into DPTRO. With

rad _____at_DPTRO

the address in DPTR0 is loaded.

Example 1: copy sequentially RAM-content from one address-space to another

Load a, C0_ratio

rad DPTR1

move r, a

load a, RESO

rad DPTRO

move r, a

load b, 8

jsb _____ROM_dma_____；call ROM routine

---

Example 2: Copying the Rratio results to the persistent bank into RAM

	rad 4

				rad rad_stack_6b

				move b, r

				load a, _____sub_rdc_R0_Ratio_temp; Source for copy

	rad DPTR1

	mover, a

	rad R0_Ratio_RAM ; Destination for copy

				rad rad_stack_6b

				move a, r

	rad DPTRO

	mover, a

	jsb _ROM_dma_

---

## Transfer Constants with Push and Pop

Call of a subroutine:

---

	push FPP_CRATIO ; Stack - 1 ---- Number of fpp in the result

	push C_REF_PORT_NUMBER; Stack - 0 ----> Reference Port Number

jsb _ROM_cdc_ ; Calling ROM routine for Ratio calculation

	_ROM_cdc__:

bitS PAGESEL_OUT

	rad rad_stack_6b; (Stack - 0) contains Reference Port Number

	move b, r

pop

rad _____sub_cdc_RefPort

	move r, b ; Temporarily saving the Reference Port Number in RAM

pop

pop

rad rad_stack_6b ; (Stack - 1) contains number of fractional digits in the

result (cdc_fpp)

	move b, \( r\;;B = \) The number of fractional digits, Result_fpp

---

mult The instruction "mult" is just a single multiplication step. To do a complete 32-bit multiplication this instruction has to be done 32 times. The multiplicands are in accumulators b and r. Every step takes the lowest bit of b. If it is one, \( r \) is added to accumulator a, else nothing is added. Thereafter a and b are shifted right. The lowest bit of a becomes the highest bit of b. Before the first step of the multiplication, a has to be cleared. The final result is spread over both accumulators a and b. The use of mult is simplified by using the ROM routines mult_ 01 to mult_32.

In many cases it will not be necessary to do the full 32 multiplication steps but much fewer. The necessary number of steps is given by the number of significant bits of b and also the necessary significant number of bits of the result.

But, if the multiplication steps are less than 32 , the result might be spread between accumulators a and b. Doing an appropriate right shift of the multiplicand in \( r \) , and the appropriate number of multiplication steps, it is possible to ensure that the result is either fully in a or in b.

Handover of Constants by Push & Pop

A simple method to hand over constants with a value 0 to 63 is using push & pop instructions. The following shows an example for calling a subroutine.

---

Subroutine call:

push FPP_CRATIO; Stack - 1 -> Number of fpp in the result

push C_REF_PORT_NUMBER; Stack - 0 -> Reference Port Number

jsb _ROM_cdc_; Calling ROM routine for Ratio calculation

_ROM_cdc_:

rad rad_stack_6b; (Stack - 0) contains Reference Port Number

move

pop

	_____sub_cdc_RefPort

move r, b; Temporarily saving the Reference Port Number in RAM

pop

pop

rad rad_stack_6b;(Stack - 1) contains number of fractional digits in the result (cdc_fpp)

move b, r; \( B = \) The number of fractional digits, Result_fpp

---

div

The instruction "div" is, like the multiplication, just a single step of a complete division. The necessary number of steps for a complete division depends on the accuracy of the result. The dividend is in accumulator a, the divisor is in accumulator \( r \) . Every division step contains following actions:

- leftshift b

- compare a and \( r \) . If a is bigger or equal to \( r \) then \( r \) is subtracted from a and One is added to b

- leftshift a

Start Conditions: \( 0 < \mathrm{a} < 2 * \mathrm{r},\mathrm{\;b} = 0 \)

Again, multiple division steps are implemented in ROM library to be easily used by customers, calling div_01 to div_32. A call of function e.g. div_24 out of this library will do a sequence of 24 division steps. The result is found in b, the remainder in a.

With \( \mathrm{N} \) division steps the result in \( \mathrm{b} : \left( {\mathrm{a}/\mathrm{r}}\right)  + {2}^{\left( {\mathrm{N} - 1}\right) ,} \) a: remainder*2 N.

Example 1: \( \mathrm{a} = 2,\mathrm{r} = 6 \) , Integer division

Figure 129:

Example: Division 2/6

<table><tr><td>Steps</td><td>a = 2</td><td>\( \mathbf{b} \)</td><td>r = 6</td><td/></tr><tr><td/><td>000000..000010</td><td>0.00000</td><td>0.0110</td><td>a < r, leftshift b, a</td></tr><tr><td>1</td><td>000000..000100</td><td>0.00000</td><td>0.0110</td><td>a < r, leftshift b, a</td></tr><tr><td>2</td><td>000000..001000</td><td>0.00000</td><td>0.0110</td><td>leftshift b, a >= r: a-=r, b+=1, leftshift a</td></tr><tr><td>3</td><td>000000..000100</td><td>0.00001</td><td>0.0110</td><td>a < r, leftshift b, a</td></tr><tr><td>4</td><td>000000..001000</td><td>0.00010</td><td>0.0110</td><td>leftshift b, a >= r: a-=r, b+=1, leftshift a</td></tr><tr><td>5</td><td>000000..000100</td><td>0.00101</td><td>0.0110</td><td/></tr></table>

Quotient \( = b * {2}^{\left( 1 - \text{steps }\right) } = {0.3125} \) , Remainder \( = a * {2}^{\left( -\text{steps }\right) } = 4 * {2}^{-5} \) \( = {0.125} \)

The following two, more complex examples show a nice advantage of division over multiplication: The resolution in bit is directly given by the number of division steps. With this knowledge, assembly programs can be written very effectively. It is easy to use only the number of division steps that is necessary.

Example 2: \( A = {8.75}, R = {7.1875} \) , Fractional number division, A &R with 4 fractional digits each.

\( {8.75}/{7.1875} = {a}^{ * }{2}^{\exp A}/{r}^{ * }{2}^{\exp R} = {a}^{ * }{2}^{-4}/{r}^{ * }{2}^{-4} \)

Figure 130:

Example: Division 8.75/7.1875

<table><tr><td>Steps</td><td>a = 140</td><td>b</td><td>r = 115</td><td/></tr><tr><td/><td>1000 1100</td><td>0000 0000</td><td>01110011</td><td>leftshift b, a >= r: a-=r, b+=1, leftshift a</td></tr><tr><td>1</td><td>0011 0010</td><td>0000 0001</td><td>0111 0011</td><td>a < r, leftshift b, a</td></tr><tr><td>2</td><td>0110 0100</td><td>0000 0010</td><td>0111 0011</td><td>a < r, leftshift b, a</td></tr><tr><td>3</td><td>1100 1000</td><td>0000 0100</td><td>0111 0011</td><td>leftshift b, a >= r: a-=r, b+=1, leftshift a</td></tr><tr><td>4</td><td>1010 1010</td><td>0000 1001</td><td>0111 0011</td><td>leftshift b, a >= r: a-=r, b+=1, leftshift a</td></tr><tr><td>5</td><td>0110 1110</td><td>0001 0011</td><td>0111 0011</td><td>a < r, leftshift b, a</td></tr><tr><td>6</td><td>1101 1100</td><td>0010 0110</td><td>0111 0011</td><td>leftshift b, a >= r: a-=r, b+=1, leftshift a</td></tr><tr><td>7</td><td>11010010</td><td>0100 1101</td><td>0111 0011</td><td>leftshift b, a >= r: a-=r, b+=1, leftshift a</td></tr><tr><td>8</td><td>1011 1110</td><td>1001 1011</td><td>01110011</td><td/></tr></table>

Quotient \( = b * {2}^{\left( 1 + \exp A - \exp R - \text{steps}\right) } = {155} * {2}^{\left( 1 - 4 + 4 - 8\right) } = {1.2109} \)

Remainder \( = {a}^{ * }{2}^{\left( \text{-steps-expR }\right) } = {190}^{ * }{2}^{-{12}} = {0.0463} \)

Example 3: \( A = {20}, R = {1.2} \) , Fractional number division, \( R < A \) .

A and \( R \) are shifted to left to display the fractional digits of \( R \) . Further, \( R \) has to be shifted to the left till it is bigger than \( A/2 \) .

\[
{20}/{1.2} = {a}^{ * }{2}^{\exp A}/{r}^{ * }{2}^{\exp R} = {a}^{ * }{2}^{-4}/{r}^{ * }{2}^{-8}
\]

Figure 131:

Example 3: DIvision 20/1.2

<table><tr><td>Steps</td><td>a = 320</td><td>\( \mathbf{b} \)</td><td>r = 307</td><td/></tr><tr><td/><td>0001 0100 0000</td><td>0000 0000 0000</td><td>0001 0011 0011</td><td>leftshift b, a >= r: a-=r, b+=1, leftshift a</td></tr><tr><td>1</td><td>0000 0001 1010</td><td>0000 0000 0001</td><td>0001 0011 0011</td><td>a < r, leftshift b, a</td></tr><tr><td>2</td><td>0000 0011 0100</td><td>0000 0000 0010</td><td>0001 0011 0011</td><td>a < r, leftshift b, a</td></tr><tr><td>3</td><td>0000 0110 1000</td><td>0000 0000 0100</td><td>0001 0011 0011</td><td>a < r, leftshift b, a</td></tr><tr><td>4</td><td>0000 1101 0000</td><td>0000 0000 1000</td><td>0001 0011 0011</td><td>a < r, leftshift b, a</td></tr><tr><td>5</td><td>0001 1010 0000</td><td>0000 0001 0000</td><td>0001 0011 0011</td><td>leftshift b, a >= r: a-=r, b+=1, leftshift a</td></tr><tr><td>6</td><td>0000 1101 1010</td><td>0000 0010 0001</td><td>0001 0011 0011</td><td>a < r, leftshift b, a</td></tr><tr><td>7</td><td>0001 1011 0100</td><td>0000 0100 0010</td><td>0001 0011 0011</td><td>leftshift b, a >= r: a-=r, b+=1, leftshift a</td></tr><tr><td>8</td><td>0001 0000 0010</td><td>0000 1000 0101</td><td>0001 0011 0011</td><td>a < r, leftshift b, a</td></tr><tr><td>9</td><td>0010 0000 0100</td><td>0001 0000 1010</td><td>0001 0011 0011</td><td>leftshift b, a >= r: a-=r, b+=1, leftshift a</td></tr><tr><td>10</td><td>0001 1010 0010</td><td>0010 0001 0101</td><td>0001 0011 0011</td><td>leftshift b, a >= r: a-=r, b+=1, leftshift a</td></tr><tr><td>11</td><td>0000 1101 1110</td><td>0100 0010 1011</td><td>0001 0011 0011</td><td>a < r, leftshift b, a</td></tr><tr><td>12</td><td>0001 1011 1100</td><td>1000 0101 0110</td><td>0001 0011 0011</td><td/></tr></table>

## amm

Quotient \( = b * {2}^{\left( 1 + \exp A - \exp R - \text{steps}\right) } = {2134} * {2}^{\left( 1 - 4 + 8 - {12}\right) } = {16.6719} \) The remainder is, as always, smaller than the denominator divided by 2steps e.g. in the present case, remainder \( < {1.2}/{2}^{12} \) \( = 0,{0003} \)

Steps \( = 1 + \exp A - \exp B - \exp \operatorname{Res} \)

## ROM Routines

The following routines are implemented as ROM code:

Figure 132:

ROM Routines

<table><tr><td>ROM Routine</td><td>Address</td><td/><td>ROM Routine</td><td>Address</td></tr><tr><td>_ROM_Version_____</td><td>1024</td><td/><td>_ROM_median_____</td><td>1804</td></tr><tr><td>_ROM_tdc_dispatch__</td><td>1029</td><td/><td>_ROM_rdc_</td><td>1936</td></tr><tr><td>_ROM_cdc_cycle_</td><td>1047</td><td/><td>_ROM_rdc_inverse_</td><td>1962</td></tr><tr><td>_ROM_rdc_cycle_</td><td>1068</td><td/><td>_ROM_cdc_</td><td>2021</td></tr><tr><td>_ROM_cdc_initialize_</td><td>1086</td><td/><td/><td/></tr><tr><td>_ROM_rdc_initialize__</td><td>1111</td><td/><td/><td/></tr><tr><td>shiftR_B_32 to _00</td><td>1140</td><td/><td/><td/></tr><tr><td>shiftL_B_32 to _00</td><td>1173</td><td/><td/><td/></tr><tr><td>shiftR_A_32 to _00</td><td>1206</td><td/><td>_ROM_memory_rd_a_32b_ to _ROM_memory_wr_08b_</td><td>2470</td></tr><tr><td>shiftL_A_32 to _00</td><td>1239</td><td/><td>_ROM_memory_store_</td><td>2650</td></tr><tr><td>mult_32 to _00</td><td>1272</td><td/><td>_ROM_memory_recall__</td><td>2673</td></tr><tr><td>div_33 to _00</td><td>1305</td><td/><td>_ROM_2PT_Calibration</td><td>2696</td></tr><tr><td>_ROM_div_variable_</td><td>1339</td><td/><td>_ROM_polynomial_3rd_degree</td><td>2825</td></tr><tr><td>_ROM_mult_variable_</td><td>1396</td><td/><td>__sub_polynomial_load_coeffs</td><td>2874</td></tr><tr><td>_ROM_shift_a_variable_</td><td>1452</td><td/><td>_ROM_polynomial_4th_degree</td><td>2923</td></tr><tr><td>_ROM_shift_b_variable_</td><td>1478</td><td/><td>_ROM_pulse_</td><td>2969</td></tr><tr><td>_ROM_dma_</td><td>1504</td><td/><td>_ROM_pulse_loaded_cal_vals</td><td>2990</td></tr><tr><td>_ROM_In__</td><td>1520</td><td/><td>_ROM_NVblock_copy_32b_ to _ROM_NVblock_copy_08b_</td><td>3138</td></tr><tr><td>_ROM_log10_____</td><td>1547</td><td/><td>_ROM_capacitance_polynomial</td><td>3236</td></tr><tr><td>_ROM_ld_____</td><td>1574</td><td/><td>_ROM_capacitance_polynomial_4d</td><td>3437</td></tr><tr><td>_ROM_signed24_to_signed32_</td><td>1648</td><td/><td/><td/></tr></table>

Handover parameters and RAM addresses for ROM routines

Figure 133:

Parameters and RAM for Key ROM Routines

<table><tr><td>ROM Routine</td><td>Parameter</td><td>RAM Address</td></tr><tr><td>_ROM_cdc_</td><td>_sub_cdc_C0_Ratio_temp to _sub_cdc_C5_Ratio_temp</td><td>58 .. 63</td></tr><tr><td>ROM_rdc_____ _ROM_rdc_inverse_</td><td>_sub_rdc_R0_Ratio_temp to _sub_rdc_R3_Ratio_temp</td><td>64. 67</td></tr><tr><td>_ROM_mult_variable_</td><td>__sub_standard_multiplier_</td><td>82</td></tr><tr><td>_ROM_div_variable_</td><td>_____sub_standard_divisor_</td><td>82</td></tr></table>

In the following we give a detailed description of the ROM

routines.

Hint: it is recommended to always include the following files:

#device PCap04v1

#include <pcap_standard.h>

#include <PCap04_ROM_addresses_standard.h>

to declare addresses to ROM routines.

_ROM_Version__

<table><tr><td>Function:</td><td>This routine gives back the 8-bit version number of the ROM in the chip</td></tr><tr><td>Input parameters:</td><td>-</td></tr><tr><td>Output/Return value:</td><td>A-ACCU: ROM version</td></tr><tr><td>Prerequisites</td><td>None</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>jsb _ROM_version__; address 0x400</td></tr><tr><td>Temporary memory usage</td><td>-</td></tr><tr><td>Example:</td><td>jsb _ROM_Version_____ rad RES5 mover, a</td></tr></table>

_ROM_tdc_dispatch__

<table><tr><td>Function:</td><td>TDC library, to be called at the very beginning. Calls subroutines _ROM_cdc_ cycle_or_ROM_rdc-cylcle_ and _tdc_awake_, depending on the trigger</td></tr><tr><td>Input parameters:</td><td>-</td></tr><tr><td>Output/Return value:</td><td>-</td></tr><tr><td>Prerequisites</td><td>None</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>jsb _ROM_tdc_dispatch_</td></tr><tr><td>Temporary memory usage</td><td>-</td></tr><tr><td>Example:</td><td>org 0 _____SOP__: ; Start of program jsb _ROM_tdc_dispatch__</td></tr></table>

_ROM_cdc_cycle_

<table><tr><td>Function:</td><td>1. Calculates the Start-Stop difference in the TDC values of the capacitance measurement ports and accumulates this in the measurement value RAM register (depending on the C_ADD_PTR) respective to the port being measured. 2. If the calculated discharge time is too large, then the result is replaced with 0xFFFFFFFF thus indicating overflow. 3. The DSP stops if there are more measurements to be done. In case of a last measurement, the DSP returns to where the ROM routine was called from continues to execute the post processing firmware, if any.</td></tr><tr><td>Input parameters:</td><td>-</td></tr><tr><td>Output/Return value:</td><td>The CDC discharge time measurement value is available in the respective RAM (88 - 95)</td></tr><tr><td>Prerequisites</td><td>This function has to be called after a measurement cycle at every capacitive port.</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>push <MSB(RAM_startaddress)> push <LSB(RAM startaddress)> jsb _ROM_cdc_cycle_</td></tr><tr><td>Temporary memory usage</td><td>DPTR0 is overwritten in this routine.</td></tr><tr><td>Example:</td><td>push 1 ; bit6 of starting address push M0 ; bit 5..0 of starting address jsb _ROM_cdc_cycle (not recommended, use _ROM_tdc_dispatch__ instead)</td></tr></table>

_ROM_Rdc_cycle__

<table><tr><td>Function:</td><td>1. Calculates the Start-Stop difference in the TDC values of the temperature measurement ports and accumulates this in the measurement value RAM register (depending on the R_ADD_PTR) respective to the port being measured. 2. If the calculated discharge time is too large, then the result is replaced with 0xFFFFFFFF thus indicating overflow. 3. If the end of an RDC measurement triggered the DSP, then this ROM routine call will stop the DSP after doing the above tasks. Else, the DSP returns to where the ROM routine was called and continues to execute the firmware.</td></tr><tr><td>Input parameters:</td><td>-</td></tr><tr><td>Output/Return value:</td><td>The RDC discharge time measurement value is available in the respective RAM (84 - 87)</td></tr><tr><td>Prerequisites</td><td>This function has to be called after a measurement cycle at every resistive port.</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>push <MSB(RAM_startaddress)> push <LSB(RAM startaddress)> jsb _ROM_rdc_cycle_</td></tr><tr><td>Temporary memory usage</td><td>DPTR0 is overwritten in this routine.</td></tr><tr><td>Example:</td><td>push 1 ; bit6 of starting address push TM0; bit 5..0 of starting address jsb _ROM_rdc_cycle (not recommended, use _ROM_tdc_dispatch__ instead)</td></tr></table>

_ROM_cdc_initialize__

<table><tr><td>Function:</td><td>This ROM routine clears all the measurement value RAM registers, Addresses 88-95 to 0 .</td></tr><tr><td>Input parameters:</td><td>The starting address of the RAM registers (88) which are to be cleared, is to be pushed into the RAM address stack before calling this subroutine.</td></tr><tr><td>Output/Return value:</td><td>-</td></tr><tr><td>Prerequisites</td><td>-</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>push <MSB(RAM_startaddress)> push <LSB(RAM startaddress)> jsb _ROM_cdc_initialize_</td></tr><tr><td>Temporary memory usage</td><td>The addresses DPTR0 and _at_DPTR0 are overwritten in this ROM routine.</td></tr><tr><td>Example:</td><td>push 1 ; bit6 of starting address push M0 ; bit 5..0 of starting address jsb _ROM_cdc_initialize</td></tr></table>

_ROM_rdc_initialize__

<table><tr><td>Function:</td><td>This ROM routine clears all the measurement value RAM registers, Addresses 84-87 to 0 .</td></tr><tr><td>Input parameters:</td><td>The starting address of the RAM registers (84) which are to be cleared, is to be pushed into the RAM address stack before calling this subroutine.</td></tr><tr><td>Output/Return value:</td><td>-</td></tr><tr><td>Prerequisites</td><td>None</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>push <MSB(RAM_startaddress)> push <LSB(RAM startaddress)> jsb _ROM_rdc_initialize_</td></tr><tr><td>Temporary memory usage</td><td>The addresses DPTR0 and _at_DPTR0 are overwritten in this ROM routine.</td></tr><tr><td>Example:</td><td>push 1 ; bit6 of starting address push TM0; bit 5..0 of starting address jsb _ROM_rdc_initialize</td></tr></table>

shiftL_A_xx; shiftR_A_xx; shiftL_B_xx; shiftR_B_xx

<table><tr><td>Function: jsb shiftL_B_01 jsb shiftR_B_01 ...... jsb shiftL_B_32jsb shiftR_B_32</td><td>Function to call a fixed number xx of shift steps of the A-Accu or B-Accu to the left or right</td></tr><tr><td>Input parameters:</td><td>A-ACCU or B-ACCU: Value to shift xx times</td></tr><tr><td>Output/Return value:</td><td>shiftL_A_01 A: A * 2 ^ (1) shiftL_A_02 A: A * 2 ^ (2) shiftL_A_03 A: A * 2 ^ ( 3 ) shiftL_A_31A: A * 2 ^ ( 31 )</td></tr><tr><td>Prerequisites</td><td>None</td></tr><tr><td>Dependency on other header files Function call</td><td>None jsb shiftL_A_01 jsb shiftR_A_01 ...... jsb shiftL_A_32jsb shiftR_A_32</td></tr><tr><td>Temporary memory usage</td><td/></tr><tr><td>Example:</td><td>load b, dp_const_m jsb shiftL_B_08</td></tr></table>

mult_xx

<table><tr><td>Function:</td><td>Function to call a variable no of multiplication steps</td></tr><tr><td>Input parameters:</td><td>B-Accu : Multiplier 1 R-Accu: Multiplier 2</td></tr><tr><td>Output/Return value:</td><td>A-ACCU: Result of multiplication</td></tr><tr><td>Prerequisites</td><td>A-Accu : 0 B \( >  = 0 \) R >= 0</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>jsb mult_01 .. jsb mult_32</td></tr><tr><td>Temporary memory usage</td><td/></tr><tr><td>Example:</td><td>sign b ; Store sign of multiplier b; take absolute value from b clear rad __sub_standard_multiplier_ jsb mult_15 ; a2 * theta in A-Akku signa ;Restoring sign of the multiplier to the result</td></tr></table>

div_xx

<table><tr><td>Function:</td><td>div_00 to div_33: Function to call a fixed no of division steps</td></tr><tr><td>Input parameters:</td><td>A-Accu : Dividend r: Divisor</td></tr><tr><td>Output/Return value:</td><td>B-Accu: Dividend / divisor</td></tr><tr><td>Prerequisites</td><td>B-Accu : 0 \( 0{ < }^{\prime }{\mathrm{a}}^{\prime } < 2{ * }^{\prime }{\mathrm{r}}^{\prime } \) respectively result b needs to be \( 0 < \mathrm{b} < 2 \)</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>jsb div_xx</td></tr><tr><td>Temporary memory usage</td><td/></tr><tr><td>Example:</td><td>rad M_internal_ref move b, r shiftL b shiftL b ; b : b + 4, to make sure dividend > 2*a rad 0 move r, b rad M0 move a, r ; a = M0 clear b rad 0 ; r = M_internal_ref jsbdiv_29; b = a/r = M0/M_internal_ref</td></tr></table>

_ROM_div_variable__

<table><tr><td>Function:</td><td>Function to call a variable no of division steps</td></tr><tr><td>Input parameters:</td><td>B-Accu : No of division steps A-Accu : Dividend arguments - 0 : Divisor (RAM-address 82)</td></tr><tr><td>Output/Return value:</td><td>B-Accu : Dividend / divisor</td></tr><tr><td>Prerequisites</td><td>\( 0{ < }^{\prime }{\mathrm{a}}^{\prime } < 2{ * }^{\prime }{\mathrm{r}}^{\prime } \) respectively result b needs to be \( 0 < \mathrm{b} < 2 \)</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>jsb _ROM_div_variable_</td></tr><tr><td>Temporary memory usage</td><td/></tr><tr><td>Example:</td><td>load a, 3 ; divisor = 3 rad _arguments__; hand over via ramaddress 82 move r, a load a, 4 ; dividend = 4 load b, 23; 23 division steps jsb _ROM_div_variable__; rad RESOO mover, b ; B : 0x555555 _____; B : 4/3 = 1.333333 (fpp22)</td></tr></table>

_ROM_mult_variable__

<table><tr><td>Function:</td><td>Function to call a variable no of multiplication steps</td></tr><tr><td>Input parameters:</td><td>B-Accu : Multiplier 1 A-ACCU : Number of multiplication steps arguments - 0 : Multiplier 2 (RAM-address 82)</td></tr><tr><td>Output/Return value:</td><td>-Accu : Result of multiplication</td></tr><tr><td>Prerequisites</td><td>Multiplier 1 > 0 Multiplier 2 > 0</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>jsb _ROM_mult_variable_</td></tr><tr><td>Temporary memory usage</td><td/></tr><tr><td>Example:</td><td>load b, 3 ; multiplier 1 = 3 rad _arguments__; hand over via ramaddress 82 mover, b load b, 4 ; multiplier 2 = 4 load a, 32; 32 muliplication steps jsb _ROM_mult_variable__; rad RESOO move r, b ; B : 12_____; B : 4*3 = 12 (fpp22)</td></tr></table>

_ROM_shift_a_variable__

<table><tr><td>Function:</td><td colspan="2">Function to call a variable no of shift A-Accu steps</td></tr><tr><td>Input parameters:</td><td colspan="2">A-ACCU :Value to shift B-Accu : Number of shift steps B > 0 : Left shift B < 0 : Right shift</td></tr><tr><td>Output/Return value:</td><td colspan="2">A: A * 2 ^ (B)</td></tr><tr><td>Prerequisites</td><td colspan="2">None</td></tr><tr><td>Dependency on other header files</td><td colspan="2">None</td></tr><tr><td>Function call</td><td colspan="2">jsb _ROM_shift_a_variable_</td></tr><tr><td colspan="3">Temporary memory usage</td></tr><tr><td>Example:</td><td>rad MyVar move a, r load b, -4 jsb _ROM_shift_a_variable_ rad RESOO move r, a</td><td>; a : MyVar; ; set up 4fold right shift</td></tr></table>

_ROM_shift_b_variable__

<table><tr><td>Function:</td><td>Function to call a variable no of shift B-Accu steps</td><td/></tr><tr><td>Input parameters:</td><td>B-Accu :Value to shift A-ACCU : Number of shift steps A > 0 : Left shift A < 0 : Right shift</td><td/></tr><tr><td>Output/Return value:</td><td colspan="2">\( B : B * 2 \land  \left( A\right) \)</td></tr><tr><td>Prerequisites</td><td colspan="2">None</td></tr><tr><td>Dependency on other header files</td><td colspan="2">None</td></tr><tr><td>Function call</td><td colspan="2">jsb_ROM_shift_b_variable_</td></tr><tr><td>Temporary memory usage</td><td colspan="2"/></tr><tr><td>Example:</td><td colspan="2">rad MyVar ; b : MyVar; move b, r load a, 13 ; set up 13fold left shift jsb _ROM_shift_b_variable_ rad RESOO move r, b</td></tr></table>

_ROM_dma__

<table><tr><td>Function:</td><td>"Direct Memory Access" - This routine copies sequential RAM-content from one address-space to another. The number of RAM values to be copied can be specified.</td></tr><tr><td>Input parameters:</td><td>B-Accu :Number of values to be copied DPTR1 :Source RAM block address DPTRO:Destination RAM block address</td></tr><tr><td>Output/Return value:</td><td>The contents, i.e. the specified number of values are copied from the source RAM block to the destination RAM block.</td></tr><tr><td>Prerequisites</td><td>-</td></tr><tr><td>Function call</td><td>jsb __ROM_dma__</td></tr><tr><td>Temporary memory usage</td><td>-</td></tr><tr><td>RAM permanently changed?</td><td>Yes, the destination RAM block</td></tr><tr><td>Example</td><td>; Copying the Cratio results to the persistent bank ; in RAM (cells__sub_cdc_C0_Ratio_tempto_sub_cdc_C0_Ratio_temp+5 into cels C0_Ratio_RAM to C0_Ratio_RAM + 5) load b, 6 load a, __sub_cdc_C0_Ratio_temp rad DPTR1 mover, a load a, C0_Ratio_RAM rad DPTRO mover, a jsb _ROM_dma_</td></tr></table>

_ROM_In__, _ROM_log10__, _ROM_Id__

<table><tr><td>Function:</td><td>Calculation of logarithm log10 (logarithm to base 10) In (logarithm naturalis) Id (logarithm dualis, to base 2) AccuA = Id( AccuA ) for all logarithms, first ld(x) is determined. For log10 and In afterwards the return value is divided by \( \operatorname{ld}\left( {e\left( 1\right) }\right) \) or \( \operatorname{ld}\left( {10}\right) \) formula for \( \operatorname{ld}\left( x\right) \) of http://de.wikipedia.org/wiki/Logarithmus#Nat.C3.BCrlicher_Logarithmus</td></tr><tr><td>Input parameters:</td><td>A-Accu : Containing parameter for logarithm dualis with \( {10}\mathrm{{fpp}} \)</td></tr><tr><td>Output/Return value:</td><td>A-Accu : Signed 16bit Value</td></tr><tr><td>Prerequisites</td><td/></tr><tr><td>Function call</td><td>jsb _ROM_Id_ jsb __ROM_In__ jsb __ROM_log10__</td></tr><tr><td>Temporary memory usage</td><td>_____temporary_variables_ - 3 to _temporary_variables_</td></tr><tr><td>RAM permanently changed?</td><td/></tr><tr><td>Example</td><td>load a, 0xA01; A: 2.500977 (=2561*2^-10) jsb __ROM_Id__ rad RESOO move r, a; A: 1.322492 (0x1528E*2^-16)</td></tr></table>

_ROM_signed24_to_signed32__

<table><tr><td>Function:</td><td>Type cast from 24bit signed to 32bit signed. This function is to cast a 24bit signed value e to a 32 bit signed value.</td></tr><tr><td>Input parameters:</td><td>Accu B : Signed 24 bit value</td></tr><tr><td>Output/Return value:</td><td>Accu B : Signed 32bit value</td></tr><tr><td>Prerequisites</td><td>None</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>_ROM_signed24_to_signed32_</td></tr><tr><td>Temporary memory usage</td><td>1</td></tr><tr><td>Example:</td><td>jsb _ROM_signed24_to_signed32_____</td></tr></table>

_ROM_median__

<table><tr><td>Function:</td><td>Median-filter: this is a quasi-median-filter. The depth of filter is defined by arguments via stack. Each new Value (X) will be compared with the current median value. Is the new value smaller or equal to the median value the last value at the list will be replaced by X. Otherwise the first value at the list wi be replaced by X. Afterwards the complete list is sorted. The value at the very middle of the list is returned as new median.</td></tr><tr><td>Input parameters:</td><td>B-Accu : Filter input (and output) Stack - 2 : Start address of filter memory Stack - 1 : Middle section of filter memory Stack - 0 : Last address of filter memory The filter order is defined by last address - start address. The necessary memory section has to be reserved for and must not be used otherwise</td></tr><tr><td>Output/Return value:</td><td>B-Accu: Filter output (and input)</td></tr><tr><td>Prerequisites</td><td>None</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>jsb _ROM_median__</td></tr><tr><td>Temporary memory usage</td><td>_____temporary_variables_ - 4 to _____temporary_variables_ FILTER_START to FILTER_STOP</td></tr><tr><td>Example:</td><td>CONST FILTER_ORDER 5 CONST FILTER_START 12 CONST FILTER_MIDDLE 12 + (FILTER_ORDER/2) CONST FILTER_STOP 12 + FILTER_ORER rad Filter_input_value move b, r push FILTER_START push FILTER_MIDDLE push FILTER_STOP jsb _ROM_median__</td></tr></table>

_ROM_cdc_

<table><tr><td>Function:</td><td>This routine contains the subroutine to determine the capacitor ratios (or inverse ratios); depending on the measurement scheme and compensation modes</td></tr><tr><td>Input parameters:</td><td>Stack 1 : CDC_FPP number of fractional digits in the result. Stack 0 : C_REF_PORT_NUMBER reference port number (0 to 6 for grounded, 0 to 2 for floating). A-ACCU :_sub_cdc_gain_corr_factor for gain correction, applied on Mi, 8fpp 0 0 : gain corr = 1 else 1+ (A-Accu) FLAG_CDC_INV (Bit 5) of FLAGREG: 0 : inverse capacitance ration, 1 : capacitance rations</td></tr><tr><td>Output/Return value:</td><td>The addresses _sub_cdc_C0_Ratio_temp to _sub_cdc_C5_Ratio_temp are updated with relevant capacitance ratios (or inverse ones)</td></tr><tr><td>Prerequisites</td><td/></tr><tr><td>Function call</td><td>jsb _ROM_cdc_</td></tr><tr><td>Temporary memory usage</td><td>Addresses 58 to 72</td></tr><tr><td>Example:</td><td>load2exp a, FLAG_CDC_INV ; Clearing FLAG_CDC_INV (Bit 5) of FLAGREG rad FLAGREG and r, a load a, 0x40 ; default gain_corr 1.25 rad 27 ; Stack - 1 --> Number of fpp in the result rad 0; Stack - 0 -> Ref. port number jsb _ROM_cdc_ ; Calling ROM routine for Ratio calculation rad __sub_cdc_C1_Ratio_temp move a, r; save Ratio from CDC</td></tr></table>

_ROM_rdc__; _ROM_rdc_inverse__

<table><tr><td>Function:</td><td>Subroutine to calculate the resistance ratios or inverse ratios for the temperature measurement ports TM0 -> Internal Reference Resistance Port; TM1 -> External Resistance Port, PT0 TM2 -> External Resistance Port, PT1 TM3 -> Internal Sensor Resistance Port</td></tr><tr><td>Input parameters:</td><td>Stack 0 : FPP_RRATIO fixed point position of result A-ACCU:REF_PORT_NUMBER reference, 0 = internal 1=external</td></tr><tr><td>Output/Return value:</td><td>_sub_rdc_R0_Ratio_temp TMO/Ref or Ref/TMO _sub_rdc_R1_Ratio_temp TM1/Ref or Ref/TM1 _sub_rdc_R2_Ratio_temp TM2/Ref or Ref/TM2 _sub_rdc_R3_Ratio_tempTM3/Ref or Ref/TM3</td></tr><tr><td>Prerequisites</td><td>None</td></tr><tr><td>Dependency on other header files</td><td>#include <memory.h></td></tr><tr><td>Function call</td><td>jsb _ROM_rdc_ jsb _ROM_rdc_inverse_</td></tr><tr><td>Temporary memory usage</td><td>_____temporary_variables_ - 8 to _temporary_variables_</td></tr><tr><td>Example:</td><td>load a, 0 ; Reference Port Number = 0 rad 25 ; Number of fpp in the result ; A-Akku: Reference Port Number (0 ... 3) ; Stack - 0: Value of fpp of result = _rdc_fpp_ jsb _ROM_rdc__; Determine RDC ratios _ROM_rdc_inverse__ ; To determine inverse-RDC ratios rad __sub_rdc_R1_Ratio_temp ; save ratio from RDC move a, r</td></tr></table>

_ROM_memory_ (read/write volatile memory)

<table><tr><td>Function:</td><td>Functions for memory NVRAM access read functions: * signed/unsinged, 8/16/24/32bit RAM into Accu A or B write functions: * 8/16/24/32 bit (write data from RAM cell mem_data) The address in RAM cell mem_add is automatically incremented with read/write operations.</td></tr><tr><td>Input parameters:</td><td>-</td></tr><tr><td>Output/Return value:</td><td>Accu-A or Accu-B contains the specified value from the NVRAM</td></tr><tr><td>Prerequisites</td><td>None</td></tr><tr><td>Dependency on other header files</td><td>#include <memory.h></td></tr><tr><td>Function call</td><td>jsb _ROM_memory_rd_a_32b_ jsb _ROM_memory_rd_a_u24b_; jsb _ROM_memory_rd_a_s24b_ jsb _ROM_memory_rd_a_u16b_; jsb _ROM_memory_rd_a_s16b_ jsb _ROM_memory_rd_a_u08b_; jsb _ROM_memory_rd_a_s08b_ jsb _ROM_memory_rd_b_32b__ jsb _ROM_memory_rd_b_u24b__ ; ... _ROM_memory_wr_32b_;_ROM_memory_wr_24b_ _ROM_memory_wr_16b_;_ROM_memory_wr_08b_</td></tr><tr><td>Temporary memory usage</td><td/></tr></table>

<table><tr><td>Example:</td><td>Single read: load a, <read_mem_add> ; mem_add : <read_mem_add> rad mem_add move r, a jsb _ROM_memory_rd_a_u24b_ Single write: load a, MEM_WE ; enable memory writing ;(disable write protection) rad mem_ctrl move r, a load a, <write_address> ; mem_add : <write_mem_add> rad mem_add move r, a load a, <data to store> ; mem_data : <data to store> rad mem_data move r, a jsb _ROM_memory_wr_32b_ ; optional: set write protection load a, MEM_WR_PROTECT rad mem_ctrl move r, a Autoincrement: load a, 900 ; address (decimal) 900 rad mem_add move r, a load a, 0x012345; data : 0x012345 rad mem_data move r, a jsb _ROM_memory_wr_24b_ ; add 900: 0x45 ; add 901: 0x23 ; add 902: 0x01 ; mem_add after this operation : 903</td></tr></table>

_ROM_MEMORY_RECALL/STORE

<table><tr><td>Function:</td><td>Functions for nonvolatile memory access All nonvolatile accesses are secured by RAM cell mem_ctrl. If a store or a recall should be activated this has to be enabled by dedicated codes to mem_ctrl to prevent such actions by accident. Store: mem_ctrl : MEM_STORE (0x2d00) Recall: mem_ctrl : MEM_RECALL (0x5900)</td></tr><tr><td>Input parameters:</td><td/></tr><tr><td>Output/Return value:</td><td/></tr><tr><td>Prerequisites</td><td>None</td></tr><tr><td>Dependency on other header files</td><td><memory.h></td></tr><tr><td>Function call</td><td>jsb _ROM_memory_store__ jsb _ROM_memory_recall__</td></tr><tr><td>Temporary memory usage</td><td/></tr><tr><td>Example</td><td>Store: load a, MEM_STORE rad mem_ctrl move r, a jsb _ROM_memory_store__ Recall: load a, MEM_RECALL rad mem_ctrl move r, a jsb _ROM_memory_recall__</td></tr></table>

_ROM_2pt_calibration

<table><tr><td>Function:</td><td>This function performs a two point calibration with the given set of input values. The mathematical formula of the function is given below (calculation of xi): ( xi_at_ccp1 - xi_at_ccp2 ) xi = . (ci - ci_at_ccp1) + xi_at_ccp1 ( ci_at_ccp1 - ci_at_ccp2 ) The input values, i.e., xi_at_ccp1, xi_at_ccp2, ci_at_ccp1, ci_at_ccp2 are defined in the calibration data</td></tr><tr><td>Input parameters:</td><td>A-ACCU : |FPP_ci| - |FPP_ccp| FPP_ci : No. of fractional digits in the input capacitance ratio FPP_ccp : No. of fractional digits in the calibration value of capacitance ratio DPTRO ) : Start address of the RAM containing the constants in 4 consecutive addresses in the following order: xi_at_ccp1, xi_at_ccp2, ci_at_ccp1, ci_at_ccp2 Stack-0 : RAM address of Input Capacitance Ratio ci NOTE: It is a must that ALL the 4 calibration values have the same fpp !!!</td></tr><tr><td>Output/Return value:</td><td>A-Accu:xi with FPP_ccp fractional digits</td></tr><tr><td>Prerequisites</td><td>All the four calibration values must have the same fpp.</td></tr><tr><td>Function call</td><td>_ROM_2pt_calibration__</td></tr><tr><td>Temporary memory usage Example:</td><td>_____temporary_variables_ - 8 to _____temporary_variables_ oad a, FPP_difference; A Accu : (|FPP_ci| - |FPP_ccp|) rad xi_at_ccp1; Start address containing the list of ; calibration values move b, r rad DPTRO ; DPTRO now contains starting address ; of the calibration values r, b rad C1_ratio ; Inputs : ; A Accu : (FPP_ci - FPP_ccp) ; DPTRO : Start address of the Calibration values in RAM ; Stack-0 : RAM address of Input Capacitance Ratio ci ; Output : ; A Accu : xi with FPP_ccp fractional digits jsb _ROM_2PT_Calibration ad 2pt_result; Storing the returned value in RAM move r, a</td></tr></table>

_ROM_polynomial_3rd_degree

<table><tr><td>Function:</td><td>This function calculates the third degree polynomial for a given input value, with known coefficients. The mathematical formula of the function is given below: an \( = \left( {\left( {\mathrm{{cc}}{3\mathrm{n}}/\mathrm{{xi}} + \mathrm{{cc}}{2\mathrm{n}}}\right) /\mathrm{{xi}} + \mathrm{{cc}}{1\mathrm{n}}}\right) /\mathrm{{xi}} + \mathrm{{cc}}{0\mathrm{n}} \) where cc3n, cc2n, cc1n and cc0n are the coefficients of the third degree polynomial. xi is the given input value which can be a capacitance or resistance ratio for example. This can be used for capacitance and resistance polynomials of this form.</td></tr><tr><td>Input parameters:</td><td>DPTR0: start address of the memory containing the following : cc3n: 3rd degree coefficient cn_div3n: division steps for cc3n cc2n: 2nd degree coefficient cn_div2n: division steps for cc2n cc1n: 1st degree coefficient cn_div1n: division steps for cc1n ccOn: constant coefficient A-Accu: Input Capacitance or Resistance Ratio (or Inverse Ratio)</td></tr><tr><td>Output/Return value:</td><td>A-Accu: Result of the polynomial</td></tr><tr><td>Prerequisites</td><td>None</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>jsb _ROM_polynomial_3rd_degree</td></tr><tr><td>Temporary memory usage</td><td>_____temporary_variables_</td></tr><tr><td>Example:</td><td>The following example calculated temperature using the temperature polynomial rad Ratio_temp ; Resistance ratio ; A-Akku contains R_ratio load b, cc3n_address ; Start address containing the list ; of calibration values rad DPTRO ; DPTRO now contains starting address ; of the coefficient and steps list ; Input : DPTR0: start address of the list memory ; A-Akku: Input Capacitance or Resistance Ratio ; (or Inverse Ratio) jsb _ ROM_polynomial_3rd_degree; A = theta rad theta move r, a</td></tr></table>

_ROM_polynomial_4th_degree

<table><tr><td>Function:</td><td>This function calculates the third degree polynomial for a given input value, with known coefficients. The mathematical formula of the function is given below: an \( = \left( {\left( {\left( {\mathrm{{cc}}4\mathrm{n}/\mathrm{{xi}} + \mathrm{{cc}}3\mathrm{n}}\right) /\mathrm{{xi}} + \mathrm{{cc}}2\mathrm{n}}\right) /\mathrm{{xi}} + \mathrm{{cc}}1\mathrm{n}}\right) /\mathrm{{xi}} + \mathrm{{cc}}0\mathrm{n} \) where cc4n, cc3n , cc2n, cc1n and cc0n are the coefficients of the third degree polynomial. xi is the given input value which can be a capacitance or resistance ratio for example. This can be used for capacitance and resistance polynomials of this form.</td></tr><tr><td>Input parameters:</td><td>DPTR0: start address of the memory containing the following: cc4n: 4th degree coefficient cn_div4n: division steps for cc4n cc3n: 3rd degree coefficient cn_div3n: division steps for cc3n cc2n: 2nd degree coefficient cn_div2n: division steps for cc2n cc1n: 1st degree coefficient cn_div1n: division steps for cc1n cc0n: constant coefficient A-Accu: Input Capacitance or Resistance Ratio (or Inverse Ratio)</td></tr><tr><td>Output/Return value:</td><td>A-Accu: Result of the polynomial</td></tr><tr><td>Prerequisites</td><td>None</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>jsb _ROM_polynomial_4th_degree</td></tr><tr><td>Temporary memory usage</td><td>_____temporary_variables_-3 to _____temporary_variables_</td></tr><tr><td>Example:</td><td>The following example calculated temperature using the temperature polynomial rad Ratio_temp ; Resistance ratio ; A-Akku contains R_ratio load b, cc4n_address ; Start address containing the list ; of calibration values rad DPTRO ; DPTRO now contains starting address ; of the coefficient and steps list ; Input : DPTR0: start address of the list memory ; A-Akku: Input Capacitance or Resistance Ratio ; (or Inverse Ratio) b ROM_polynomial_4th_degree; A = theta rad theta move ríng</td></tr></table>

_ROM_pulse__

<table><tr><td>Function: Input parameters:</td><td>This function determines the pulse output, given two input co-ordinates (result_ 1, pulse_out_1) and (result_2, pulse_out_2) and the current result_n. The input coordinates are copied from the NVRAM, given the address and must fulfill the pre-requisite. The result_n, result_1 and result_2 can be the result from the capacitance measurement (like Humidity, Pressure etc) or the temperature measurement (theta). The "result_n" is converted into "Pulse_out" which can then be assigned to PULSE0 or PULSE1 output. The mathematical formula of the function is given below: Pulse_out = ( pulse_out_1 - pulse_out_2 ) * (result_n - result_1) + (pulse_out_1) ( result_1 - result_2 ) Additionally Pulse_out is limited to the range between pulse_out_min and pulse_out_max. The constants pulse_out_1, pulse_out_2, result_1, result_2, pulse_out_min and pulse_out_min are defined in the calibration memoryand have to be copied to the RAM before calling this function. !!! NOTE : result_n and result_1 must have the same format. A-Accu: Value of result_n B-Accu: 10-bit NVRAM Start Address containing the list of calibration values</td></tr><tr><td>Output/Return value:</td><td>A-Accu: Pulse_out value as integer</td></tr><tr><td>Prerequisites</td><td>result_1: 4 bytes (Same fpp as result_2 and result_n) result_2 : 4 bytes (Same fpp as result_1 and result_n) pulse_out_1 : 2 bytes (Integer) pulse_out_2: 2 bytes (Integer) pulse_out_max: 2 bytes (Integer) pulse_out_min: 2 bytes (Integer)</td></tr><tr><td>Dependency on other header files</td><td>-</td></tr><tr><td>Function call</td><td>jsb _ROM_pulse__</td></tr><tr><td>Temporary memory usage</td><td>_____temporary_variables_ - 8 to _temporary_variables_</td></tr><tr><td>Example:</td><td>rad Z_result ; Value to be given as pulse output move a, r load b, result1_NVaddress ; Starting address in NVRAM ; containing constants ; Input : B-Accu: 10 bit NVRAM Address ; A-Accu : Value of result_n jsb _ ROM_pulse__; Output in A-Accu is an integer rad PULSEO ; Pulse output on PULSEO move ríng</td></tr></table>

_ROM_pulse_loaded_cal_vals

<table><tr><td>Function:</td><td>This ROM routine has the same functionality as the _ROM_pulse_ routine. Only difference is that the constant values have to be copied from the calibration NVRAM memory to the RAM by the firmware, before this routine is called.</td></tr><tr><td>Input parameters:</td><td>A-Akku: Value of result_n DPTR0: Start address of the RAM containing the constant values in 6 consecutive addresses in the following order: result_1 (Same fpp as result_2 and result_n) result_2 Same fpp as ) pulse_out_1 (Integer) pulse_out_2 (Integer) pulse_out_max (Integer) pulse_out_min (Integer)</td></tr><tr><td>Output/Return value:</td><td>A-Akku: Pulse_out value as integer</td></tr><tr><td>Prerequisites</td><td>The coordinate values must be copied from the NVRAM to a RAM space by the firmware.</td></tr><tr><td>Dependency on other header files</td><td>-</td></tr><tr><td>Function call</td><td>jsb _ROM_ pulse_loaded_cal_vals</td></tr><tr><td>Temporary memory usage</td><td>_____temporary_variables_ - 8 to _temporary_variables_</td></tr><tr><td>Example:</td><td>d Z_result ; Value to be given as pulse output move a, r load b, result1_RAMaddress ; Starting address in RAM ; containing constants rad DPTRO mover, b ; Input : DPTR0: Starting RAM Address ; A-Accu : Value of result_n jsb _ROM_pulse_loaded_cal_vals ; Output in A-Accu is an integer _____ move r, a</td></tr></table>

_ROM_NVblock_copy__

<table><tr><td>Function:</td><td>Copy a block of data from NVRAM to RAM</td></tr><tr><td>Input parameters:</td><td>DPTR0: Start address of the RAM B-Accu : Starting address of the NVRAM A-Accu: Count of the number of values to be copied SIGNED_VALUE_NV in FLAGREG must be set (for reading signed values)or cleared (for reading unsigned values) - relevant only for 24/16/08 bit values</td></tr><tr><td>Output/Return value:</td><td>RAM contains a copy of the specified number of values from the NVRAM</td></tr><tr><td>Prerequisites</td><td>None</td></tr><tr><td>Dependency on other header files</td><td>None</td></tr><tr><td>Function call</td><td>jsb _ROM_NVblock_copy_32b_; jsb _ROM_NVblock_copy_24b_; jsb _ROM_NVblock_copy_16b_; jsb _ROM_NVblock_copy_08b_;</td></tr><tr><td>Temporary memory usage</td><td>_____temporary_variables_</td></tr><tr><td>Example:</td><td>This example copies 4 values, 32 bits each from the NVRAM to the RAM address starting at xi_at_ccp1: load a, RAM_address ; DPTRO <-- starting RAM address rad DPTRO move ríng load2exp a, 2 ; Count = 4 load b, NVRAM_address ; Starting NVRAM address ; Subroutine to copy values from NVRAM -> RAM, ;Returns current NVRAM address in B-Akku 2 ROM_NVblock_copy_32b_</td></tr></table>

_ROM_capacitance_polynomial

<table><tr><td>Function:</td><td>This function calculates the value of the capacitance polynomial, Z_result = (((a2 * theta)+ a1) * theta )+a0 given the capacitance ratio or inverse (Cratio) and temperature (theta). a2, a1 and a0 are 3rd degree polynomials of the Cratio value an \( = \left( {\left( {\mathrm{{cc}}3\mathrm{n}/\mathrm{{xi}} + \mathrm{{cc}}2\mathrm{n}}\right) /\mathrm{{xi}} + \mathrm{{cc}}1\mathrm{n}}\right) /\mathrm{{xi}} + \mathrm{{cc}}0\mathrm{n} \) where cc3n .... cc0n are the coefficients of the third degree polynomial in the NVRAM</td></tr><tr><td>Input parameters:</td><td>Address of the capacitance ratio or inverse(Cratio) DPTR1: Address of the temperature (theta) 3-Accu Starting address of coefficient values in NVRAM Arg_6: Z_min Arg_7 : Z_max FLAGREG, Bit 7 (LIN_3BYTE_COEFF) : \( 1 \rightarrow  3 \) bytes in each of the coefficients \( 0 \rightarrow  4 \) bytes in each of the coefficients</td></tr><tr><td>Output/Return value:</td><td>A-Accu: Z_result = result of the polynomial</td></tr><tr><td>Prerequisites</td><td>-</td></tr><tr><td>Function call</td><td>_ROM_capacitance_polynomial_____</td></tr><tr><td>Temporary memory usage</td><td>_____temporary_variables_ - 8 to _____temporary_variables_ Arg_0 to Arg_7</td></tr><tr><td>Example:</td><td>; Copying Z_min and Z_max to Arg_6 and Arg_7 load a, Arg_6 ; DPTR0 <-- starting argument ; memory address (RAM) rad DPTRO move ríng load2exp a, 1 ; Count = 2 b, NV_Cal_vals; Starting address of Calibration ; values in NVRAM jsb _____ ROM_NVblock_copy_32b_ ; Subroutine to copy Z_min ; and Z_max values from NVRAM -> argument RAM load a, C1_ratio rad DPTRO ; DPTRO: Address of the capacitance ; ratio or inverse(Cratio) move r, a bad a a, theta ; DPTR1: Address of the temperature rad DPTR1 move r, a load b, NV_QUADRATIC_COEFFS; Address of the coefficients ;in NVRAM in B-Accu jsb _ROM_capacitance_polynomial rad Z_result mover, a</td></tr></table>

_ROM_capacitance_polynomial_4d

<table><tr><td>Function:</td><td>This function calculates the value of the capacitance polynomial, Z_result = (((a2 * theta)+ a1) * theta )+a0 given the capacitance ratio or inverse (Cratio) and temperature (theta). a2, a1 and a0 are 4th degree polynomials of the Cratio value an \( = \left( {\left( {\left( {\mathrm{{cc}}4\mathrm{n}/\mathrm{{xi}} + \mathrm{{cc}}3\mathrm{n}}\right) /\mathrm{{xi}} + \mathrm{{cc}}2\mathrm{n}}\right) /\mathrm{{xi}} + \mathrm{{cc}}1\mathrm{n}}\right) /\mathrm{{xi}} + \mathrm{{cc}}0\mathrm{n} \) where cc4n ... cc0n are the coefficients of the fourth degree polynomial in the NVRAM</td></tr><tr><td>Input parameters:</td><td>Address of the capacitance ratio or inverse(Cratio) DPTR1: 1: Address of the temperature (theta) B-Accu ccu Starting address of coefficient values in NVRAM Arg_6: Z_min Arg_7 : Z_max</td></tr><tr><td>Output/Return value:</td><td>A-Accu: Z_result = result of the polynomial</td></tr><tr><td>Prerequisites</td><td>-</td></tr><tr><td>Function call</td><td>_ROM_capacitance_polynomial_____</td></tr><tr><td>Temporary memory usage</td><td>_____temporary_variables_ - 8 to _____temporary_variables_ Arg_0 to Arg_7</td></tr><tr><td>Example:</td><td>; Copying Z_min and Z_max to Arg_6 and Arg_7 load a a, Arg_6 ; DPTR0 <-- starting argument ; memory address (RAM) rad DPTRO move ríng load2exp a, 1 ; Count = 2 b, NV_Cal_vals; Starting address of Calibration ; values in NVRAM jsb _____ ROM_NVblock_copy_32b_; Subroutine to copy Z_min ; and Z_max values from NVRAM -> argument RAM load a, C1_ratio rad DPTRO ; DPTRO: Address of the capacitance ; ratio or inverse(Cratio) move r, a load ad a a, theta ; DPTR1: Address of the temperature rad DPTR1 move r, a load b, NV_QUADRATIC_COEFFS; Address of the coefficients ;in NVRAM in B-Accu jsb _ROM_capacitance_polynomial_4d rad Z_result mover, a</td></tr></table>

## Assembly Programs

The PCap04 assembler is a multi-pass assembler that translates assembly language files into HEX files as they will be downloaded into the device. For convenience, the assembler can include header files. The user can write his own header files but also integrate the library files as they are provided by ams. The assembly program is made of many statements which contain instructions and directives. In the former section we explained the instructions in detail. In the following sections we describe the directives and some sample code.

Each line of the assembly program can contain only one directive or instruction statement. Statements must be contained in exactly one line.

## Symbols

A symbol is a name that represents a value. Symbols are composed of up to 31 characters from the following list:

A \( - Z, a - z,0 - 9, \) _____

Symbols are not allowed to start with numbers. The assembler is case sensitive, so care has to be taken for this.

## Numbers

Numbers can be specified in hexadecimal or decimal. Decimal have no additional specifier. Hexadecimals are specified by leading "Ox".

## Expressions and Operators

An expression is a combination of symbols, numbers and operators. Expressions are evaluated at assembly time and can be used to calculate values that otherwise would be difficult to be determined.

The following operators are available with the given precedence: Example:

<table><tr><td>Level</td><td>Operator</td><td>Description</td></tr><tr><td>1</td><td>0</td><td>Brackets, specify order of execution</td></tr><tr><td>2</td><td>* /</td><td>Multiplication, Division</td></tr><tr><td>3</td><td>+-</td><td>Addition, Subtraction</td></tr></table>

CONST value 1

equal \( \;\left( {\left( {\text{value } + 3}\right) /2}\right) \)

## amm

## Directives

The assembler directives define the way the assembly language instructions are processed. They also provide the possibility to define constants, to reserve memory space and to control the placement of the code. Directives do not produce executable code.

The following table provides an overview of the assembler directives.

Figure 134:

Overview of Assembler Directives

<table><tr><td>Directive</td><td>Description</td><td>Example</td></tr><tr><td>CONST</td><td>Constant definition, CONST [name] [value] value might be a number, a constant, a sum of both</td><td>CONST Slope 42 CONST Slope constant + 1</td></tr><tr><td>LABEL:</td><td>Label for target address of jump instructions. Labels end with a colon. All rules that apply to symbol names also apply to labels.</td><td>jsb LABEL1 LABEL1: ...</td></tr><tr><td>;</td><td>Comment, lines of text that might be implemented to explain the code. It begins with a semicolon character. The semicolon and all subsequent characters in this line will be ignored by the assembler. A comment can appear on a line itself or follow an instruction.</td><td>; this is a comment</td></tr><tr><td>org</td><td>Sets a new origin in program memory for subsequent statements.</td><td rowspan="2">org 0x23 equal 0x332211 ; write 0x11 to address 0x23, ; 0x22 to address 0x24 ...</td></tr><tr><td>equal</td><td>Insert three bytes of user defined data in program memory, starting at the address as defined by org.</td></tr><tr><td>#device</td><td>Directive definition, #device [dev_name] might be the name of the used device. Defines which Library is used for the assembler and defines the subdirectory \\lib\\ [dev_name] for the included header or library file.</td><td>#device PCap03-Z</td></tr><tr><td>#include</td><td>Include the header or library file named in the brackets < > or quotation marks " ". The code will be added at the line of the include command. Names in brackets refer to the ams library with the defined subdirectory \\lib\\ [dev_name]. Without using #device directive it refers to the fixed subdirectory \\lib. In quotation marks the might be just the file name in case it is in the same folder as the program, but also the complete path.</td><td>#include <rdc.h> #include "rdc.h"</td></tr></table>

<table><tr><td>Directive</td><td>Description</td><td>Example</td></tr><tr><td>#ifdef #elseif #endif</td><td>Directive to implement code or not, dependig on the value of the symbol following the #ifdef directive. Use e.g. to include header files only once into a program.</td><td rowspan="2">#ifdef __standard_h__ #else #define _____standard_h_ ... #endif</td></tr><tr><td>#define</td><td>Defines a symbol that will be interpreted as true when being analysed by the #ifdef directive</td></tr></table>

## amm

## Sample Code

In the following we show some sample code for programming loops in the various kinds, for the use of the load instruction and the rotate instruction.

“for” Loop

<table><tr><td>Assembler</td><td>C-Equivalent</td><td>Comment</td></tr><tr><td>load a, max not a inc a rad index mover, a do: \( ;\{ \) .. \( \} \) rad index incr jCarC do</td><td>for(index=-max; index < 0; index++)</td><td>max : number of repetitions 2nd complement for max (~max+1) store (-max) to index loop body loop increment repeat while index \( < 0 \)</td></tr></table>

“while” Loop

<table><tr><td>Assembler</td><td>C-Equivalent</td><td>Comment</td></tr><tr><td>do: rad expression move a, r jEQ done ;\{..\} clear a jEQ do done;</td><td>while ( expression ) \( \{ \) .. \( \} \)</td><td>activate Status Flags for „expression“. Jump if expression \( =  = 0 \) loop body unconditional jump without writing to program counter stack</td></tr></table>

"do - while" Loop

<table><tr><td>Assembler</td><td>C-Equivalent</td><td>Comment</td></tr><tr><td>do:</td><td>do</td><td/></tr><tr><td>\( ;\{ \) .. \( \} \)</td><td>\( \{ \) .. \( \} \)</td><td>loop body</td></tr><tr><td>rad expression</td><td>while ( expression )</td><td/></tr><tr><td>move a, r</td><td/><td>activate Status Flags</td></tr><tr><td>jNE do</td><td/><td>jump if expression \( l = 0 \)</td></tr></table>

"do - while" with 2 pointers

<table><tr><td>Assembler</td><td>C-Equivalent</td><td>Comment</td></tr><tr><td>load a, MW7 rad loopLimit</td><td>loopLimit = *MW7</td><td>load max-address for ptrSource</td></tr><tr><td>move r, a</td><td/><td/></tr><tr><td>load a, MW0</td><td>ptrSource = *MW0;</td><td>load ptrSource with source address</td></tr><tr><td>rad DPTR0</td><td/><td/></tr><tr><td>move r, a</td><td/><td/></tr><tr><td>load a, RESO</td><td>ptrSink = *Res0;</td><td>load ptrSink with sink address</td></tr><tr><td>rad DPTR1</td><td/><td/></tr><tr><td>move r, a</td><td/><td/></tr><tr><td>do:</td><td/><td>loop body</td></tr><tr><td>rad_at_DPTR0</td><td>do \{ *ptrSink++ = *ptrSource++ \}</td><td>load value from source</td></tr><tr><td>move a, r</td><td/><td/></tr><tr><td>rad_at_DPTR1</td><td/><td>write value to sink</td></tr><tr><td>move r, a</td><td/><td/></tr><tr><td>rad loopLimit</td><td/><td>write max-address to a</td></tr><tr><td>move a, r</td><td/><td/></tr><tr><td>rad DPTR1</td><td/><td>increment sink address</td></tr><tr><td>incr</td><td/><td/></tr><tr><td>rad DPTR0</td><td/><td>increment source</td></tr><tr><td>incr sub a, r</td><td/><td>address</td></tr><tr><td>jCarS do</td><td/><td>limitLoop – ptrSource</td></tr><tr><td/><td/><td>repeat loop if ptrSource <= max-address</td></tr><tr><td/><td>while ( ptrSource <= MW7)</td><td/></tr></table>

## Rotate Right A to B

To rotate a value right from Akku A to Akku B, Akku B and R must be set to zero. Afterwards with each mult command a single "rotate right from \( A \) to \( {B}^{\prime \prime } \) is done. This function could be used e.g. to shift a 8-bit value to the highest byte in the register.

<table><tr><td>Assembler</td><td>C-Equivalent</td><td>Comment</td></tr><tr><td>load a, 0xa3 clear b move r, b mult ; (8x) mult - mult</td><td>A = <U8bC> b = a << 40</td><td/></tr></table>

## amm

## Libraries

The PICOCAP assembler offers the possibility to implement library files. With these libraries the firmware can be written in a modular manner. Common library files are for definitions of variable and constant names.

When the DSP has to be programmed by the user for a specific application or when the firmware ought to be modified, these library functions can be simply integrated into the application program without any major tailoring. They save programming effort for known, repeatedly used, important functions. Some library files are interdependent on other file(s) from the library.

The library functions are called header files (they have *.h extension) in the assembler software and have to be included in the main *.asm program. The path for the library files should be \\lib\\ [dev_name] in the folder where the assembler is.

The following are the header files that we supply together with the assembler as part of the evaluation kit.

## Device Related

pcap_standard.h

PCap04_ROM_addresses_standard.h

pcap_config.h

The input parameters, output parameters, effect on RAM contents etc. for each of these library functions are explained in the tables below.

Note(s): In the standard firmware and in all the library files, the notation "ufdN" is used as a comment. This shows if the parameter is signed or unsigned and the number of fractional digits in the number, N. For e.g. ufd21 indicates that the parameter is an unsigned fixed point number with 21 fractional digits. If the u at the beginning is missing, it is a signed number.

pcap_standard.h

<table><tr><td>Function:</td><td>This is a standard library for PCap04 firmware projects. It contains the major address mappings and constant names for the PCap04. Note: This file should be always included. It contains no commands, so no pro- gram space is wasted</td></tr><tr><td>Definitions (examples):</td><td>... ;- Temp. Variables and Arguments Def. CONST __arguments__82 CONST __number_of_arguments__10 CONST _____temporary_variables_____arguments_____1_____number_of_arguments_____ CONST Arg_0 _____arguments_____ - 8 CONST Arg_1 __arguments__ - 7 ... ; - RAM-Addresses OUT (&IN) CONST FLAGREG96 CONST RESOO 97 CONST RES01 98 CONST RES02 99 ...</td></tr></table>

PCap04_ROM_addresses_standard.h

<table><tr><td>Function:</td><td>This file declares the jump labels for ROM routines</td></tr><tr><td>Definitions (examples):</td><td>... CONST _ROM_dma_0x5d1; 1489 CONST _ROM_ln_0x5e1 ; 1505 CONST _ROM_log10_0x5fc; 1532 ... CONST _ROM_cdc_0x7d4; 2004 CONST _sub_cdc_C0_Ratio_temp0x3A; 58 CONST __sub_cdc_C1_Ratio_temp0x3B; 59 ...</td></tr></table>

## aml

pcap_config.h

<table><tr><td>Function:</td><td>Configuration register addresses and names for pcap04. It is for convenience, contains no commands and so no program space is wasted.</td></tr><tr><td>Definitions (examples):</td><td>CONST CFG_ADD_OFFSET 960 ; Start address of config in ; NVRAM ; --------- Register 13 CONST CFG_ADD_C_TRIG_SEL 13 + CFG_ADD_OFFSET ... ; --------- Register 42 CONST CFG_ADD_EXTERNAL_FLAGS 42+ CFG_ADD_OFFSET CONST CFG_BM_C_MEDIAN_EN0x01 ; Bit Mask for C_MEDIAN_EN ; Enable median filter for CDC values ...</td></tr></table>

## Application Information

## Schematic

Pcap04 needs only a few external components for operation. Of importance is a sufficient buffering of the supply voltage. We recommend \( {10\mu }\mathrm{F} \) for VDD33 and \( {4.7\mu }\mathrm{F} \) for VDD18. A simple RC network may be used for integration of the PDM outputs to generate analog output signal.

Figure 135:

Typical Schematics with \( {\mathrm{I}}^{2}\mathrm{C} \) Interface and PDM Analog Outputs

![bo_d3r3s93ef24c73d0qhr0_164_231_648_1232_856_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_164_231_648_1232_856_0.jpg)

## amm

## Minimized Bonding

Pcap04 is designed that for compact one-sensor applications the die may be bonded on two sides only.

Minimum: GND: #3, 4, 21,22, VDD33: #7, 24, VDD18: #5, 6 have to be connected.

Figure 136:

2-Side Bonding

![bo_d3r3s93ef24c73d0qhr0_165_247_613_1210_670_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_165_247_613_1210_670_0.jpg)

## Package Drawings & Markings

Figure 137:

Package Drawing (QFN24)

![bo_d3r3s93ef24c73d0qhr0_166_186_341_1308_1497_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_166_186_341_1308_1497_0.jpg)

## Note(s):

1. Dimensioning and tolerancing conform to ASME Y14.5M-1994

2. All dimensions are in millimeters (angles are in degrees).

3. Dimension b applies to metallized terminal and is measured between \( {0.25}\mathrm{\;{mm}} \) and \( {0.30}\mathrm{\;{mm}} \) from terminal tip. Dimension L1 represents terminal full back from package edge up to \( {0.15}\mathrm{\;{mm}} \) is acceptable.

4. Coplanarity applies to the exposed heat slug as well as the terminal.

5. Radius on terminal is optional.

6. \( \mathrm{N} \) id the total number of terminals.

## amm

Figure 138:

Package Marking

![bo_d3r3s93ef24c73d0qhr0_167_727_303_777_406_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_167_727_303_777_406_0.jpg)

Figure 139:

Package Code

<table><tr><td>PCAP04</td><td/><td>PP</td><td>v1</td><td>YY</td><td>WW</td><td>X</td><td>Z</td></tr><tr><td>Part</td><td>Temperature A : -40℃ to 125℃ B : -40℃ to 85℃</td><td>Package QF : QFN24</td><td>Silicon revision</td><td>Year</td><td>Week</td><td>Assembly Plant Identifier</td><td>Assembly Traceability Code</td></tr></table>

## PCB Pad Layout

Caution: The center pad is internally connected to GND. No wires other than GND are allowed underneath.

It is recommended to not solder the center pad. Too much solder paste could reduce solder quality.

Suitable socket: e.g. Plastronics 32QN50S15050D

Figure 140:

Landing Pattern

![bo_d3r3s93ef24c73d0qhr0_168_496_596_693_750_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_168_496_596_693_750_0.jpg)

Note(s):

1. All dimensions are in \( \mathrm{{mm}} \) .

## amm

## Tape & Reel Information

Figure 141:

Package Overview (only QFN)

<table><tr><td rowspan="2">Package</td><td rowspan="2">Device</td><td colspan="2">Devices per Reel</td></tr><tr><td>7" Reel</td><td>13" Reel</td></tr><tr><td>QFN24</td><td>PCap04</td><td>1000</td><td>6000</td></tr></table>

The tape-and-reel configuration is used for transport and storage from the manufacturer (ams AG) to the customer, and for use in the customer manufacturing plant. The configuration is designed for feeding components to automatic-placement machines for surface mounting on board assemblies. The complete configuration consists of a carrier tape with sequential individual cavities that hold individual components, and a cover tape that seals the carrier tape to retain the components in the cavities. Single reels are packed into dry-pack and inserted into intermediate boxes before shipping. Figure 142:

Reel

![bo_d3r3s93ef24c73d0qhr0_169_227_1132_1244_681_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_169_227_1132_1244_681_0.jpg)

Figure 143:

Single Reel in Dry Bag

![bo_d3r3s93ef24c73d0qhr0_170_213_278_1286_797_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_170_213_278_1286_797_0.jpg)

Carrier tape is widely used for presenting devices to pick-and-place machines for automatic placement onto printed circuit boards.

Figure 144:

Carrier Tape QFN24 (32)

![bo_d3r3s93ef24c73d0qhr0_171_191_272_1310_1251_0.jpg](images/bo_d3r3s93ef24c73d0qhr0_171_191_272_1310_1251_0.jpg)

Note(s):

1. Sprocket hole pitch cumulative tolerance \( \pm  {0.2} \)

2. Camber in Compliance with EIA 481

3. Pocket position relative to sprocket hole measured as true position of pocket, not pocket hole

4. All dimensions in mm

Soldering & Storage

Information

## amm

IPC/JEDEC J-STD-020

The reflow peak soldering temperature (body temperature) is specified according to IPC/JEDEC J-STD-020 "Moisture/Reflow Sensitivity Classification for Non-hermetic Solid State Surface Mount Devices." The lead finish for Pb-free leaded packages is "Matte Tin" (100% Sn)

## amm

## Ordering & Contact Information

Figure 145:

Ordering Information Buy our products or get free samples online at: www.ams.com/ICdirect Technical Support is available at: www.ams.com/Technical-Support Provide feedback about this document at: www.ams.com/Document-Feedback For further information and requests, e-mail us at: ams_sales@ams.com For sales offices, distributors and representatives, please visit: www.ams.com/contact

<table><tr><td>Ordering Code</td><td>Package</td><td>Marking</td><td>Delivery Form</td><td>Delivery Quantity</td></tr><tr><td>PCap04-AQFT-24</td><td rowspan="2">QFN24</td><td rowspan="2">PCAP04 AQF V1 YYWWXZZ</td><td>13”Tape & Reel in dry pack</td><td>6000 pcs/reel</td></tr><tr><td>PCap04-AQFM-24</td><td>7”Tape & Reel in dry pack</td><td>1000 pcs/reel</td></tr><tr><td>PCap04-BQFT-24</td><td rowspan="2">QFN24</td><td rowspan="2">PCAP04 BQF V1 YYWWXZZ</td><td>13”Tape & Reel in dry pack</td><td>6000 pcs/reel</td></tr><tr><td>PCap04-BQFM-24</td><td>7”Tape & Reel in dry pack</td><td>1000 pcs/reel</td></tr><tr><td>PCap04-ASWB</td><td>n.a.</td><td>n.a.</td><td>Sorted wafer in box</td><td>1 wafer \( =  \sim  {10000} \) die</td></tr><tr><td>PCap04-ASDF</td><td>n.a.</td><td>n.a.</td><td>Sorted wafer on blue foil</td><td>1 wafer = ~10000 die</td></tr><tr><td>PCap04-BSWB</td><td>n.a.</td><td>n.a.</td><td>Sorted wafer in box</td><td>1 wafer \( =  \sim  {10000} \) die</td></tr></table>

## Headquarters

ams AG

Tobelbader Strasse 30

8141 Premstaetten

Austria, Europe

Tel: +43 (0) 3136 500 0

Website: www.ams.com

RoHS Compliant & ams Green

Statement

RoHS: The term RoHS compliant means that ams AG products fully comply with current RoHS directives. Our semiconductor products do not contain any chemicals for all 6 substance categories, including the requirement that lead not exceed 0.1% by weight in homogeneous materials. Where designed to be soldered at high temperatures, RoHS compliant products are suitable for use in specified lead-free processes.

ams Green (RoHS compliant and no Sb/Br): ams Green defines that in addition to RoHS compliance, our products are free of Bromine (Br) and Antimony (Sb) based flame retardants (Br or Sb do not exceed 0.1% by weight in homogeneous material).

Important Information: The information provided in this statement represents ams AG knowledge and belief as of the date that it is provided. ams AG bases its knowledge and belief on information provided by third parties, and makes no representation or warranty as to the accuracy of such information. Efforts are underway to better integrate information from third parties. ams AG has taken and continues to take reasonable steps to provide representative and accurate information but may not have conducted destructive testing or chemical analysis on incoming materials and chemicals. ams AG and ams AG suppliers consider certain information to be proprietary, and thus CAS numbers and other limited information may not be available for release.

## amm

## Copyrights & Disclaimer

Copyright ams AG, Tobelbader Strasse 30, 8141 Premstaetten, Austria-Europe. Trademarks Registered. All rights reserved. The material herein may not be reproduced, adapted, merged, translated, stored, or used without the prior written consent of the copyright owner.

Devices sold by ams AG are covered by the warranty and patent indemnification provisions appearing in its General Terms of Trade. ams AG makes no warranty, express, statutory, implied, or by description regarding the information set forth herein. ams AG reserves the right to change specifications and prices at any time and without notice. Therefore, prior to designing this product into a system, it is necessary to check with ams AG for current information. This product is intended for use in commercial applications. Applications requiring extended temperature range, unusual environmental requirements, or high reliability applications, such as military, medical life-support or life-sustaining equipment are specifically not recommended without additional processing by ams AG for each application. This product is provided by ams AG "AS IS" and any express or implied warranties, including, but not limited to the implied warranties of merchantability and fitness for a particular purpose are disclaimed.

ams AG shall not be liable to recipient or any third party for any damages, including but not limited to personal injury, property damage, loss of profits, loss of use, interruption of business or indirect, special, incidental or consequential damages, of any kind, in connection with or arising out of the furnishing, performance or use of the technical data herein. No obligation or liability to recipient or any third party shall arise or flow out of ams AG rendering of technical or other services.

## Document Status

<table><tr><td>Document Status</td><td>Product Status</td><td>Definition</td></tr><tr><td>Product Preview</td><td>Pre-Development</td><td>Information in this datasheet is based on product ideas in the planning phase of development. All specifications are design goals without any warranty and are subject to change without notice</td></tr><tr><td>Preliminary Datasheet</td><td>Pre-Production</td><td>Information in this datasheet is based on products in the design, validation or qualification phase of development. The performance and parameters shown in this document are preliminary without any warranty and are subject to change without notice</td></tr><tr><td>Datasheet</td><td>Production</td><td>Information in this datasheet is based on products in ramp-up to full production or full production which conform to specifications in accordance with the terms of ams AG standard warranty as given in the General Terms of Trade</td></tr><tr><td>Datasheet (discontinued)</td><td>Discontinued</td><td>Information in this datasheet is based on products which conform to specifications in accordance with the terms of ams AG standard warranty as given in the General Terms of Trade, but these products have been superseded and should not be used for new designs</td></tr></table>

## amm

Revision Information

<table><tr><td>Changes from 1-02 (2017-Nov-08) to current revision 1-03 (2018-Apr-04)</td><td>Page</td></tr><tr><td>Updated Figure 1</td><td>1</td></tr><tr><td>Updated Figure 8</td><td>10</td></tr><tr><td>Updated notes under Figure 10</td><td>13</td></tr><tr><td>Updated text under Figure 77</td><td>53</td></tr><tr><td>Updated Figure 78</td><td>54</td></tr><tr><td>Updated text under Figure 80</td><td>56</td></tr><tr><td>Updated text under Figure 89</td><td>62</td></tr><tr><td>Updated text under Trigger</td><td>66</td></tr><tr><td>Updated text under NVRAM Access</td><td>94</td></tr></table>

Note(s):

1. Page and figure numbers for the previous version may differ from page and figure numbers in the current revision.

2. Correction of typographical errors is not explicitly mentioned.

## Content Guide

1 General Description

1 Key Benefits & Features

2 Applications MEMS Sensors

2 Block Diagram

3 Pin Assignments

4 Pin Description

6 Pad Coordinates

8 Absolute Maximum Ratings

10 Electrical Characteristics

13 CDC Characteristics

14 RDC Characteristics

16 Timing Characteristics

17 Detailed Description

19 Register Description

19 Configuration Registers

19 Register Overview

4 Detailed Configuration Register Description

Configuration Register 0 (Address 0x0)

Configuration Register 1 (Address 0x1)

Configuration Register 2 (Address 0x2)

Configuration Register 3 (Address 0x3)

Configuration Register 4 (Address 0x4)

Configuration Register 5 (Address 0x5)

27 Configuration Register 6 (Address 0x6)

27 Configuration Register 7:8 (Address 0x7, 0x8)

27 Configuration Register 11:9 (Address 0x9;0xA;0xB)

28 Configuration Register 12 (Address 0xC)

28 Configuration Register 13 (Address 0xD)

28 Configuration Register 14 (Address 0xE)

29 Configuration Register 15 (Address 0xF)

29 Configuration Register 16 (Address 0x10)

29 Configuration Register 17 (Address 0x11)

30 Configuration Register 18 (Address 0x12)

31 Configuration Register 19 (Address 0x13)

31 Configuration Register 20 (Address 0x14)

32 Configuration Register 21 (Address 0x15)

32 Configuration Register 22(Address 0x16)

33 Configuration Register 23 (Address 0x17)

33 Configuration Register 24 (Address 0x18)

34 Configuration Register 25 (Address 0x19)

34 Configuration Register 26 (Address 0x1A)

34 Configuration Register 27 (Address 0x1B)

35 Configuration Register 28 (Address 0x1C)

35 Configuration Register 29 (Address 0x1D)

35 Configuration Register 30 (Address 0x1E)

36 Configuration Register 31 (Address 0x1F)

37 Configuration Register 32 (Address 0x20)

37 Configuration Register 33 (Address 0x21)

38 Configuration Register 34 (Address 0x22)

38 Configuration Register 35 (Address 0x23)

38 Configuration Register 36 (Address 0x24)

39 Configuration Register 37 (Address 0x25)

39 Configuration Register 38 (Address 0x26)

39 Configuration Register 39 (Address 0x27)

39 Configuration Register 40 (Address 0x28)

40 Configuration Register 41 (Address 0x29)

40 Configuration Register 42 (Address 0x30)

40 Configuration Register 47 (Address 0x2F)

41 Configuration Register 48 (Address 0x30)

41 Configuration Register 49 (Address 0x31)

41 Configuration Register 50 (Address 0x32)

42 Configuration Register 51 to 53: ams internal Registers, 0x00 mandatory

42 Configuration Register 54 (Address 0x36)

42 Configuration Register 55 to 61: ams internal Registers, 0x00 mandatory 42 Configuration Register 62 (Address 0x3e) 42 Configuration Register 63 (Address 0x3f) 43 Read Registers 45 Result Registers 45 Status Registers 47 Principles of Operation 47 Converter Frontend

47 Capacitance-to-Digital Converter (CDC)

47 Measuring Principle

47 Connecting Sensors

48 Discharge Resistors

49 Cycle

51 Sequence

52 Conversion

55 CDC Compensation Options

55 Internal Compensation

55 External Compensation

56 DCBalance

57 Gain Correction

57 CDC Important Parameters

57 Cycle Clock

58 Cycle Time

59 Sequence

60 Conversion

61 Guarding

64 RDC Resistance-to-Digital Converter

64 Measuring Principle

64 Connecting Sensors

65 Cycle & Conversion

66 Trigger

67 RDC Important Parameters

67 Cycle Clock

68 Sequence

68 Conversion

68 RDC Results, Ratios

69 Interfaces (Serial & PDM/PWM)

69 Serial Interfaces (SIF)

70 Opcodes

\( {71}{\mathrm{l}}^{2}\mathrm{C} \) Compatible Interface

72 I'C Timing

72 IPC Write

73 I'CRead

73 SPI Interface

74 SPI Timing

76 GPIO and PDM/PWM

78 Debouncing Filter

78 PDM and PWM

82 Oscillators

83 DSP & Memory

84 DSP & Environment

85 RAM Structure

87 Registers 0 to 95, User RAM

88 Register 96, Flags & Internal Control Signals

88 DSP Read Register 97

89 DSP Read Registers 98 to 103

89 DSP Read/Write Registers 105 to 108, Data Pointer

90 DSP Read Register 126, PORTINFO (PORTERR<7...0>, PORTMASK<7...0>)

90 DSP Write Registers 97 to 104, RESOO...RESO7

90 DSP Write Registers 109, 110, PIO_REF...PI1_REF

90 DSP Write Register 111, TIMERO

91 DSP Read/Write Registers 112 to 120, MEM_CTRL, MEM_ ADD, MEM_DATA

92 DSP Read Registers 121 to 124, TDC_START, TDC_STOP, C_ADD_PTR, R_ADD_PTR

93 NVRAM and ROM

93 NVRAM Structure

94 NVRAM Access

94 ROM Structure

94 DSP Inputs & Outputs

99 ALU Flags

100 DSPOUT – GPIO Assignment

104 DSP Configuration

105 DSP Start

105 Watchdog

106 Instruction Set

107 Instructions

125 Instruction Details

125 Pointer

126 Transfer Constants with Push and Pop

126 mult

127 Handover of Constants by Push & Pop

127 div

130 ROM Routines

132 _ROM_Version_

132 _ROM_tdc_dispatch_

133 _ROM_cdc_cycle_

134 _ROM_Rdc_cycle_

135 _ROM_cdc_initialize_

135 _ROM_rdc_initialize_

136 shiftL_A_xx; shiftR_A_xx; shiftL_B_xx; shiftR_B_xx

136 mult_xx

137 div_xx

138 _ROM_div_variable_

139 _ROM_mult_variable_

140 _ROM_shift_a_variable_

140 _ROM_shift_b_variable_

141 _ROM_dma_

142 _ROM_In_, _ROM_log10_, _ROM_ld_

142 _ROM_signed24_to_signed32_

143 _ROM_median_

144 _ROM_cdc_

145 _ROM_rdc_;_ROM_rdc_inverse_

146 _ROM_memory_(read/write volatile memory)

148 _ROM_MEMORY_RECALL/STORE

149 _ROM_2pt_calibration

150 _ROM_polynomial_3rd_degree

151 _ROM_polynomial_4th_degree

152 _ROM_pulse_

153 _ROM_pulse_loaded_cal_vals

154 _ROM_NVblock_copy_

155 _ROM_capacitance_polynomial

156 _ROM_capacitance_polynomial_4d

157 Assembly Programs

158 Directives

160 Sample Code

160 “for” Loop

160 “while” Loop

160 “do - while” Loop

161 “do - while” with 2 pointers

161 Rotate Right A to B

162 Libraries

163 pcap_standard.h

163 PCap04_ROM_addresses_standard.h

164 pcap_config.h

165 Application Information

165 Schematic

166 Minimized Bonding

167 Package Drawings & Markings

169 PCB Pad Layout

170 Tape & Reel Information

173 Soldering & Storage Information

174 Ordering & Contact Information

175 RoHS Compliant & ams Green Statement

176 Copyrights & Disclaimer

177 Document Status

178 Revision Information