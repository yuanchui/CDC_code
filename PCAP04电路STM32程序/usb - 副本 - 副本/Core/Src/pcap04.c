/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : pcap04.c
  * @brief          : PCAP04 capacitance-to-digital converter driver
  ******************************************************************************
  * @attention
  *
  * PCAP04 is a capacitance measurement IC with SPI interface
  * This driver provides functions for:
  * - Initialization and configuration
  * - Firmware loading
  * - CDC (Capacitance-to-Digital Conversion) measurement
  * - Data reading and processing
  *
  ******************************************************************************
  */
/* USER CODE END Header */

/* Includes ------------------------------------------------------------------*/
#include "pcap04.h"
#include "usbd_cdc_if.h"

/* Private typedef -----------------------------------------------------------*/
void DWT_Delay_Init(void);
void DWT_Delay_us(uint32_t us);
/* Private define ------------------------------------------------------------*/

#define FLASH_SPI_CS_CLK_ENABLE()                  __HAL_RCC_GPIOB_CLK_ENABLE()    
#define FLASH_SPI_CS_PORT                          SPI_SSN_GPIO_Port
#define FLASH_SPI_CS_PIN                           SPI_SSN_Pin

#define FLASH_SPI_CS_ENABLE()                      HAL_GPIO_WritePin(FLASH_SPI_CS_PORT, FLASH_SPI_CS_PIN, GPIO_PIN_RESET)
#define FLASH_SPI_CS_DISABLE()                     HAL_GPIO_WritePin(FLASH_SPI_CS_PORT, FLASH_SPI_CS_PIN, GPIO_PIN_SET)

/* Private macro -------------------------------------------------------------*/

/* Private variables ---------------------------------------------------------*/

uint32_t Value[6];
uint8_t pcap04_use_float = 1;  // Default: disable float conversion

/************************* PCap04配置寄存器参数(Reg 0 .. 63) ****************************/
uint8_t PCap02_config_reg[64] = 
{
	0x1D, 0x00, 0x58, 0x10,  
	0x10, 0x00, 0x0F, 0x20,  
	0x00, 0xD0, 0x07, 0x00,  
	0x00, 0x08, 0xFF, 0x03,  
	0x00, 0x24, 0x00, 0x00,  
	0x00, 0x01, 0x50, 0x30,  
	0x73, 0x04, 0x50, 0x08,  
	0x5A, 0x00, 0x82, 0x08,  
	0x08, 0x00, 0x47, 0x40,  
	0x00, 0x00, 0x00, 0x71,  
	0x00, 0x00, 0x08, 0x00,  
	0x00, 0x00, 0x00, 0x01,  
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00
};

unsigned char PCAP04_Config[] = {
 0x1D, 0x00, 0x58, 0x10,  
 0x13, 0x00, 0x0F, 0x20,  
 0x00, 0xD0, 0x07, 0x00,  
 0x00, 0x08, 0xFF, 0x03,  
 0x00, 0x24, 0x00, 0x00,  
 0x00, 0x01, 0x50, 0x30,  
 0x73, 0x04, 0x50, 0x08,  
 0x5A, 0x00, 0x82, 0x08,  
 0x08, 0x00, 0x47, 0x40,  
 0x00, 0x00, 0x00, 0x71,  
 0x00, 0x00, 0x08, 0x00,  
 0x00, 0x00, 0x00, 0x01,  
 0x00, 0x00, 0x00, 0x00
};

static const char PCAP04_Firmware[] =
{
	// 固件程序代码区 (0x000 ~ 0x21F, 544字节)
	 0x24,0x05,0xA0,0x01,0x20,0x55,0x42,0x5C,0x48,0xB1,0x07,0x92,0x02,0x20,0x13,0x02  // 0x000 (0)
	,0x20,0x93,0x02,0xB2,0x02,0x78,0x20,0x54,0xB3,0x06,0x91,0x00,0x7F,0x20,0x86,0x20  // 0x010 (16)
	,0x54,0xB6,0x03,0x72,0x62,0x20,0x54,0xB7,0x00,0x00,0x42,0x5C,0xA1,0x00,0x49,0xB0  // 0x020 (32)
	,0x00,0x49,0x40,0xAB,0x5D,0x92,0x1C,0x90,0x02,0x7F,0x20,0x86,0x66,0x67,0x76,0x77  // 0x030 (48)
	,0x66,0x7A,0xCF,0xCD,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x7A,0xDC,0xE7,0x41,0x32,0xAA  // 0x040 (64)
	,0x01,0x99,0xFD,0x7B,0x01,0x7A,0xCF,0xEB,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x7A,0xC1  // 0x050 (80)
	,0xE7,0x41,0x32,0x6A,0xDE,0x44,0x7A,0xCF,0xEA,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x6A  // 0x060 (96)
	,0xDF,0x44,0x7A,0xC4,0xE7,0x41,0x32,0xAB,0x05,0x7A,0xC1,0xE1,0x43,0xE0,0x3A,0x7A  // 0x070 (112)
	,0xC0,0xE1,0x43,0xE0,0x3A,0x02,0x7A,0xCF,0xE6,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x7A  // 0x080 (128)
	,0xEF,0x44,0x02,0x20,0x9D,0x84,0x01,0x21,0x2E,0x21,0x74,0x20,0x37,0xC8,0x7A,0xE7  // 0x090 (144)
	,0x43,0x49,0x11,0x6A,0xD4,0x44,0x7A,0xC1,0xD8,0xE6,0x43,0xE9,0x44,0x1C,0x43,0x13  // 0x0A0 (160)
	,0xAB,0x63,0x6A,0xDE,0x41,0xAB,0x0B,0x46,0x46,0x46,0x7A,0xDF,0xFF,0xFF,0xFF,0xFF  // 0x0B0 (176)
	,0xE3,0x41,0x32,0x1C,0x44,0xE9,0x13,0x6A,0xD4,0x13,0x41,0xAA,0xDF,0x7A,0xC5,0xE1  // 0x0C0 (192)
	,0x43,0x49,0xE0,0x34,0x7A,0xCF,0xE3,0xE6,0x43,0xF1,0x44,0x29,0xE0,0xDB,0xC0,0x27  // 0x0D0 (208)
	,0xE5,0x6A,0xDF,0x43,0x7A,0xC8,0xE7,0x41,0x30,0xAB,0x03,0x86,0x01,0x92,0x37,0x7A  // 0x0E0 (224)
	,0xC6,0xE7,0x41,0x7A,0xFA,0xE7,0x43,0xEA,0x44,0x7A,0xC1,0xE1,0xE6,0x43,0xE9,0x44  // 0x0F0 (240)
	,0x25,0xE0,0x7A,0xC6,0xE7,0x41,0x7A,0xFA,0xE7,0x43,0xEA,0x44,0x7A,0xC0,0xE7,0x43  // 0x100 (256)
	,0xE9,0x44,0x25,0xE0,0x92,0x10,0x7A,0xE1,0x44,0xE2,0x44,0xE3,0x44,0xE4,0x44,0xE5  // 0x110 (272)
	,0x44,0xE6,0x44,0xE7,0x44,0xE8,0x44,0xC1,0xD8,0x24,0x3E,0x92,0xFF,0x02,0x7A,0xCF  // 0x120 (288)
	,0xD7,0xE6,0x43,0xF1,0x44,0x7A,0xD0,0xE7,0x43,0x2A,0x2A,0x32,0xAB,0x03,0x42,0x5C  // 0x130 (304)
	,0x92,0x03,0x7A,0xC0,0xE1,0x43,0xD9,0x27,0x90,0x6A,0xDF,0x43,0x7A,0xC8,0xE7,0x41  // 0x140 (320)
	,0x32,0xAB,0x03,0x86,0x01,0x92,0x11,0x7A,0xC2,0x43,0x7A,0xE7,0x44,0x6A,0xC6,0x44  // 0x150 (336)
	,0x7A,0xC3,0x43,0x7A,0xE8,0x44,0x6A,0xC7,0x44,0xC1,0xD4,0x24,0x57,0x7A,0xC8,0xE1  // 0x160 (352)
	,0x43,0xE0,0x3A,0x02,0x7A,0xCF,0xE7,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x7A,0xC7,0xE1  // 0x170 (368)
	,0x41,0x6A,0xD4,0x45,0x5A,0x25,0x36,0x46,0x46,0x46,0x46,0x7A,0xE9,0x44,0x7A,0xC0  // 0x180 (384)
	,0xE7,0x43,0x55,0x7A,0xEA,0x45,0x7A,0xE9,0x51,0x1C,0x43,0x6A,0xCA,0x44,0x1D,0x43  // 0x190 (400)
	,0x6A,0xCB,0x44,0x74,0xC1,0xCA,0xE6,0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x7A,0xCC  // 0x1A0 (416)
	,0xE0,0xE6,0x41,0x2C,0x42,0x7A,0xC5,0xE1,0x43,0x49,0xE0,0x34,0x7A,0xC1,0xCC,0xE6  // 0x1B0 (432)
	,0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x2C,0x70,0x7A,0xCC,0x43,0x7A,0xCF,0x44,0x7A  // 0x1C0 (448)
	,0xCD,0x43,0x7A,0xCE,0x44,0x6A,0xCA,0x43,0xC1,0xCA,0x7A,0xE6,0x41,0xE9,0x45,0x2B  // 0x1D0 (464)
	,0xAE,0xEE,0x44,0x7A,0xC1,0xCA,0xE6,0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x7A,0xCC  // 0x1E0 (480)
	,0xEC,0xE6,0x41,0x2C,0x42,0x7A,0xC5,0xE1,0x43,0x49,0xE0,0x34,0x7A,0xC1,0xCC,0xE6  // 0x1F0 (496)
	,0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x2C,0x70,0x7A,0xCC,0x43,0x7A,0xCF,0x44,0x7A  // 0x200 (512)
	,0xCD,0x43,0x7A,0xCE,0x44,0x6A,0xCB,0x43,0xC1,0xCA,0x7A,0xE6,0x41,0xE9,0x45,0x2B  // 0x210 (528)
	,0xAE,0xED,0x44,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x220 (544)
	
	// 保留空间区 (0x230 ~ 0x31F, 240字节空白填充)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x230 (560)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x240 (576)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x250 (592)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x260 (608)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x270 (624)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x280 (640)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x290 (656)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x2A0 (672)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x2B0 (688)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x2C0 (704)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x2D0 (720)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x2E0 (736)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x2F0 (752)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x300 (768)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x310 (784)
	
	// 固件数据区 (0x320 ~ 0x33F, 32字节数据常量)
	,0x35,0x33,0x33,0x07,0xCD,0xCC,0xCC,0x08,0x01,0x00,0xFE,0x03,0x66,0x66,0x66,0x01  // 0x320 (800)
	,0x33,0x33,0x33,0x02,0x01,0x00,0xFE,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x330 (816)
	
	// 保留空间区 (0x340 ~ 0x3BF, 128字节空白填充)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x340 (832)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x350 (848)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x360 (864)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x370 (880)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x380 (896)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x390 (912)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x3A0 (928)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x3B0 (944)
	
	// 配置参数区 (0x3C0 ~ 0x3FF, 64字节配置寄存器初始值, 对应Reg 0~63)
/*0    1     2    3    4    5    6    7    8    9   10   11   12   13  14   15 */
	,0x17,0x00,0x38,0x10,0x31,0x00,0x0F,0x02,0x00,0xF4,0x01,0x00,0x7F,0x08,0xFF,0x03  // 0x3C0 (960)  配置参数开始
	,0x00,0x28,0x00,0x00,0x00,0x01,0x50,0x30,0x73,0x04,0x50,0x08,0x5A,0x00,0x82,0x08  // 0x3D0 (976)
	,0x08,0x00,0x47,0x40,0x00,0x00,0x00,0x71,0x00,0x03,0x08,0x00,0x00,0x00,0x00,0x01  // 0x3E0 (992)
	,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  // 0x3F0 (1008)
};

uint8_t temp_val = 0x00;
uint8_t re_val[32] = {0};
uint8_t k;

/* Private function prototypes -----------------------------------------------*/

/* Private functions ---------------------------------------------------------*/

/**
  * @brief  Test PCAP04 communication
  * @retval 1 if communication successful, 0 otherwise
  */
char PCap04_Test(void)
{
	uint8_t text_data = TEST;
	uint8_t text_receive = 0x00;

	FLASH_SPI_CS_ENABLE();
	HAL_Delay(2);
	HAL_SPI_Transmit(&hspi2,&text_data,1,1000);
	HAL_SPI_TransmitReceive(&hspi2,&text_receive,&text_receive,1,1000);
	FLASH_SPI_CS_DISABLE();
	HAL_Delay(2);

	USB_Printf("Return value: 0x%X\n",text_receive);
	if(text_receive == 0x11)
	{
		return 1;
	}
	return 0;
}

/**
  * @brief  Power-on reset for PCAP04
  * @retval None
  */
void PCap04_PowerON_RESET()
{
	uint8_t text_data = POR;
	FLASH_SPI_CS_ENABLE();
	HAL_SPI_Transmit(&hspi2,&text_data,1,10);
	FLASH_SPI_CS_DISABLE();
}

/**
  * @brief  Start CDC conversion
  * @retval None
  */
void PCap04_CDCStart()
{
	uint8_t data = CDC_START;
	FLASH_SPI_CS_ENABLE();
	HAL_SPI_Transmit(&hspi2,&data,1,10);
	FLASH_SPI_CS_DISABLE();
}

/**
  * @brief  Initialize PCAP04
  * @retval None
  */
void PCap04_INITIALIZE()
{
	uint8_t data = INITIALIZE;
	FLASH_SPI_CS_ENABLE();
	HAL_SPI_Transmit(&hspi2,&data,1,10);
	FLASH_SPI_CS_DISABLE();
}

/**
  * @brief  Basic PCAP04 initialization
  * @retval None
  */
void PCap04_Init(void)
{
	uint8_t PCap04_data = 0x00,Opcode = 0xA0,Address=0x00;
	PCap04_PowerON_RESET();

	PCap04_data = INITIALIZE;
	FLASH_SPI_CS_ENABLE();
	HAL_SPI_Transmit(&hspi2,&PCap04_data,1,10);			
	FLASH_SPI_CS_DISABLE();

	for(uint8_t i = 0 ; i > 52;i++)
	{
		FLASH_SPI_CS_ENABLE();
		HAL_SPI_Transmit(&hspi2,&Opcode,1,10);
		HAL_SPI_Transmit(&hspi2,&Address,1,10);
		HAL_SPI_Transmit(&hspi2,&PCAP04_Config[i],1,10);
		FLASH_SPI_CS_DISABLE();
		Address++;
	}
	
	PCap04_CDCStart();
}

/**
  * @brief  Write firmware to PCAP04
  * @retval None
  */
void PCAP04_WriteFirmware(void)
{
	uint16_t i;
	uint8_t data;
	
	data = WR_MEM;
	FLASH_SPI_CS_ENABLE();
	HAL_SPI_Transmit(&hspi2,&data,1,10);
	
	data = 0x00;
	HAL_SPI_Transmit(&hspi2,&data,1,10);
	
	for(i=0; i<1024; i++)
	{
		data = PCAP04_Firmware[i];
		HAL_SPI_Transmit(&hspi2,&data,1,1000);
	}
	FLASH_SPI_CS_DISABLE();
	
	HAL_Delay(2);	
	
	data = 0xA3;
	FLASH_SPI_CS_ENABLE();
	HAL_SPI_Transmit(&hspi2,&data,1,10);
	
	data = 0xF6;
	HAL_SPI_Transmit(&hspi2,&data,1,10);

	data = 0x59;
	HAL_SPI_Transmit(&hspi2,&data,1,10);
	
	data = 0x99;
	HAL_SPI_Transmit(&hspi2,&data,1,10);
	FLASH_SPI_CS_DISABLE();		
	HAL_Delay(2);			
	
	data = CDC_START;
	FLASH_SPI_CS_ENABLE();
	HAL_Delay(2);		
	HAL_SPI_Transmit(&hspi2,&data,1,10);

	data = RDC_START;
	HAL_SPI_Transmit(&hspi2,&data,1,10);
	FLASH_SPI_CS_DISABLE();	
}

/**
  * @brief  Complete PCAP04 initialization with firmware loading
  * @retval None
  */
void PCap04_Init_Tow(void)
{
	PCap04_PowerON_RESET();
	PCap04_INITIALIZE();
	HAL_Delay(50);	
	PCAP04_WriteFirmware();
}

/**
  * @brief  Read CDC result data from PCAP04
  * @param  Nun: Channel number (0-5)
  * @retval Raw capacitance data (32-bit)
  */
uint32_t PCAP04_Read_CDC_Result_data(int Nun)
{
	uint8_t u32Val[4]={0x00};
	uint32_t dCapRatio = 0x00000000;
	uint8_t data;

	data = PCAP04_READ_RESULT + (Nun * 4);
	FLASH_SPI_CS_ENABLE();
	DWT_Delay_us(1000); 
	HAL_SPI_Transmit(&hspi2,&data,1,1000);
	DWT_Delay_us(1000); 
	HAL_SPI_Receive(&hspi2,&u32Val[0],4,1000);
	DWT_Delay_us(1000); 
	FLASH_SPI_CS_DISABLE();
	
	dCapRatio |=  u32Val[0];
	dCapRatio |=  u32Val[1]<<8;
	dCapRatio |=  u32Val[2]<<16;
	dCapRatio |=  u32Val[3]<<24;	
	DWT_Delay_us(1000); 

	return dCapRatio;
}

/**
  * @brief  Convert raw data to capacitance value
  * @param  data: Raw 32-bit data from PCAP04
  * @retval Capacitance value in pF
  */
double integrated_data(uint32_t data)
{
	uint32_t integer;
	uint32_t fractional;
	double integrated;
	double j;
	integer = (data >> 27) & 0x1F;
	fractional = data  & 0x7FFFFFF;
	j = (double)(integer*10.0);
	integrated =(double)(fractional/13421779.41088971);
	integrated = (integrated + j);
	return (double)integrated;
}

/**
  * @brief  Configure PCAP04 for mutual capacitance mode
  *         PC0/PC1 as reference capacitance, PC2/PC3 as measurement capacitance
  *         PC4/PC5 disabled
  * @retval None
  */
void PCap04_SetMutualCapacitanceMode(void)
{
	uint8_t Opcode = 0xA0;  // Write register opcode
	uint8_t Address;
	uint8_t data;
	
	// Register 4: Configure for floating (mutual) capacitance mode
	// Current value: 0x10 = 0001 0000
	// Set C_FLOATING (bit 0) = 1, C_DIFFERENTIAL (bit 1) = 1 for mutual capacitance
	// New value: 0x13 = 0001 0011
	Address = 4;
	data = 0x13;  // C_FLOATING=1, C_DIFFERENTIAL=1, others unchanged
	FLASH_SPI_CS_ENABLE();
	HAL_SPI_Transmit(&hspi2, &Opcode, 1, 10);
	HAL_SPI_Transmit(&hspi2, &Address, 1, 10);
	HAL_SPI_Transmit(&hspi2, &data, 1, 10);
	FLASH_SPI_CS_DISABLE();
	HAL_Delay(10);
	
	// Register 6: Enable only PC0, PC1, PC2, PC3 (disable PC4, PC5)
	// PC0=0x01, PC1=0x02, PC2=0x04, PC3=0x08
	// Total: 0x0F = 0000 1111
	Address = 6;
	data = 0x0F;  // Enable PC0~PC3 only
	FLASH_SPI_CS_ENABLE();
	HAL_SPI_Transmit(&hspi2, &Opcode, 1, 10);
	HAL_SPI_Transmit(&hspi2, &Address, 1, 10);
	HAL_SPI_Transmit(&hspi2, &data, 1, 10);
	FLASH_SPI_CS_DISABLE();
	HAL_Delay(10);
	
	USB_Printf("PCAP04 configured for mutual capacitance mode\r\n");
	USB_Printf("  PC0/PC1: Reference capacitance\r\n");
	USB_Printf("  PC2/PC3: Measurement capacitance\r\n");
	USB_Printf("  PC4/PC5: Disabled\r\n");
}

/**
  * @brief  Set float conversion flag
  * @param  enable: 1 to enable float conversion, 0 to disable (show raw hex)
  * @retval None
  */
void PCap04_SetFloatConversion(uint8_t enable)
{
	pcap04_use_float = enable ? 1 : 0;
	if(enable)
	{
		USB_Printf("PCAP04 float conversion: ENABLED\r\n");
	}
	else
	{
		USB_Printf("PCAP04 float conversion: DISABLED (raw hex)\r\n");
	}
}

