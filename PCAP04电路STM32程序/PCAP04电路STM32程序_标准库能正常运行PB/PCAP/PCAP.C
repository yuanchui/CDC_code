
#include "pcap.h"
#include "stm32f10x_conf.h"
#include "delay.h"
#include "sys.h"
#include "usart.h"

static	uint8_t  sysclk = 72;   //默认系统时钟为72MHz
static  uint8_t  fac_us=0;      //us延时倍乘数
static  uint16_t fac_ms=0;      //ms延时倍乘数 



u8 SPI_Read_Bit()
{	 																 //MCU IN
       u8 Read_Bit;
	   Read_Bit = GPIO_ReadInputDataBit(GPIOA,GPIO_Pin_6); 
	   return Read_Bit;
 }

void LED_OFF()	                                                     //LED点亮
{
       GPIO_ResetBits(GPIOD,GPIO_Pin_2);
 }
 
void LED_ON()											             //LED关闭
{
       GPIO_SetBits(GPIOD,GPIO_Pin_2);
}	

u32 spi_read(void)    
{
       u8 cnt;
       u32 rbuf32=0x00000000;
       for(cnt=24;cnt>0;cnt--)
       {
              SPI_SCLK_High; //CAP_SCK_SET;//SCK
              __3nop();
              rbuf32<<=1;
              if(SPI_Read_Bit() == 1)//PB14
                    rbuf32 |=1;
              SPI_SCLK_Low; //CAP_SCK_CLR;//SCK
              __3nop();
        }
       return(rbuf32);
}

//在SCK下降沿写入一个BIT
void spi_send_bit(u8 bbit)					    //SPI 时序  ok
{
//       SPI_Enable();
	   SPI_SCLK_High;
	   __3nop();
	   if(bbit == 1)
	   {
	          SPI_MOSI_High;
		}
	   else	if(bbit == 0)
	   {
	          SPI_MOSI_Low;
		}
	   __3nop();
	   SPI_SCLK_Low;
	   __3nop();

}


//写入一个8为数据
void write_date_8(u8 date)
{
       u8 cnt = 0;
       __3nop();
       SPI_Enable();
       __3nop();
	   __3nop();
       for(cnt=8;cnt>0;cnt--)
       {
              if((date&0x80)==0x80)
                     spi_send_bit(1);
              else
                     spi_send_bit(0);    
              date = date<<1;
        }
       __3nop();
       __3nop();
}


//写入一个16为数据
void write_date_16(u16 date)
{
       u8 cnt = 0;
       __3nop();
       SPI_Enable();
       __3nop();
	   __3nop();
       for(cnt=16;cnt>0;cnt--)
       {
              if((date&0x8000)==0x8000)
                     spi_send_bit(1);
              else
                     spi_send_bit(0);
              date = date<<1;
        }
       __3nop();
       __3nop();
}


//写入一个32为数据
void write_date_32(u32 date)
{
       u8 cnt;
       __3nop();
       SPI_Enable();
       __3nop();
	   __3nop();
       for(cnt=32;cnt>0;cnt--)
       {
              if((date&0x80000000)==0x80000000)
                     spi_send_bit(1);
              else
                     spi_send_bit(0);
              date = date<<1;
        }
       __3nop(); 
       __3nop();
}

void spi_test(void)
{
        u8 i;
        u8 tmp = 0x80;
        const u16 test_reg  =  0x0005;     //测试SRAM地址
        /*const*/ u8 test_data  =  0xA5;   //测试数据
        u8 test_read = 0x00;

        while(test_data!=test_read)
        {
                //写SRAM
				LED_ON();
                SPI_Disable();
                __3nop();
				__3nop();
                write_date_16(test_reg|0x9000);
                write_date_8(test_data);
                __3nop();
				
                //读SRAM
                tmp = 0x80;
                SPI_Disable();
                __3nop();
				__3nop();
                write_date_16(test_reg|0x1000);
                test_read=0x00;
			//	LED_OFF();
                for(i=8;i>0;i--)
                {
                       SPI_SCLK_High;
                       __3nop();
                       if(SPI_Read_Bit() == 1)
                       {
                              test_read |=tmp;
                              __3nop();
                              __3nop();
                        }  
                       tmp /=2;
                       SPI_SCLK_Low;
                       __3nop();
                 }
          
         }  

		LED_OFF();                   //如果读写测试成功，LED熄灭
		printf("成功        \r\n");  //51.9698
 
}

void write_firmware(void)
{
       const unsigned char PCAP01_Firmware[] = {
	        0x00, 0x00, 0x00, 0x62, 0x63, 0x00, 0x65, 0xBE, 0x01, 0x20, 0x26, 0x42, 0x5C, 0x48, 0xA0, 0x03,
	        0x21, 0xE4, 0x20, 0x31, 0xA1, 0x03, 0x21, 0xE4, 0x20, 0x31, 0x84, 0x01, 0x23, 0x63, 0x01, 0x00,
	        0x00, 0x00, 0x00, 0x00, 0x20, 0x0B, 0x43, 0x58, 0xC0, 0xFE, 0x43, 0xC0, 0x44, 0x7A, 0x7E, 0x20,
	        0x0B, 0xC0, 0xC0, 0xC0, 0xC8, 0xFF, 0x43, 0xED, 0x44, 0xC0, 0xC0, 0xC0, 0xF6, 0xFF, 0x43, 0xEC,
	        0x44, 0xC0, 0xC0, 0xC0, 0xC8, 0xFF, 0x41, 0x23, 0x94, 0xD0, 0x43, 0xEE, 0x44, 0xD2, 0x43, 0xEF,
	        0x44, 0x20, 0x5A, 0x70, 0x60, 0x71, 0x61, 0x78, 0x68, 0x02, 0x7A, 0xF3, 0x43, 0xC7, 0xFE, 0x41,
	        0xEB, 0x45, 0x5A, 0x21, 0xDF, 0x46, 0x46, 0x46, 0x46, 0xEC, 0x44, 0xC0, 0xC0, 0xC0, 0xC8, 0xFF,
	        0x43, 0x55, 0xED, 0x45, 0xEC, 0x51, 0xF4, 0x41, 0x23, 0x88, 0xEA, 0x45, 0xF5, 0x41, 0x23, 0x88,
	        0xE9, 0x45, 0x1D, 0x41, 0x43, 0x58, 0xEA, 0x21, 0x99, 0xE9, 0x50, 0x46, 0xEB, 0x44, 0xA9, 0x02,
	        0xEB, 0x59, 0x43, 0xCA, 0xFE, 0x41, 0x5C, 0xA8, 0x03, 0xC0, 0x5A, 0xEB, 0x45, 0xEB, 0x41, 0xF2,
	        0x45, 0xF6, 0x41, 0x23, 0x88, 0xEA, 0x45, 0xF7, 0x41, 0x23, 0x88, 0xE9, 0x45, 0x1F, 0x41, 0x43,
	        0x58, 0xEA, 0x21, 0x99, 0xE9, 0x50, 0x46, 0xEB, 0x44, 0xA9, 0x02, 0xEB, 0x59, 0x43, 0xCA, 0xFE,
	        0x41, 0x5C, 0xA8, 0x03, 0xC0, 0x5A, 0xEB, 0x45, 0xEB, 0x41, 0xF3, 0x45, 0x02, 0xFF, 0xFF, 0xFF, 
	        0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x7C, 0x7D, 0x45, 0x41, 0x02, 0x47, 0x47, 0x47,
	        0x47, 0x47, 0x47, 0x47, 0xF0, 0x7C, 0x6D, 0x45, 0x41, 0x6C, 0x7D, 0x45, 0x41, 0x02, 0x47, 0x47, 
	        0x47, 0x47, 0x47, 0x47, 0x47, 0xF0, 0x6C, 0x7D, 0x45, 0x41, 0x02, 0x47, 0x47, 0x47, 0x47, 0x47,
	        0x47, 0x47, 0xF0, 0x7C, 0x6D, 0x45, 0x41, 0x45, 0x41, 0x02, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47,
	        0x47, 0xF0, 0x7C, 0x6D, 0x45, 0x41, 0x02, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x47, 0x02, 0x4F,
	        0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F,
	        0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F,
	        0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x4F, 0x02, 
	        0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E,
	        0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E,
	        0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 0x4E, 
	        0x02, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 
	        0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56,
	        0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 0x56, 
	        0x56, 0x02, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 
	        0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E,
	        0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 0x5E, 
	        0x5E, 0x5E, 0x5E, 0x02, 0x6A, 0xFD, 0x43, 0x40, 0x4F, 0x4F, 0x4F, 0xEB, 0x45, 0x7A, 0xF9, 0x41, 
	        0x43, 0x58, 0xEB, 0x21, 0x99, 0xEA, 0x44, 0xC0, 0xC0, 0xC0, 0xF1, 0xFF, 0x43, 0xEC, 0x44, 0xC0,
	        0xC0, 0xC0, 0xC8, 0xFF, 0x41, 0xED, 0x45, 0xC0, 0x41, 0xC0, 0xC0, 0xC0, 0xF8, 0xFF, 0x43, 0xE9,
	        0x44, 0x6A, 0x1D, 0x43, 0xAB, 0x01, 0xEA, 0x58, 0x8E, 0x03, 0xEC, 0x53, 0x1D, 0x50, 0x1F, 0x44,
	        0xEC, 0x53, 0xED, 0x53, 0xE9, 0x43, 0xEC, 0x58, 0xAC, 0xE6, 0x8E, 0x26, 0xC0, 0xC0, 0xC0, 0xF9,
	        0xFF, 0x43, 0xEC, 0x44, 0xC0, 0xC0, 0xC0, 0xC8, 0xFF, 0x43, 0xED, 0x44, 0xC0, 0x41, 0xC0, 0xC0, 
	        0xC0, 0xFC, 0xFF, 0x43, 0xE9, 0x44, 0x1D, 0x43, 0x1F, 0x59, 0xE9, 0x43, 0xED, 0x53, 0xEC, 0x53,
	        0x58, 0xAC, 0xF2, 0x7A, 0xC0, 0xC0, 0xC0, 0xC9, 0xFF, 0x43, 0xEC, 0x44, 0xE7, 0x44, 0xE8, 0x44,
	        0xC0, 0xC0, 0xC0, 0xC8, 0xFF, 0x43, 0xED, 0x44, 0x1F, 0x43, 0x4E, 0x4E, 0x4E, 0x44, 0xC0, 0xC0, 
	        0xC0, 0xCF, 0xFF, 0x43, 0xE9, 0x44, 0x8E, 0x07, 0xC0, 0xC0, 0xC0, 0xCB, 0xFF, 0x43, 0xE9, 0x44, 
	        0x40, 0x5D, 0x1D, 0x43, 0x1F, 0x21, 0xCA, 0xE8, 0x43, 0xEC, 0x44, 0x1D, 0x45, 0xF8, 0x43, 0xAB,
	        0x0C, 0xC0, 0x41, 0xED, 0x53, 0x53, 0x1F, 0x43, 0x4E, 0x4E, 0x4E, 0x44, 0xE7, 0x53, 0xC0, 0x41, 
	        0xE8, 0x53, 0xE7, 0x53, 0x41, 0xEC, 0x45, 0xE9, 0x43, 0x5C, 0xAC, 0xD3, 0xC0, 0xC0, 0xC0, 0xCF, 
	        0xFF, 0x43, 0xE9, 0x44, 0xE8, 0x41, 0xE9, 0x43, 0x5C, 0xA8, 0x0C, 0xC0, 0x41, 0xE8, 0x43, 0x53,
	        0xEC, 0x44, 0x1D, 0x44, 0x59, 0x43, 0xAB, 0xEB, 0xC8, 0x43, 0x46, 0x46, 0x46, 0x44, 0x7A, 0x8A,
	        0x1B, 0xC0, 0x43, 0x40, 0x5D, 0x5D, 0x90, 0x15, 0xC8, 0x45, 0xC9, 0x45, 0xF8, 0x43, 0xAA, 0x0B, 
	        0xCA, 0x45, 0xCB, 0x45, 0xCC, 0x45, 0xCD, 0x45, 0xCE, 0x45, 0xCF, 0x45, 0x00, 0x02, 0xC0, 0x43,
	        0x4E, 0x4E, 0xEA, 0x44, 0xE9, 0x44, 0x8E, 0x06, 0xC0, 0x43, 0x4E, 0xEA, 0x44, 0xE9, 0x44, 0xF8, 
	        0x43, 0xAB, 0x13, 0xC0, 0x43, 0x4E, 0xEA, 0x44, 0x4E, 0x50, 0xE9, 0x44, 0x8E, 0x08, 0xC0, 0x43, 
	        0xEA, 0x44, 0x4E, 0x4E, 0x50, 0xE9, 0x44, 0xC0, 0xC0, 0xC0, 0xC8, 0xFF, 0x43, 0x4E, 0x4E, 0xE9,
	        0x51, 0x91, 0x01, 0x23, 0x5A, 0xEA, 0x43, 0xE9, 0x51, 0x92, 0x01, 0x23, 0x5A, 0xEA, 0x43, 0xE9, 
	        0x51, 0x93, 0x01, 0x23, 0x5A, 0xEA, 0x43, 0xE9, 0x51, 0x94, 0x01, 0x23, 0x5A, 0xEA, 0x43, 0xE9, 
	        0x51, 0x95, 0x01, 0x23, 0x5A, 0xEA, 0x43, 0xE9, 0x51, 0x96, 0x01, 0x23, 0x5A, 0xEA, 0x43, 0xE9,
	        0x51, 0x97, 0x01, 0x23, 0x5A, 0xEA, 0x43, 0xE9, 0x51, 0x02, 0xE9, 0x43, 0x46, 0x46, 0xEC, 0x44, 
	        0x1D, 0x45, 0x02, 0x7A, 0xFA, 0x41, 0x4F, 0x4F, 0x4F, 0xE7, 0x45, 0x5A, 0xFB, 0x43, 0xE7, 0x75,
	        0x21, 0xCA, 0x65, 0xD0, 0x45, 0x5A, 0xFC, 0x43, 0xE7, 0x21, 0xCA, 0xD1, 0x45, 0x5A, 0xFD, 0x43,
	        0xE7, 0x21, 0xCA, 0xD2, 0x45, 0x79, 0x69, 0x02, 0xD7, 0xFE, 0x43, 0xE7, 0x45, 0x5D, 0xAD, 0x01, 
	        0x5D, 0x45, 0x41, 0x02, 0x1F, 0x43, 0x1D, 0x44, 0xC0, 0x43, 0xEC, 0x51, 0xED, 0x51, 0x5D, 0xAA, 
	        0xF2, 0x02
       };
       u16 couter;
       u8  read_firmware[10];
       u8  i,tmp;

       for( couter = 0 ; couter <= 929 ; couter++ )
       {
             SPI_Disable();
             __3nop();
		     __3nop();
             write_date_16(couter|0x9000);
             write_date_8(PCAP01_Firmware[couter]);
             __3nop();
        }



       for( couter = 0 ; couter <= 9 ; couter++ )
       {
             tmp = 0x80;
             SPI_Disable();
             __3nop();
		     __3nop();
             write_date_16(couter|0x1000);
             read_firmware[couter]=0x00;
             for(i=8;i>0;i--)
             {
                    SPI_SCLK_High;
                    __3nop();
		            __3nop();
                    if(SPI_Read_Bit()==1)
                    {
                           read_firmware[couter] |= tmp;
                           __3nop();
		                   __3nop();
                     }
                    tmp /=2;
                    SPI_SCLK_Low;
                    __3nop();
		            __3nop();
              }
       }

}



void cap01_init(void)
{
    unsigned long int REG[11] = {
	0xC04200FF,//addr0 0xC04200FF
				 //0X4; 
				 //0Bxx(MECOMP):; 
				 //0B10; 
				 //0Xxx(ECC_MODE):; 
				 //0Xx(AUTOBOOT_DIS):; 
				 //0Xx(MEM_LOCK_DIS):; 
	0xC1201022,//addr1 0xC1201022 固定
	0xC21D182B,		//PC2 IS USED
	//0xC23D172B,	//PC0--PC4 IS used .ground mode,internal resistence is 30K,,outside discharge resistence--100ohm
	//0xC2031E0B,//addr2 0xC2031E0B
				 //0Xxx(CMEAS_PORT_EN):CDC使能,开启PC7-PC0; 0X03
				 //0Bxxxxx(CMEAS_BITS):传感器连接 00010-接地电容单一或差分 01000-漂移单一电容 10000-漂移差分电容; ? 0B00010
				 //0Bxxx(RDCHG_INT_SEL):内部电阻选择 100-180K 101-90K 110-30K 111-10K; 111 电阻越小频率越小精度越低
				 //0X0B; 
	//0xC30D0001,             
	0xC30D0064,//addr3 0xC30D0064
				 //0Bxx(CY_CLK_SEL):CDC循环的时钟基准 0-20us 2-1us(当外部4M晶振时) 3-0.25us(当外部4M晶振时);
				 //0B0;
				 //0Bxxxxx(SEQ_TIME):在时钟-触发模式设置触发的周期(TMEAS_TRIG_SEL=2) 0-关闭 ;
				 //0B0;
				 //0Bxx(CMEAS_FAKE):设定CDC每次测量的后的假测量次数，可从0到4选择;
				 //0Bxxx...(C_AVRG):CDC测量后内部平均的次数。设置为0无效，默认为1;
	0xC4080011,//addr4 0xC4080000
				 //0B00;
				 //0Bxx(CMEAS_STARTPIN):选择相应的输出电容测量的脉冲触发管脚 0-PG0 1-PG1 2-PG2 3-PG3;
				 //0Bxx(CMEAS_TRIG_SEL):选择电容测量的触发源 0-仅软件触发 1-持续模式 2-时钟触发模式 3-脉冲触发模式;
				 //0Bxxxxxxxxxx(CMEAS_CYTIME):设置用于电容测量的CDC周期时间 (CMEAS_CYTIME+1)*Clock_PeriodClock_period=20us/1us/0.25us根据CYCLKSEL=0/2/3;
				 //0B000;
				 //0Bx(TMEAS_CYTIME):设置用于温度测量的周期时间 0-140us(推荐) 1-280us;
				 //0Bxx(TMEAS_STARTPIN):选择用于温度测量的脉冲触发管脚 0-PG0 1-PG1 2-PG2 3-PG3;
				 //0Bxx(TMEAS_TRIG_SEL):选择温度测量的触发源.选项2和3请不要应用; 0-关闭/操作码触发 1-CMEAS-触发(通过C-测量,推荐) 2-时钟触发模式 3-脉冲触发模式
	0xC5000000,//addr5 0xC5000000
				 //0Bxx(T_AVRG):0-1无平均 1-4次平均 2-8次平均 3-16次平均; 
				 //0Bxxx...(TMEAS_TRIG_PREDIV):RDC相对于CDC的测量出现的次数 0为1次; 
	0xC6000040,//addr6 0xC6000040
				 //0X00; 
				 //0Bx(TMEAS_FAKE):0-2次假测量 1-8次假测量; 
				 //0Bxxxxxxx(TMEAS_7BITS):选择温度补偿的连接方式; ?
				 //0X40; ?
	0xC71F0000,//addr7 0xC71F0000 固定
	0xC8800010,//addr8 0xC8800030 DSP设置
	0xC9FF000F,//addr9 0xC9FF000F PWM/PDM设置
	0xCA180047,//addr10 0xCA180087
				 //0X1800
				 //0Xxx(V_CORE_CTL):控制1.8 V 核心电压调节器 0x47-标准 0x87-低功耗	
	};

	SPI_Enable();
	delay_ms(1);
	write_date_8(0x88);        //上电复位。复位所有状态。
	delay_ms(1);

	spi_test();  	           //测试 通讯是否正常

	//SPI_Enable();
	//delay_ms(1);
	//write_date_8(0x88);        //上电复位。复位所有状态。
	//delay_ms(1);

	write_firmware();

	SPI_Disable();
	__3nop();
	write_date_32(0xc04200FF);   //寄存器0设置：关闭SRAM与OTP比较;关闭OTP内部错误检测与修复;配置为单从机模式。打开写入读出保护。
	//write_date_32(REG[0]);
	
	SPI_Disable();
	__3nop();
    write_date_32(0xC1201022);   //寄存器1设置,固定写入。
	//write_date_32(REG[1]);

    SPI_Disable();
	__3nop();
//    write_date_32(0xc203150B);   //寄存器2设置,pc0 pc7输入测量。接地测量模式。内部放电电阻90K
	write_date_32(0xC2FF450B);       //寄存器2设置,开启所有电容引脚 ， 漂移单一电容
	//write_date_32(REG[2]);

    SPI_Disable();
	__3nop();
    write_date_32(0xc3062001);   //寄存器3设置,测量周期为20us;时钟触发测量模式。5.24s触发一次测量。200次平均测量。2次假测量（前两次数据丢弃）
	//write_date_32(REG[3]);

    SPI_Disable();
	__3nop();
    write_date_32(0xc4080510);   //触发方式选择。定时器触发。
	//write_date_32(REG[4]);	

	SPI_Disable();
	__3nop();
    write_date_32(0xc5000000);   //无平均
	//write_date_32(REG[5]);	

	SPI_Disable();
	__3nop();
    write_date_32(0xc6004140);   //
	//write_date_32(REG[6]);	

	SPI_Disable();
	__3nop();
    write_date_32(0xc71F0000);    //固定写入
	//write_date_32(REG[7])	;

	SPI_Disable();
	__3nop();
    write_date_32(0xc8800010);     //内部单片机程序存储空间选择。
	//write_date_32(REG[8]);	

	SPI_Disable();
	__3nop();
    write_date_32(0xc9BF208F);     //设置PWM输出引脚。输出数据位数。
	//write_date_32(REG[9]);	

	SPI_Disable();
	__3nop();
    write_date_32(0xca180047);     //设置内部DSP工作电压。	
	//write_date_32(REG[10]);	

	SPI_Disable();
	__3nop();
    write_date_32(0xcd000007);    //设置输出数据为c7/c0 寄存器13
	//write_date_32(REG[11]);	

	SPI_Disable();
	__3nop();
	write_date_32(0xce002ff0);    //设置输出数据的斜率 寄存器14	
	
	SPI_Disable();
	__3nop();
	write_date_32(0xcf000000);    //设置输出数据的偏置 寄存器15
	
	SPI_Disable();
	__3nop();
  	write_date_32(0xD3200000);    //芯片开始工作。
	__3nop();

	
	SPI_Disable();
	__3nop();
    write_date_32(0xD4000001);    //芯片开始工作。
	__3nop();
	
	SPI_Disable();
	__3nop();
	write_date_8(0x8a);           //复位输出结果数据。
	__3nop();

    SPI_Disable();
	__3nop();
	write_date_8(0x8c);         //开始电容测量。

}




