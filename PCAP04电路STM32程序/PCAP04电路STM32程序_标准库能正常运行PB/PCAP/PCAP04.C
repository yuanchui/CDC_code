#include "pcap.h"
#include "stm32f10x_conf.h"
#include "delay.h"
#include "sys.h"
#include "usart.h"
#include "STM32_VSPI.h"
#include "PCAP04.h"
#include "stm32f10x_gpio.h"
#include "stm32f10x_rcc.h"


//=====================================
// Firmware 代码
//-------------------------------------
static const  u8 PCAP04_Firmware[] =
{
	//Read Memory
 0x24,0x05,0xA0,0x01,0x20,0x55,0x42,0x5C,0x48,0xB1,0x07,0x92,0x02,0x20,0x13,0x02  //0
,0x20,0x93,0x02,0xB2,0x02,0x78,0x20,0x54,0xB3,0x06,0x91,0x00,0x7F,0x20,0x86,0x20  //16
,0x54,0xB6,0x03,0x72,0x62,0x20,0x54,0xB7,0x00,0x00,0x42,0x5C,0xA1,0x00,0x49,0xB0  //32
,0x00,0x49,0x40,0xAB,0x5D,0x92,0x1C,0x90,0x02,0x7F,0x20,0x86,0x66,0x67,0x76,0x77  //48
,0x66,0x7A,0xCF,0xCD,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x7A,0xDC,0xE7,0x41,0x32,0xAA  //64
,0x01,0x99,0xFD,0x7B,0x01,0x7A,0xCF,0xEB,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x7A,0xC1  //80
,0xE7,0x41,0x32,0x6A,0xDE,0x44,0x7A,0xCF,0xEA,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x6A  //96
,0xDF,0x44,0x7A,0xC4,0xE7,0x41,0x32,0xAB,0x05,0x7A,0xC1,0xE1,0x43,0xE0,0x3A,0x7A  //112
,0xC0,0xE1,0x43,0xE0,0x3A,0x02,0x7A,0xCF,0xE6,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x7A  //128
,0xEF,0x44,0x02,0x20,0x9D,0x84,0x01,0x21,0x2E,0x21,0x74,0x20,0x37,0xC8,0x7A,0xE7  //144
,0x43,0x49,0x11,0x6A,0xD4,0x44,0x7A,0xC1,0xD8,0xE6,0x43,0xE9,0x44,0x1C,0x43,0x13  //160
,0xAB,0x63,0x6A,0xDE,0x41,0xAB,0x0B,0x46,0x46,0x46,0x7A,0xDF,0xFF,0xFF,0xFF,0xFF  //176
,0xE3,0x41,0x32,0x1C,0x44,0xE9,0x13,0x6A,0xD4,0x13,0x41,0xAA,0xDF,0x7A,0xC5,0xE1  //192
,0x43,0x49,0xE0,0x34,0x7A,0xCF,0xE3,0xE6,0x43,0xF1,0x44,0x29,0xE0,0xDB,0xC0,0x27  //208
,0xE5,0x6A,0xDF,0x43,0x7A,0xC8,0xE7,0x41,0x30,0xAB,0x03,0x86,0x01,0x92,0x37,0x7A  //224
,0xC6,0xE7,0x41,0x7A,0xFA,0xE7,0x43,0xEA,0x44,0x7A,0xC1,0xE1,0xE6,0x43,0xE9,0x44  //240
,0x25,0xE0,0x7A,0xC6,0xE7,0x41,0x7A,0xFA,0xE7,0x43,0xEA,0x44,0x7A,0xC0,0xE7,0x43  //256
,0xE9,0x44,0x25,0xE0,0x92,0x10,0x7A,0xE1,0x44,0xE2,0x44,0xE3,0x44,0xE4,0x44,0xE5  //272
,0x44,0xE6,0x44,0xE7,0x44,0xE8,0x44,0xC1,0xD8,0x24,0x3E,0x92,0xFF,0x02,0x7A,0xCF  //288
,0xD7,0xE6,0x43,0xF1,0x44,0x7A,0xD0,0xE7,0x43,0x2A,0x2A,0x32,0xAB,0x03,0x42,0x5C  //304
,0x92,0x03,0x7A,0xC0,0xE1,0x43,0xD9,0x27,0x90,0x6A,0xDF,0x43,0x7A,0xC8,0xE7,0x41  //320
,0x32,0xAB,0x03,0x86,0x01,0x92,0x11,0x7A,0xC2,0x43,0x7A,0xE7,0x44,0x6A,0xC6,0x44  //336
,0x7A,0xC3,0x43,0x7A,0xE8,0x44,0x6A,0xC7,0x44,0xC1,0xD4,0x24,0x57,0x7A,0xC8,0xE1  //352
,0x43,0xE0,0x3A,0x02,0x7A,0xCF,0xE7,0xE6,0x43,0xF1,0x44,0x29,0xE0,0x7A,0xC7,0xE1  //368
,0x41,0x6A,0xD4,0x45,0x5A,0x25,0x36,0x46,0x46,0x46,0x46,0x7A,0xE9,0x44,0x7A,0xC0  //384
,0xE7,0x43,0x55,0x7A,0xEA,0x45,0x7A,0xE9,0x51,0x1C,0x43,0x6A,0xCA,0x44,0x1D,0x43  //400
,0x6A,0xCB,0x44,0x74,0xC1,0xCA,0xE6,0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x7A,0xCC  //416
,0xE0,0xE6,0x41,0x2C,0x42,0x7A,0xC5,0xE1,0x43,0x49,0xE0,0x34,0x7A,0xC1,0xCC,0xE6  //432
,0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x2C,0x70,0x7A,0xCC,0x43,0x7A,0xCF,0x44,0x7A  //448
,0xCD,0x43,0x7A,0xCE,0x44,0x6A,0xCA,0x43,0xC1,0xCA,0x7A,0xE6,0x41,0xE9,0x45,0x2B  //464
,0xAE,0xEE,0x44,0x7A,0xC1,0xCA,0xE6,0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x7A,0xCC  //480
,0xEC,0xE6,0x41,0x2C,0x42,0x7A,0xC5,0xE1,0x43,0x49,0xE0,0x34,0x7A,0xC1,0xCC,0xE6  //496
,0x43,0xE9,0x44,0x7A,0xC1,0xE1,0x43,0x2C,0x70,0x7A,0xCC,0x43,0x7A,0xCF,0x44,0x7A  //512
,0xCD,0x43,0x7A,0xCE,0x44,0x6A,0xCB,0x43,0xC1,0xCA,0x7A,0xE6,0x41,0xE9,0x45,0x2B  //528
,0xAE,0xED,0x44,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //544
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //560
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //576
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //592
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //608
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //624
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //640
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //656
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //672
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //688
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //704
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //720
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //736
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //752
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //768
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //784
,0x35,0x33,0x33,0x07,0xCD,0xCC,0xCC,0x08,0x01,0x00,0xFE,0x03,0x66,0x66,0x66,0x01  //800
,0x33,0x33,0x33,0x02,0x01,0x00,0xFE,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //816
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //832
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //848
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //864
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //880
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //896
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //912
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //928
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //944
,0x1D,0x00,0x58,0x10,0x10,0x00,0x0F,0x20,0x00,0xD0,0x07,0x00,0x00,0x08,0xFF,0x03  //960
,0x00,0x24,0x00,0x00,0x00,0x01,0x50,0x30,0x73,0x04,0x50,0x08,0x5A,0x00,0x82,0x08  //976
,0x08,0x00,0x47,0x40,0x00,0x00,0x00,0x71,0x00,0x03,0x08,0x00,0x00,0x00,0x00,0x01  //992
,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00  //1008

};
	
u8 ReadFirmwareBuff[1025];


//******************************************************************************
// 函数功能: PCAP04引脚初始化
// 函数参数: 无
// 返 回 值: 无
// 说    明: 无
//******************************************************************************
void PCAP04_Config(void)
{
  GPIO_InitTypeDef  GPIO_InitStructure;
	VSPI_Configuration();
	// CS
//	GPIO_SetPinMode(PCAP04_CS_PORT, PCAP04_CS_PIN, GPIO_Mode_Out_PP, GPIO_Speed_50MHz);
 GPIO_InitStructure.GPIO_Pin = PCAP04_CS_PIN;				 //LED0-->PA.12端口配置
 GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP; 		 //推挽输出
 GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;		 //IO口速度为50MHz
 GPIO_Init(PCAP04_CS_PORT, &GPIO_InitStructure);					 //根据设定参数初始化GPIOA.8
	
	PCAP04_CS_H();
	delay_ms(10); 
	
	PCAP04_Init();
}

char PCap04_Test(void)//测试通讯
{
	u8 ucReadByte;
	PCAP04_CS_L();
	PCap04_WriteByte(0x7e);//PCAP04_TEST_READ);     // 测试代码
	ucReadByte = PCap04_ReadByte();         // 读取TEST_READ的结果
	PCAP04_CS_H();
	
	printf("打印：%x\r\n",ucReadByte); 
	
		if(ucReadByte == 0x11)
	{
		return 1;
	}
		return 0;
}
//******************************************************************************
// 函数功能: PCAP04芯片功能初始化
// 函数参数: 无
// 返 回 值: 无
// 说    明: 无
//******************************************************************************
void PCAP04_Init(void)
{
  u8 ucReadByte;

	PCAP04_CS_L();
	PCap04_WriteByte(0x7e);//PCAP04_TEST_READ);     // 测试代码
	ucReadByte = PCap04_ReadByte();         // 读取TEST_READ的结果
	PCAP04_CS_H();
	
	printf("打印：%x\r\n",ucReadByte); 
	
	
	
	if(ucReadByte == PCAP04_TEST_CORRECT)    // 判断是否0x11，是否正常？
	{
		
		delay_ms(10);
		PCAP04_CS_L(); 
		PCap04_WriteByte(PCAP04_POR);         // 系统复位
		PCap04_WriteByte(PCAP04_INIT);        // 芯片初始化
		PCAP04_CS_H();
		delay_ms(20);
		printf("----------\r\n");
		PCAP04_WriteFirmware();
		printf("----------\r\n");
		delay_ms(30);
//		PCAP04_ReadFirmware();
		delay_ms(10);
		PCAP04_CS_L();
		
		PCap04_WriteByte(0xA3);		//NVRAM调用
		PCap04_WriteByte(0xF6);
		PCap04_WriteByte(0x59);
		PCap04_WriteByte(0x99);
		
		
		
		
		PCAP04_CS_H();
		
		PCAP04_CS_L();  
		PCap04_WriteByte(PCAP04_CDC_START);   // CDC功能初始化
		PCap04_WriteByte(PCAP04_RDC_START);   // RDC功能初始化
		PCAP04_CS_H();
		delay_ms(100); 
		printf("----------\r\n");
	}
}


//******************************************************************************
// 函数功能: 向PCAP04写Firmware固件函数
// 函数参数: 无
// 返 回 值: 无
// 说    明: 无
//******************************************************************************
void PCAP04_WriteFirmware(void)
{
	u16 i;

	PCAP04_CS_L();

	PCap04_WriteByte(0xA0);
	PCap04_WriteByte(0x00);
	for(i=0; i<1024; i++)                       // 固件长度为1K
	{
		PCap04_WriteByte(PCAP04_Firmware[i]);
	}

	PCAP04_CS_H();  
	delay_ms(2); 
}

//******************************************************************************
// 函数功能: 向PCAP04读Firmware固件函数
// 函数参数: 无
// 返 回 值: 无
// 说    明: 无
//******************************************************************************
void PCAP04_ReadFirmware(void)
{
	u16 i;

	PCAP04_CS_L();

	PCap04_WriteByte(0x20);
	PCap04_WriteByte(0x00);
	for(i=0; i<1024; i++)                       // 固件长度为1K
	{
		ReadFirmwareBuff[i]=PCap04_ReadByte();
	}

	PCAP04_CS_H();  
	delay_ms(2); 
}

void PCAP04_Readjcq(void)
{
	u8 i;

	PCAP04_CS_L();

	PCap04_WriteByte(0xA3);
	PCap04_WriteByte(0xC0);

	

	PCap04_WriteByte(0xF6);
	PCAP04_CS_H();

	delay_ms(100); 
	PCAP04_CS_L();

	PCap04_WriteByte(0x93);
	PCap04_WriteByte(0xC0);

	PCap04_WriteByte(0x1F);

//	i=PCap04_ReadByte();
	PCAP04_CS_H();
	printf("打印：%x\r\n",i); 
	delay_ms(2); 
}
//******************************************************************************
// 函数功能: 从PCAP04读取电容比值结果
// 函数参数: 无
// 返 回 值: 无
// 说    明: 无
//******************************************************************************
double PCAP04_Read_CDC_Result(void)
{
	u32 u32Val;
	double dCapRatio;

	PCAP04_CS_L();
	
	// Res0,地址为0X40+0
	PCap04_WriteByte(PCAP04_READ_RESULT);
	u32Val  = PCap04_ReadByte();
	u32Val |= ((u32)PCap04_ReadByte()<<8);
	u32Val |= ((u32)PCap04_ReadByte()<<16);
	u32Val |= ((u32)PCap04_ReadByte()<<24);

	PCAP04_CS_H();
	delay_ms(2); 

//	dCapRatio = u32Val;
	dCapRatio = (double)u32Val * C_DotParm * C_Factor;  

	return dCapRatio;
}

u32 PCAP04_Read_CDC_Result_data(int data)
{
	u32 u32Val;
	u32 dCapRatio;
	u32 integer,fractional;
	double integrated ;
	
	PCAP04_CS_L();
	// Res0,地址为0X40+0
	PCap04_WriteByte(PCAP04_READ_RESULT + (data*4));
	u32Val  = PCap04_ReadByte();
	u32Val |= ((u32)PCap04_ReadByte()<<8);
	u32Val |= ((u32)PCap04_ReadByte()<<16);
	u32Val |= ((u32)PCap04_ReadByte()<<24);
//	delay_ms(2); 
	PCAP04_CS_H();
	

	dCapRatio = u32Val;
//	dCapRatio = (double)u32Val * C_DotParm * C_Factor;  
	
	integer = (u32Val >> 27) & 0x1F;
	fractional = u32Val  & 0x7FFFFF;

	integrated = (double)(integer + (double)((integer) * 0.000000001));
	return u32Val;
}



void printf_integrated(void)
{
	u32 data =0x11D68827,integer;

	u32 fractional;
	u32 integrated ;
	double i,j;
	integer = (data >> 27) & 0x1F;
	fractional = data  & 0x7FFFFFF;
	j = integer*10.0;
	printf("对比数据integer：%f\r\n",j);
	printf("对比数据fractional：%X\r\n",fractional);	
	i =(double)(fractional/13421779.41088971);
	printf("对比数据fractional：%f\r\n", i);	

	i = (i + j);
	printf("对比数据integrated：%f\r\n",i);	
	printf("--------------\r\n");
	
	
//	printf("数据integrated：%d\r\n",(0x11D68827 * 134217730.065902));	
	
}


///******************************************************************************
// 函数功能: 从PCAP04读取电阻比值结果
// 函数参数: 无
// 返 回 值: 无
// 说    明: 无
//******************************************************************************
double PCAP04_Read_RDC_Result(void)
{
	u32 Val;
	double dResRatio;

	PCAP04_CS_L(); 

	// Res6,地址为0X40+24
	PCap04_WriteByte(PCAP04_READ_RESULT|24);      // 读取电阻转换结果，4字节   
	Val  = PCap04_ReadByte();
	Val |= ((u32)PCap04_ReadByte()<<8);
	Val |= ((u32)PCap04_ReadByte()<<16);
	Val |= ((u32)PCap04_ReadByte()<<24);

	PCAP04_CS_H();
	delay_ms(2); 

	dResRatio = (double)Val * R_DotParm * R_Factor * 1000;//1000为内部参考电阻

	return dResRatio;
}

u32 PCAP04_Read_RDC_Result_data(void)
{
	u32 Val;
	double dResRatio;

	PCAP04_CS_L(); 

	// Res6,地址为0X40+24
	PCap04_WriteByte(PCAP04_READ_RESULT|24);      // 读取电阻转换结果，4字节   
	Val  = PCap04_ReadByte();
	Val |= ((u32)PCap04_ReadByte()<<8);
	Val |= ((u32)PCap04_ReadByte()<<16);
	Val |= ((u32)PCap04_ReadByte()<<24);

	PCAP04_CS_H();
	delay_ms(2); 

//	dResRatio = (double)Val * R_DotParm * R_Factor * 1000;//1000为内部参考电阻
	dResRatio = Val;//1000为内部参考电阻
	return dResRatio;
}
